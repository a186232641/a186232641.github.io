<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql实战45讲读书笔记</title>
      <link href="/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一条SQL查询语句是如何执行的？"><a href="#1-一条SQL查询语句是如何执行的？" class="headerlink" title="1. 一条SQL查询语句是如何执行的？"></a>1. 一条SQL查询语句是如何执行的？</h2><p><img src="/../images/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p><ol><li><p>Server 层</p><ol><li>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等）</li></ol></li><li><p>存储引擎层</p><ol><li>存储引擎层负责数据的存储和提取</li><li>架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</li><li>执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB</li><li>你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表</li></ol></li></ol><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist #查看全部连接</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait_timeout #控制客户端无动静后最长的连接时间</span><br><span class="line">SHOW VARIABLES LIKE &#x27;wait_timeout&#x27;;</span><br><span class="line">SET GLOBAL wait_timeout = &lt;desired_timeout_in_seconds&gt;;</span><br></pre></td></tr></table></figure><p>连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><ol><li>长连接<ol><li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接</li></ol></li><li>短连接<ol><li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li></ol></li></ol><p>使用长连接后存在的问题</p><ol><li>内存占用太大被系统杀掉，mysql表现异常重启</li></ol><p>如何解决</p><ol><li>定期断开长连接。</li><li>MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>缓存以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p><strong>缓存失效非常快</strong></p><h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><ol><li><p>词法分析</p><ol><li>你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么</li><li>如识别”select”这个关键字</li></ol></li><li><p>语法分析</p><p>词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法</p></li></ol><h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><p>选择走哪个索引</p><h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><ol><li>检查执行权限<ol><li>无<ol><li>返回没有权限错误</li></ol></li><li>有<ol><li>调用存储引擎层接口</li></ol></li></ol></li></ol><h2 id="2-日志系统：一条SQL更新语句是如何执行的？"><a href="#2-日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="2. 日志系统：一条SQL更新语句是如何执行的？"></a>2. 日志系统：一条SQL更新语句是如何执行的？</h2><ol><li>更新语句会把表T上所有缓存结果都清空</li><li>分析器会通过词法和语法解析知道这是一条更新语句</li><li>优化器决定要使用ID这个索引。</li><li>执行器负责具体执行，找到这一行，然后更新</li></ol><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><p>redo log是<strong>InnoDB引擎特有的日志</strong></p><p>Redo log 比作粉板 mysql比作账本</p><p>粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体流程：</p><p>InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。</p><p>循环写</p><p>write pos是当前记录的位置一边写一边后移、checkpoint是当前要擦除的位置也是往后推移并且循环的，擦除记录前要把记录更新到数据文件</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong></p><p><img src="/../images/16a7950217b3f0f4ed02db5db59562a7.png" alt="img"></p><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog(归档日志)"></a>binlog(归档日志)</h4><ol><li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>update语句的内部流程</p><p><img src="/../images/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img"></p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p> Redo Log 进入 Prepared 状态时，表示该事务的 Redo Log 已经被<strong>持久化到磁盘</strong>，但还没有提交。</p><p>通过将 binlog 持久化到磁盘</p><p>为什么需要两阶段提交？</p><p>redo log和binlog是两个<strong>独立的逻辑</strong>，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><ol><li><p><strong>先写redo log后写binlog</strong></p><p>假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的<strong>binlog里面就没有这条语句</strong>。</p><p>如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</p></li><li><p><strong>先写binlog后写redo log</strong></p></li></ol><p>​如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my.cnf</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line">sync_binlog = 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-事务隔离：为什么你改了我还看不见？"><a href="#3-事务隔离：为什么你改了我还看不见？" class="headerlink" title="3. 事务隔离：为什么你改了我还看不见？"></a>3. 事务隔离：为什么你改了我还看不见？</h2><h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p><ol><li>脏读（dirty read）</li><li>不可重复读（non-repeatable read）</li><li>幻读（phantom read）</li></ol><p>SQL标准的事务隔离级别包括：</p><ol><li><p>读未提交（read uncommitted）</p><p>一个事务还没提交时，它做的变更就能被别的事务看到</p></li><li><p>读提交（read committed）</p><p>一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>可重复读（repeatable read）</p><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</p></li><li><p>串行化（serializable ）</p><p>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure></li></ol><p><img src="/../images/7dea45932a6b722eb069d2264d0066f8.png" alt="img"></p><ol><li><p>读未提交</p><p>V1、V2、V3 都是2</p></li><li><p>读提交</p><p>V1&#x3D;1、V2、V3 都是2</p></li><li><p>可重复读</p><p>V1 v2都是1、 v3是2</p></li><li><p>串行化</p><p>事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。</p><p> V1、V2值是1，V3的值是2。</p></li></ol><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p><img src="/../images/d9c313809e5ac148fc39feff532f0fee.png" alt="img"></p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><p>这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><h4 id="什么时候删除回滚日志"><a href="#什么时候删除回滚日志" class="headerlink" title="什么时候删除回滚日志"></a>什么时候删除回滚日志</h4><p>在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p><h4 id="为什么建议你尽量不要使用长事务"><a href="#为什么建议你尽量不要使用长事务" class="headerlink" title="为什么建议你尽量不要使用长事务"></a>为什么建议你尽量不要使用长事务</h4><p>这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><h4 id="如何避免长事务"><a href="#如何避免长事务" class="headerlink" title="如何避免长事务"></a>如何避免长事务</h4><ol><li>确认是否使用了set autocommit&#x3D;0。确认是否使用了set autocommit&#x3D;0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</li><li>只读事务可以去掉</li><li>业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li><li>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警&#x2F;或者kill；</li><li>把innodb_undo_tablespaces设置成2（或更大的值）。</li></ol><h4 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h4><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li><li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit work and chain #提交事务并自动启动下一个事务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60#查找持续时间超过60s的事务</span><br></pre></td></tr></table></figure><h2 id="4-深入浅出索引（上）"><a href="#4-深入浅出索引（上）" class="headerlink" title="4. 深入浅出索引（上）"></a>4. 深入浅出索引（上）</h2><p>给表添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_username ON users (username);</span><br><span class="line">CREATE INDEX idx_username_email ON users (username, email);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建时添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">列定义后面使用 INDEX 或 KEY 关键字来实现。</span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    username VARCHAR(255),</span><br><span class="line">    email VARCHAR(255),</span><br><span class="line">    INDEX idx_username (username),</span><br><span class="line">    INDEX idx_email (email)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    username VARCHAR(255),</span><br><span class="line">    email VARCHAR(255),</span><br><span class="line">    KEY idx_username (username),</span><br><span class="line">    KEY idx_email (email)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何删除索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_username ON users;</span><br><span class="line">想删除 users 表上的 PRIMARY KEY 索引</span><br><span class="line">ALTER TABLE users DROP PRIMARY KEY;</span><br><span class="line">如果要删除的索引是唯一索引</span><br><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><p><img src="/../images/dcda101051f28502bd5c4402b292e38d.png" alt="img"></p><p>索引类型</p><ol><li><p>主键索引 ｜ 聚簇索引</p><p>主键索引的叶子节点存的是整行数据</p></li><li><p>非主键索引 ｜ 二级索引</p><p>非主键索引的叶子节点内容是主键的值</p></li></ol><p>查询非主键索引会查到主键id 然后从主键树中查找 id并返回数据，叫做回表</p><h4 id="基于主键索引和普通索引的查询有什么区别？"><a href="#基于主键索引和普通索引的查询有什么区别？" class="headerlink" title="基于主键索引和普通索引的查询有什么区别？"></a>基于主键索引和普通索引的查询有什么区别？</h4><ul><li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为<strong>回表</strong>。</li></ul><h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>如果插入id为400 但R5所在的页满，会导致页分裂</p><p>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>解决办法</p><ol><li>使用自增主键</li></ol><p>​自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p><p><strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><h2 id="5-深入浅出索引（下）"><a href="#5-深入浅出索引（下）" class="headerlink" title="5. 深入浅出索引（下）"></a>5. 深入浅出索引（下）</h2><p><img src="/../images/dcda101051f28502bd5c4402b292e38d-20240525220555522.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where k between 3 and 5</span><br></pre></td></tr></table></figure><ol><li>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</li><li>再到ID索引树查到ID&#x3D;300对应的R3；</li><li>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</li><li>再回到ID索引树查到ID&#x3D;500对应的R4；</li><li>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。</li></ol><p><strong>回到主键索引树搜索的过程，我们称为回表</strong></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>select ID from T where k between 3 and 5，这时只需要<strong>查ID的值</strong>，而<strong>ID的值已经在k索引树</strong>上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p><strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p><img src="/../images/89f74c631110cfbc83298ef27dcd6370.jpg" alt="img"></p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p><p>你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p><p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><h4 id="在建立联合索引的时候，如何安排索引内的字段顺序"><a href="#在建立联合索引的时候，如何安排索引内的字段顺序" class="headerlink" title="在建立联合索引的时候，如何安排索引内的字段顺序"></a><strong>在建立联合索引的时候，如何安排索引内的字段顺序</strong></h4><p>当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>在索引遍历过程中，对索引中包含的字段先做判断</p><p><img src="/../images/b32aa8b1f75611e0759e52f5915539ac.jpg" alt="img"></p><p>索引下推的执行流程</p><p><img src="/../images/76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
