<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理总结</title>
      <link href="/2024/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
      <url>/2024/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件工程</title>
      <link href="/2024/11/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>/2024/11/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>需求分析阶段的工作可以概括为：需求获取、需求分析、编写需求规格说明书、需求评审四个方面。软件需求规格说明书是描述需求中的重要文档，是软件需求分析的主要成果。</p><p> 1.软件开发的常用四个模型 </p><p>  （1）  瀑布模型：将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。 </p><p>  （2）  快速原型模型：第一步是建造一个快速原型，实现客户或未来的用户与系统的交互，用户或客户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足客户的要求，开发人员可以确定客户的真正需求是什么；第二步则在第一步的基础上开发客户满意的软件产品 </p><p>  （3）  增量模型：软件被作为一系列的增量构件来设计、实现、集成和测试，每一个构件是由多种相互作用的模块所形成的提供特定功能的代码片段构成。增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到所开发的软件，从而降低开发风险。 </p><p>  （4）  螺旋模型：兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失 ，螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足 </p><p>  螺旋模型沿着螺线进行若干次迭</p><p><strong>系统流程图</strong>是用图形符号来表示系统中的各个元素，例如人工处理、数据库、设备等，流程图表达了系统中各个元素之间的信息流动情况。是描绘<strong>物理系统</strong>的传统工具。</p><p>度量效益的方法：<strong>货币的时间价值 投资回收期 纯收入 投资回收率</strong>     </p><p>CMMI将软件能力成熟度认证分为五个等级，分别是初始级（Level 1）、可管理级（Level 2）、已定义级（Level 3）、已量化管理级（Level 4）和优化级（Level 5）。     </p><p>常用的黑盒测试方法有：<strong>等价类划分法</strong>；边界值分析法；<strong>因果图法</strong>；<strong>场景法</strong>；正交实验设计法；判定表驱动分析法；<strong>错误推测法</strong>；功能图分析法。</p><p>白盒测试的测试方法有<strong>代码检查法</strong>、静态结构分析法、<strong>静态质量度量法</strong>、逻辑覆盖法、基本路径测试法、域测试、符号测试、路径覆盖和程序变异。<br>白盒测试法的覆盖标准有逻辑覆盖、循环覆盖和基本路径测试。其中<strong>逻辑覆盖</strong>包括语句覆盖、判定覆盖、条件覆盖、判定&#x2F;条件覆盖、<strong>条件组合覆盖</strong>和修改条件判断覆盖。</p><p>SAX解析xml 文件：</p><p>  优点：不用事先调入整个文档，占用资源少。尤其在嵌入式环境，如Android,极力推荐采用SAX进行解析。</p><p>缺点：不像DOM一样将文档树长期留驻在内存，数据不是长久的。事件过后，若没保存数据，那么数据就会丢失。</p><p>  使用场合：机器有性能限制，尤其是在嵌入式环境。</p><p>用例（use case）用来描述系统在对事件做出响应时所采取的行动，即它确定了一个与系统参与者进行交互、并由系统执行的动作序列。可见，<strong>一个用例本身并不是一个功能需求</strong>，<strong>它代表了系统的一个单一的目标，是一个行为上相关的步骤序列。</strong><br>用例将系统的功能范围分解成许多小的系统功能陈述。</p><p>需求分析阶段建立三种模型：<strong>数据模型 E-R图     ；功能模型  数据流图（DFD图），系统流程图；行为模型   STD图</strong>  层次方框图-数据层次结构 </p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>根据PMBOK指南，项目章程应该包括的主要内容如下：<br> 1、概括性的项目描述和产品描述。<br> 2、概括性的项目描述，包括项目的总体范围和总体质量要求。<br> 3、可测量的项目目标和相关的成功标准。<br> 4、项目的主要风险，例如，可以列出项目的主要风险类别。<br> 5、总体里程碑进度计划。<br> 6、总体预算，可以是一个概算区间，例如，在100万元至130万元之间。<br> 7、委派的项目经理及其职责和职权。<br>  8、发起人或其他批准项目章程的人员的姓名和职权。 </p><p><strong>软件生命期</strong>一般包括以下各阶段： 软件生命周期，</p><p>分为三大阶段，计划阶段，开发阶段，运行阶段。 </p><p> 计划阶段：问题定义，可行性分析。  </p><p>开发时期：需求分析，概要分析，详细设计，编码，测试。 </p><p>运行阶段：运行。 </p><p>软件计划与可行性研究（问题定义、可行性研究） </p><p>需求分析 </p><p>软件设计（概要设计和详细设计） </p><p>编码 </p><p>软件测试 </p><p>运行与维护</p><p>概要设计：在需求分析之后进行，关注系统整体结构、模块间的关系以及主要组件。<br>详细设计：概要设计之后进行，关注的是每个模块内部的实现细节。</p><h5 id="项目与产品的区别"><a href="#项目与产品的区别" class="headerlink" title="项目与产品的区别"></a>项目与产品的区别</h5><p>项目：是指在<strong>一定的约束条件下</strong>（主要是限定时间、限定资源），具有明确目标的工作任务。</p><p>软件项目：是指为企业开发或者部署实施一套专用的系统，或在特定的行业领域做一些系统之间的集成，在进入项目之前必须与用户进行具体的交流和讨论，了解清楚用户心目中的产品或项目预期是什么样子，然后招投标、签订合同、<strong>实施交付</strong>。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/196adfe67b228650e278fabab2918119.png" alt="img"></p><h5 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h5><p>产品：是指能够提供给市场，被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。</p><p>软件产品：是指向用户提供的计算机软件、信息系统、套装软件或在提供计算机信息系统集成、应用服务等技术服务时提供的软件，是通用的产品应用于某一行业领域而不是像软件项目一样为某一需求或者单位定制开发。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7274640e38be432e54ba15a5a278a9a4.png" alt="img"></p><p><a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>建模方法有很多种，也都在进一步的发展和完善中。OMT法是目前最为成熟和实用的方法之一。它从三个方面对系统进行建模，每个模型从一个侧面反映系统的特性，三个模型分别是：<strong>对象模型</strong>、<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B">动态模型</a>和<a href="https://baike.baidu.com/item/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9E%8B">功能模型</a>。     </p><p>对象拥有的特性（特征）：<strong>对象唯一性</strong>（标识）、<strong>分类性、继承性、多态性。</strong></p><p>根据不同的测试阶段，测试可以分为单元测试、集成测试、系统测试和验收测试。 体现了测试由小到大、又内至外、循序渐进的测试过程和分而治之的思想。 </p><p><strong>单元测试</strong>的粒度最小，一般由开发小组采用白盒方式来测试，主要测试单元是否符合“设计”。 </p><p>  <strong>集成测试界于单元测试和系统测试</strong>之间，起到“桥梁作用”，一般由开发小组采用白盒加黑盒的方式来测试，既验证“设计”，又验证“需求”。 </p><p>  <strong>系统测试</strong>的粒度最大，一般由独立测试小组采用<strong>黑盒方式来测试</strong>，主要测试系统是否符合“需求规格说明书”。 </p><p>  <strong>验收测试与系统测试</strong>相似，主要区别是测试人员不同，验收测试由用户执行。 </p><p>  <strong>黑盒测试</strong>不考虑程序内部结构和逻辑结构，主要是用来测试系统的功能是否满足需求规格说明书。一般会有一个输入值，一个输出值，和期望值做比较。 </p><p><strong>白盒测试主要应用在单元测试阶段</strong>，主要是对代码级的测试，针对程序内部逻辑结构，测试手段有：语句覆盖、判定覆盖、条件覆盖、路径覆盖、条件组合覆盖 </p><p><strong>集成测试</strong>主要用来测试模块与模块之间的接口，同时还要测试一些主要业务功能。 </p><p> <strong>系统测试</strong>是在经过以上各阶段测试确认之后，把系统完整地模拟客户环境来进行的测试</p><p>MVC（Model-View-Controller）模式是一种常用的软件架构模式，它将应用程序分为三个主要组件：模型（Model）、视图（View）和控<br> 制器（Controller）。采用MVC模式的理由并不是为了直接使用发布-订阅模式，但MVC模式的设计思想可以与发布-订阅模式结合，从而更好地控制用户的表示和输入操作。</p><p> 下面是一些理由说明为何采用MVC模式可以与发布-订阅模式结合：</p><ol><li><p>分离关注点：MVC模式通过将数据逻辑（模型）与用户界面（视图）和用户交互逻辑（控制器）进行分离，使得系统的不同部分可以独立开发、维护和扩展。这符合单一职责原则，有利于代码的可读性和可维护性。</p></li><li><p>视图更新：当模型的状态发生变化时，视图需要及时地更新以反映最新的数据。在这种情况下，发布-订阅模式可以用于触发和处理模型状态变化的事件。模型作为发布者，将状态变化的消息发布给所有订阅者（包括视图），视图收到消息后进行相应的更新操作。</p></li><li><p>用户输入控制：控制器负责接收用户的输入操作，并将其转发给模型进行处理。在这个过程中，发布-订阅模式可以用于控制器与其他组件之间的通信。例如，当控制器接收到用户输入时，它可以发布一个事件，让订阅者（如视图）知道有新的输入需要处理。</p></li><li><p>灵活性和可扩展性：采用MVC模式可以使系统组件之间的耦合度降低，提高系统的灵活性和可扩展性。如果未来需要添加新的视图或控制器，只需根据需要实现相应的订阅者或发布者即可，而不需要修改其他部分的代码。<br> 综上所述，MVC模式本身并不直接涉及发布-订阅模式，但它提供了一种组织应用程序结构的方式，使得可以很容易地将发布-订阅模式与<br> 其结合使用，从而更好地控制用户的表示和输入操作。这种结合可以提高代码的可读性、可维护性和可扩展性。</p></li></ol><p>层次图、结构图：<strong>描绘软件结构</strong> </p><p> 层次方框图：<strong>描绘数据结构</strong> </p><p>  N-S图（盒图）：描<strong>绘程序结构以及流程</strong> </p><p>  E-R图：实体联系图。表示各个实体之间的关系</p><p>判定表由四部分组成。 </p><p>第一部分判定标的左上部称为基本条件项，<strong>列出各种可能的条件</strong>。</p><p> 第二部分判定标的右上部称为条件项，它<strong>列出了各种可能的条件组合</strong>。 </p><p>第三部分判定标的左下部称为<strong>基本动作项</strong>，它<strong>列出了所有的操作</strong>。 </p><p>第四部分判定标的右下部称为动作项，它列出<strong>在对条件组合下所选的操作</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20170906/1566862_1504687508868_4408D1FD75F1290422DDEF18CAF660E6" alt="img"></p><p><strong>软件设计</strong>是软件工程的重要阶段，是<strong>一个把软件需求转换为软件表示的过程</strong>。软件设计的基本目标是用比较抽象概括的方式确定目标系统如何完成预定的任务，即解决软件“怎么做”的问题</p><p>需求分析 <strong>做什么 详细设计 怎么做</strong></p><p>影响系统可维护性的因素</p><p><strong>1.可理解性</strong> 软件可理解性表现为外来读者理解软件的结构、接口、功能和内部过程的难易程度。模块化、详细的设计文档、结构化设计、源代码内部的文档和良好的高级程序设计语言等等，都对改进软件的可理解性有重要贡献。</p><p> <strong>2.可测试性</strong> 诊断和测试的难易程度主要取决于软件容易理解的程度。良好的文档对诊断和测试是至关重要的。此外，软件结构、可用的测试工具和调试工具，以及以前设计的测试过程也都是非常重要的。维护人员应该能够得到在开发阶段用过的测试方案，以便进行回归测试。在设计阶段应该尽力把软件设计成容易测试和容易诊断的。</p><p> <strong>3.可修改性</strong> 软件容易修改的程度和软件设计原理和规则直接有关。耦合、内聚、局部化、控制域与作用域的关系等等，都影响软件的可修改性。 上述三个可维护性因素是紧密相关的。维护人员在正确理解一个程序之前根本不可能修改它；如果不能进行完善的诊断和测试，则表面正确的修改可能引进其他故障。</p><p>jackson图既可以表示数据结构也可以表示程序结构 </p><p>N-S图程序流程图盒图表示</p><p>PAD图 </p><p>工厂模式包括：简单工厂模式、工厂方法模式、抽象工厂模式。 简单工厂模式：建立一个抽象工厂类；  工厂方法模式：建立一个抽象工厂类和多个具体工厂；  抽象工厂模式：建立一个抽象工厂类和多个具体工厂类（每个具体工厂类中提供多种产品创建的函数）。    </p><p><strong>代码评审也称代码复查</strong>，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动, 只说是否达到模块设计的要求太片面</p><p>Data Flow Diagram，缩写为DFD。中文名数据流图或数据流程图。数据流图DFD是描述系统中数据流程的一种图形工具，它标志了一个系统的逻辑输入和逻辑输出，以及把逻辑输入转换逻辑输出所需的加工处理。它从数据传递和加工角度，以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。  所以数据流改变时，也要修改系统结构    </p><p>白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。白盒测试是一种测试用例设计方法，盒子指的是被测试的软件，白盒指的是盒子是可视的，你清楚盒子内部的东西以及里面是如何运作的。”白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。”白盒”法是穷举路径测试。在使用这一方案时，测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据。贯穿程序的独立路径数是天文数字。 </p><p>偶然内聚&lt; 逻辑内聚 &lt;时间内聚 &lt;过程内聚 &lt;通信内聚 &lt;顺序内聚 &lt;功能内聚 </p><h2 id="UML类图关系"><a href="#UML类图关系" class="headerlink" title="UML类图关系"></a>UML类图关系</h2><p>泛化(generalization)：表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。    </p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411291858855.png" alt="image-20241129185749202"></p><p> 实现（Realization）:在类图中就是接口和实现的关系。在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。  </p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411291859043.png" alt="image-20241129185819912"></p><p>  依赖(Dependency)：对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411291901733.png" alt="image-20241129190143377">  </p><p>  关联(Association) : 对象之间一种引用关系，比如客户类与订单类之间的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。  </p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411291859656.png" alt="image-20241129185927264"></p><p>​     聚合(Aggregation) : 表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形表示，菱形从局部指向整体。  </p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411291900313.png" alt="image-20241129190024189"></p><p>  组合(Composition) : 表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。在类图使用实心的菱形表示，菱形从局部指向整体。  </p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411291901843.png" alt="image-20241129190124617"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411291902690.png" alt="image-20241129190243676"></p><p>系统软件包括<strong>操作系统，语言系统和工具系统（实用系统</strong>）</p><p><strong>面向数据流</strong>的设计方法的目的是给出<strong>设计软件结构</strong>的一个系统化的途径，在软件工程的<strong>需求分析阶段</strong>，信息流是一个主要考虑的问题，常用数据流图描绘信息在系统中加工和流动的情况。面向数据流的设计方法定义了一些不同的映射，利用这些映射，可以把数据流图变换成软件结构。<strong>信息流</strong>的类型决定了映射的方法。信息流有两种类型：变换流和事务流。    </p><p>面向数据流的设计方法把<strong>信息流</strong>映射成软件结构，信息流的类型决定了映射的方法</p><h2 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a>一、填空题</h2><p>1、软件是一种逻辑产品</p><p>2、软件开发方法是指导软件开发的一系列规则和约定</p><p>3、软件生存周期中花费最多的阶段是软件维护阶段</p><p>4、软件工程的三要素：<strong>工具、过程、方法</strong></p><p>5、在软件生存周期中，能准确地确定“软件系统必须做什么”的阶段是需求分析阶段</p><p>6、<a href="https://so.csdn.net/so/search?q=%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">瀑布模型</a>本质上是一种线性顺序模型</p><p>7、瀑布模型突出的缺点是不适应用户需求的变动</p><p>8、在<a href="https://so.csdn.net/so/search?q=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">软件开发模型</a>中，提出最早、应用最广泛的模型是瀑布模型</p><p>9、瀑布模型不适用于需求模糊不清的软件开发</p><p>10、快速原型的主要优点：能让用户参与开发、给出反馈；尽早把需求分析清楚，以降低风险；尽早地发现问题、纠正错误</p><p>11、<strong>快速原型</strong>的主要问题在于<strong>缺乏支持原型开发</strong>的工具</p><p>12、<a href="https://so.csdn.net/so/search?q=%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">螺旋模型</a>是一种减瀑布模型和增量模型结合起来的软件开发模型</p><p>13、在软件生产的程序系统时代由于软件规模扩大和和软件复杂性提高等原因导致了软件危机</p><p>14、集成化开发环境中的环境集成机制包括数据集成、控制集成、界面集成</p><p>15、软件工程的出现是由于<strong>物理系统</strong></p><p>16、系统流程图是一种传统工具，用于描绘软件危机的出现</p><p>17、软件可行性研究的目的是阐述软<strong>件开发项目值得或不值得做</strong></p><p>18、技术可行性研究要解决的问题是<strong>从技术方面说明项目是否可行</strong></p><p>19、可行性研究的步骤首先是<strong>确定项目目标，即对要解决的问题进行定义</strong></p><p>20、可行性研究的任务包括<strong>技术可行性、经济可行性、法律可行性</strong></p><p>21、系统流程图是描述物理系统的工具</p><p>22、可行性研究实质上是要进行一次简化、压缩的<a href="https://edu.csdn.net/cloud/sd_summit?utm_source=glcblog&spm=1001.2101.3001.7020">需求分析</a>，设计过程</p><p>23、需求分析最终结果是产生需求规格说明书</p><p>24、<strong>数据流图</strong>（DFD）是SA方法中用于表示<strong>系统的逻辑模型的一种图形工具</strong>。</p><p>25、需求规格说明书的作用包括软件验收的依据 、用户与开发人员对软件要做什么的共同理解、软件可行性研究的依据</p><p>26、<strong>数据词典是用来定义数据流图中的各个成分的具体含义</strong></p><p>27、结构化分析方法（SA）是一种面<strong>向数据流的分析方法</strong></p><p>28、软件开发的需求活动，其主要任务是定义需求并建立系统模型</p><p>29、结构化分析的核心是<strong>自顶向下的</strong>分解</p><p>30、需求分析的任务是正确说明让软件“做什么”</p><p>31、对于分层的DFD，<strong>父图与子图的平衡是指子图必须继承父图的输入与输出流</strong></p><p>32、DFD的每个加工都必须有<strong>一个输入和输出数据流</strong></p><p>33、需求分析是分析员经了解用户的要求，认真细致地调研、分析，最终建立目标系统的逻辑模型并写出软件规格说明书的过程。</p><p>34、结构化分析方法是以数据流图、DD和加工说明等描述工具，即用直观的图和简洁的语言来描述软件系统模型</p><p>35、软件需求分析阶段的工作，可以分为四个方面：需求获取、需求分析、编写需求规格说明书以及需求评估</p><p>36、数据流图由加工、数据存储、源点和终点构成</p><p>37、DFD用于<strong>描述系统的软件功能</strong></p><p>38、DFD即数据流图(Data Flow Diagram)</p><p>39、<strong>数据词典不包括的条目是数据类型</strong></p><p>40、数据词典包括<strong>数据项、数据结构、数据流、处理逻辑、数据存储和外部实体</strong></p><p>41、软件需求分析一般应确定的是<strong>用户对软件的功能需求和非功能需求</strong></p><p>42、在数据流图中，有名字和方向的成分是数据流</p><p>43、软件结构图的形态特征能<strong>反映程序重用率的是扇入</strong></p><p>44、概要设计的目的是<strong>确定整个系统的功能及模块结构</strong></p><p>45、耦合是对软件不同模块之间互连程度的度量。各种耦合从强到弱的排列为<strong>内容耦合</strong>，<strong>公共环境耦合，控制耦合，数据耦合。</strong></p><p>46、当一个模块直接使用另一个模块的内部数据时,这种模块之间的耦合为内容耦合。</p><p>47、数据耦合和控制耦合相比,则控制耦合的耦合性强</p><p>48、衡量模块独立性的标准是耦合性和内聚性</p><p>49、如果某种内聚要求一个模块中包含的任务必须在同一段时间内执行,则这种内聚为时间内聚</p><p>50、为了提高模块的独立性,模块内部最好是功能内聚</p><p>51、 偶然内聚：如果一个模块的各成分之间毫无关系，则称为偶然内聚。</p><p>52、 逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。如一个模块读取各种不同类型外设的输入。尽管逻辑内聚比偶然内聚合理一些，但逻辑内聚的模块各成分在功能上并无关系，即使局部功能的修改有时也会影响全局，因此这类模块的修改也比较困难。</p><p>53、 时间内聚：如果一个模块完成的功能必须在同一时间内执行（如系统初始化），但这些功能只是因为时间因素关联在一起，则称为时间内聚。</p><p>54、过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。</p><p>55、 通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚。</p><p>56、 顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚。</p><p>57、 功能内聚：模块的所有成分对于完成单一的功能都是必须的，则称为功能内聚。</p><p>58、内容耦合：当一个模块直接修改或操作另一个模块的数据,或者直接转入另一个模块时，就发生了内容耦合。此时，被修改的模块完全依赖于修改它的模块。</p><p>59、公共耦合：两个以上的模块共同引用一个全局数据项就称为公共耦合。</p><p>60、控制耦合：一个模块在界面上传递一个信号（如开关值、标志量等）控制另一个模块，接收信号的模块的动作根据信号值进行调整，称为控制耦合。</p><p>61、标记耦合：模块间通过参数传递复杂的内部数据结构，称为标记耦合。此数据结构的变化将使相关的模块发生变化。</p><p>62、数据耦合：模块间通过参数传递基本类型的数据，称为数据耦合。</p><p>63、非直接耦合：模块间没有信息传递时，属于非直接耦合。</p><p>64、如果模块间必须存在耦合，就尽量使用<strong>数据耦合，少用控制耦合，限制公共耦合的范围，坚决避免使用内容耦合</strong></p><p>65、软件设计是把软件需要转换为软件表示的过程</p><p>66、概要设计的主要成果是<strong>概要设计说明书</strong></p><p>67、数据结构设计也是概要设计的重要内容,主要是进行数据的逻辑设计</p><p>68、概要设计与详细设计衔接的图形工具是SC图</p><p>69、SC图：Structure Chart,结构图</p><p>70、在软件开发中,任务属于设计阶段的有数据结构设计、给出系统模块结构、定义模块算法</p><p>71、软件设计原则有<strong>抽象、模块化、信息隐藏</strong></p><p>72、软件详细设计的主要任务是<strong>确定每个模块的算法和使用的数据结构</strong></p><p>73、借助于软件工具，<strong>可将PAD图容易地转换为高级语言源程序</strong></p><p>74、<strong>PAD图：问题分析图(Problem Analysis Diagram)</strong></p><p>75、不属于详细设计工具的是DFD图</p><p>76、DFD图：Data Flow Diagram，数据流图</p><p>77、程序的三种基本结构是顺序、选择和重复</p><p>78、<strong>UML的主要特点不正确的是面对过程，表达能力强</strong></p><p>79、UML： 统一建模语言(Unified Modeling Language</p><p>80、<strong>静态建模图包括用例图、类图、对象图</strong></p><p>81、<strong>用例图的模型元素包括用例、系统、行为者</strong></p><p>82、<strong>类图的要不包括类名称、操作、属性</strong></p><p>83、时序图中的要素包括对象、对象生命线、消息</p><p>84、对象模型的描述工具是对象图</p><p>85、协作图的要素包括对象、链、消息</p><p>86、类图反映了系统中对象之间的抽象关系，包括关联、聚合、泛化</p><p>87、描述类中某个对象的行为，反映了状态与事件关系的是状态图</p><p>88、动态模型的描述工具是状态图</p><p>89、表示对象的相互行为的模型是对象模型</p><p>90、用例图中用例之间的关系通常有关联关系、依赖关系和泛化关系</p><p>91、动态模型图包括：时序图、协作图、状态图和活动图图</p><p>92、汽车有一个发动机，汽车和发动机之间的关系是整体部分关系</p><p>93、火车是一种陆上交通工具，火车和陆上交通工具之间的关系是一般具体关系</p><p>94、面向对象程序设计语言不同于其他语言的最主要特点是继承性</p><p>95、软件部件的内部实现与外部可访问性分离，这是指软件的封装性</p><p>96、面向对象分析阶段建立的三个模型中，核心模型是对象模型</p><p>97、对象模型的描述工具是对象图</p><p>98、动态模型的描述工具是状态图</p><p>99、在只有单重继承的类层次结构中，类层次结构是树型层次结构</p><p>100、对象模型表示了对象的互相行为</p><p>101、在确定类时，所有名词是候选的类</p><p>102、面向对象分析的原则包括抽象、封装、继承</p><p>103、常用动词和动词词组来表示关联</p><p>104、在确定属性时，所有名词是候选的属性</p><p>105、在面向对象方法中，信息隐藏是通过对象的封装性来实现的</p><p>106、面向对象设计的准则包括模块化、抽象、信息隐藏</p><p>107、在编码中首先要考虑的是程序的可读性</p><p>108、属于序言性注释内容的有模块设计者、修改日期、程序的整体说明</p><p>109、序言性注释应置于文件或模块的起始位置</p><p>110、如果编写系统软件，可选用的语言是C语言</p><p>111、选择程序设计语言不应该考虑的是语言的功能</p><p>112、与编程风格有关的因素包括源程序文档化、语句构造、输入输出</p><p>113、最早用于科学计算的程序设计语言是FORTRAN</p><p>114、FORTRAN语言即公式翻译器</p><p>115、功能性注释的主要内容不包括模块的功能</p><p>116、对建立良好的编程风格，下面描述正确的是程序应简单、清晰、可读性好</p><p>117、源程序中应包含一些内部文档，以帮助阅读和理解程序，源程序的内部文档通常包括合适的标识符、注释和程序的布局组织</p><p>118、编制一个好的程序应强调良好的编程风格，例如，选择标识符的名字时应考虑选择含义明确的名字，以正确提示所代表的实体</p><p>119、以下关于编程风格的叙述中，应提倡的是使用括号以改善表达式的清晰性、一般情况下，不要直接进行浮点数的相等比较、使用有清晰含义的标识符</p><p>120、在结构化程序设计思想提出之前，在程序设计中曾强调程序的效率，现在人们更重视程序的可理解性</p><p>121、为了提高易读性，源程序内部应加功能性注释，用于说明程序段或语句的功能</p><p>122、适合在互联网上编写程序可供不同平台上运行的面向对象的程序设计语言是Java</p><p>123、使用C语言开发的软件具有较好的可移植性</p><p>124、用低级语言开发的程序，具有运行效率高，开发效率低特点</p><p>125、发现错误多的程序模块，残留在模块中的错误也多</p><p>126、确定测试计划是在需求分析阶段制定的</p><p>127、集成测试计划是在概要设计阶段制定的</p><p>128、单元测试是在编码阶段完成的</p><p>129、集成测试工作最好由不属于该软件开发组的软件设计人员承担</p><p>130、为了提高软件的测试效率，测试工作需要有测试工具的支持</p><p>131、测试用例是专门为了发现软件错误而设计的一组或多组数据，它由测试输入与预期的输出数据组成。</p><p>132、测试和调试最大的不同在于操作者的心理状态不同</p><p>133、一个成功的测试是发现至今尚未发现的错误</p><p>134、白盒法和黑盒法最大的不同在于的测试是测试用例设计方法不同</p><p>135、单元测试阶段主要涉及概要设计的文档</p><p>136、检查软件产品是否符合需求定义的过程称为确认测试</p><p>137、软件调试的目的是改正错误</p><p>138、进行<a href="https://edu.csdn.net/cloud/sd_summit?utm_source=glcblog&spm=1001.2101.3001.7020">软件测试</a>的目的是尽可能多地找出软件中的错误</p><p>139、在进行单元测试时，常用的方法是采用白盒测试，辅之以黑盒测试</p><p>140、白盒测试方法一般适合于单元测试</p><p>141、为了提高测试的效率，应该选择发现错误可能性大的数据作为测试数据</p><p>142、属于白盒测试的技术有语句覆盖、判定覆盖、条件覆盖</p><p>143、在逻辑覆盖标准中，差错能力最强的是条件组合覆盖</p><p>144、在黑盒法中，着重检查输入条件组合的测试方法是因果图法</p><p>145、在需求分析阶段，就应该考虑软件可维护性问题</p><p>146、由于在开发过程中测试的不彻底、不完全而造成的维护是改正性维护</p><p>147、为适应软硬件环境变化而修改软件的过程是适应性维护</p><p>148、为增加软件功能和性能而进行的软件维护过程是完善性维护</p><p>149、维护阶段需由用户填写的维护文档是软件问题报告</p><p>150、软件的可维护性是指软件能被修改的难易程度</p><p>151、软件维护工作中最主要部分是完善性维护</p><p>152、维护中，因误删除一个标识符而引起的错误是编码副作用</p><p>153、维护中，因修改全局变量或公用数据而引起的错误是数据副作用</p><p>154、软件维护工作过程中，第一步是先确定维护类型</p><p>155、在软件生存周期中，工作量所占比例最大的阶段是维护阶段</p><p>156、软件工程对维护工作的主要目标是提高软件的可维护性，降低维护的代价</p><p>157、软件维护的副作用是指因修改软件而造成的错误</p><p>158、一般来说，在软件维护过程中，大部分工作是由用户的需求改变引起的</p><p>159、软件项目管理是软件生存周期一切活动的管理</p><p>160、在软件工程项目中，不随参与人数增加而使生产率增加的主要问题是参与人员之间的通信困难</p><p>161、COCOCO估算模型是结构性成本模型</p><p>162、自底向上估算方法的缺点是估算往往缺少系统级工作量，所以估算往往偏低</p><p>163、软件管理比其他工程管理更为困难</p><p>164、CMM模型中属于可管理级的特征软件过程中活动的生产率与质量是可度量的</p><p>165、由IEEE组织制定的标准是国际标准</p><p>166、GB&#x2F;T 8567-2006《计算机软件文档编制规范》是推荐性行业标准</p><p>167、测试计划文档应从软件工程的需求分析阶段开始编写</p><p>168、理解螺旋模型的一个简便的方法，是把它看作在每个阶段之前都增加了风险分析过程的瀑布模型</p><p>169、在结构化分析中，用以表达内部数据运动情况的工具是数据流图</p><p>170、在一张状态图中，只能有一个初态</p><p>171、DFD的每一个加工中至少有一个输入流和一个输出流</p><p>172、一个模块访问了另一个模块的内部数据，两个模块间发生了内容耦合</p><p>173、能够清楚地表示复杂的条件组合和应做的动作之间的对应关系的工具是判定表</p><p>174、详细设计的基本任务是确定每个模块的算法</p><p>175、问题定义和可行性研究的主要任务都是概括地了解用户的需求</p><p>176、在数据字典中建立的一组严密一致的定义有助于改进分析员和用户之间的通信</p><p>177、编码和测试统称为实现</p><p>178、总体设计的过程通常由系统设计和结构设计阶段组成</p><p>179、程序的质量主要取决于软件设计的质量</p><p>180、软件危机是指软件开发和维护中出现一系列严重问题</p><p>181、可行性研究中描述系统高层物理模型的工具是系统流程图</p><p>182、准确地解决”软件系统必须做什么“是需求分析阶段的任务</p><p>183、结构化分析方法使用数据流图描述软件的功能模型</p><p>184、数据存储和数据流都是数据，仅仅是所处的状态不同</p><p>185、需求分析阶段完成后产生的重要文档，一个书软件需求规格说明书，另一个很可能产生的文档是软件验收测试计划</p><p>186、在结构化设计中，软件结构图是从需求分析得到的数据流图中映射出的</p><p>187、软件结构设计，在对事物流的分析中，识别出事务中心的分析的关键</p><p>188、连个模块通过传递记录、数组等数据结构参数参与联系，则称为这两个模块间存在标记耦合</p><p>189、软件初始化模块，其中包括几个相对独立的、必须在软件自启动阶段内完成的任务，这个模块的内聚级别是时间内聚</p><p>190、在软件开发与维护的各阶段中，单元测试在编码阶段完成</p><p>191、软件生命周期中，持续时间最长的阶段一般都是维护阶段</p><p>192、软件工程的中心课题是是控制软件的复杂度</p><p>193、在几种软件生命周期模型中，螺旋模型引入了风险分析，它适合大规模的内部软件项目开发</p><p>194、软件工具的主要目的是为了提高软件生产效率和改善软件的质量</p><p>195、在构造软件原型时，必须注意功能和性能（或需求）的取舍，忽略一切暂时不需关心的部分</p><p>196、在需求分析中，对加工处理算法的简单描述被记录在数据字典中</p><p>197、软件结构设计，应符合模块独立原理，做到高内聚和低耦合</p><p>198、判断表和判断树，用来描述复杂的条件组合和动作组合间的对应关系，宜作为辅助设计和测试设计的工具</p><p>199、黑盒测试主要用来进行功能测试</p><p>200、效率是一个性能需求，因该在需求分析阶段(或需求规格说明书)给出</p><p>201、软件再工程，也叫修理和再生，是一类软件工程活动。它由逆向工程、重构和正向工程组合而成</p><p>202、再软件开发的各个阶段，通过了正式复审的软件配置项被称为基线</p><p>203、与计算机科学的理论研究不同，软件工程是一门工程性学科</p><p>204、软件开发环境中最主要的组成部分是软件工具</p><p>205、瀑布模型是一种软件生命周期模型</p><p>206、技术可行性要解决技术风险问题</p><p>207、系统流程图是描述软件系统系统物理模型的工具</p><p>208、软件需求规格说明书的内容应包括主要功能、用户界面及运行环境、软件的性能</p><p>209、软件设计阶段一般又可分为概要设计和详细设计</p><p>210、概要设计又称为总体设计</p><p>211、黑盒测试主要是测试软件的功能</p><p>212、在软件生命周期中，维护阶段所占的工作量最大</p><p>213、判定树是判断表的变种</p><p>214、层次图中一个矩形代表一个模块</p><p>215、McCabe方法的流图，实质上是”退化了的“程序流程图</p><p>216、单元测试主要使用白盒测试技术</p><p>217、文档是影响软件可维护性的决定因素</p><p>218、两个模块通过访问同一个全程变量的互相合作，这种模块间的耦合方式称为公共环境耦合</p><p>219、信息流有两种类型，即变换流和事务流</p><p>220、预防性维护实质上是软件再工程</p><p>221、人们用代码行技术和功能点技术估算软件规模</p><h2 id="二、简答题"><a href="#二、简答题" class="headerlink" title="二、简答题"></a>二、简答题</h2><p>1、软件通过你自己使用计算机的经历和对计算机的认识分辨软件和程序的差别，指出区别的关键点。</p><p>答：软件包括程序、数据及其相关文档的完整集合。其中，程序是按事先设计的功能和性能要求执行的指令序列；数据是使程序能够正确地处理信息的数据结构；文档是与程序开发、维护和使用有关的图文资料。软件包括程序,程序只是软件的一部分。</p><p>2、简述软件危机产生的原因以及避免的方法。</p><p>答：软件危机的产生有两方面因素，一方面与软件本身的抽象性和复杂性有关；另一方面则与软件开发和维护过程中使用的技术和方法有关，这是主观原因。</p><p>为了解决软件危机，既要有技术措施（好的方法和工具），也要有组织管理措施。<br>（1）使用好的软件开发技术和方法。<br>（2）使用好的软件开发工具，提高软件生产率。<br>（3）有良好的组织、严密的管理，各方面人员相互配合共同完成任务。</p><p>3、简述软件工程在软件开发中的作用和意义。</p><p>答：软件工程的主要思想是强调软件开发过程中应用工程化原则的重要性。软件工程的目标是实现软件的优质高产。软件工程的目的是在经费的预算范围内，按期交付出用户满意的、质量合格的软件产品。</p><p>4、软件生命周期概念对软件的开发有哪些指导作用。</p><p>答：软件生命周期是软件工程的一个重要的概念。把整个软件生命周期划分为若干个较小的阶段，每个阶段都有相对独立的任务和完成任务的步骤和方法，然后逐步完成各个阶段的任务，这有利于软件开发过程的组织和管理，从而降低了整个软件开发过程的困难程度，从而使规模庞大、结构复杂和管理复杂的软件开发变得容易控制和管理。</p><p>5、分析瀑布模型和螺旋模型的异同，比较它们的适用场合。</p><p>答：瀑布模型是线性模型，是整体开发模型，文档驱动的模型，每一阶段必须完成指定的文档，需求明确的中、小型软件开发， 不适宜需求模糊或多变的应用软件开发；螺旋模型是典型迭代模型，是风险驱动模型，可用于面向对象开发，适宜风险较大的大型软件开发。</p><p>6、软件开发的早期，为什么要进行可行性研究？目标的可行性研究有几个方面？</p><p>答：许多软件开发问题都不能在预期的时间范围内或资源限制下得到解决。如果开发人员没有尽早停止没有可行解决方案的开发项目，就会造成时间、资金、人力、物力的浪费。为了降低软件开发失败的可能性，需要进行软件可行性研究。可行性研究要从经济可行性、技术可行性、运行可行性和法律可行性四方面进行。</p><p>7、简述可行性研究的步骤。</p><p>答：<br>（1）审核系统的规模和目标；<br>（2）分析研究现行系统；<br>（3）设计新系统的高层逻辑模型；<br>（4）获得并比较可行的方案；<br>（5）撰写可行性研究报告。</p><p>8、需求分析的任务是什么？怎样理解“做什么”和“怎么做”？</p><p>答：需求分析的基本任务是要准确地理解旧系统、定义新系统的目标，为了满足用户需要，回答“系统必须做什么”的问题，即确定系统必须完成哪些工作，对新系统提出完整、准确、清晰、具体的要求。<br>具体任务是:明确问题定义、导出软件的逻辑模型、编写软件需求规格说明书。<br>“做什么”，即深入描述软件的功能和性能，确定软件设计的限制和软件与其他系统元素的接口细节，定义软件的其他有效性需求。<br>“怎么做”，即着手软件需求的实现：用比较抽象概括的方式确定目标系统如何完成预定的任务，确定系统的物理模型。</p><p>9、怎样建立目标系统的逻辑模型？</p><p>答：建立目标系统逻辑模型的一般过程：<br>（1）由当前物理系统导出当前系统物理模型;<br>（2）由当前系统物理模型，导出当前系统逻辑模型;<br>（3）参考当前系统逻辑模型，设想出新系统逻辑模型。</p><p>10、数据流图的作用是什么？它有哪些基本成分？</p><p>答：数据流图是用于表示系统逻辑模型的一种工具。它从数据传递和加工的角度，以图形的方式描述数据在系统中流动和处理过程。它表示了系统内部信息的流向以及系统的逻辑处理功能。<br>数据流图的主要成分有四种：数据流、数据存储、加工、数据流的源点和终点。</p><p>11、数据词典的作用是什么？它包括哪些内容？</p><p>答：数据词典是数据的集合，它对数据流图中的各个元素作完整的定义和说明，是数据流图的补充工具。数据流图和数据词典共同构成系统的逻辑模型，两者缺一不可。<br>其内容包括：数据流、数据项、数据结构、数据存储、加工逻辑、外部实体6类元素。</p><p>12、软件设计应遵循的原则是什么?</p><p>答:软件设计中一般应遵循以下原则：模块化、抽象、信息隐蔽与局部化、一致性、完整性和可验证性。</p><p>13、什么是软件的概要设计?概要设计阶段完成的主要任务是什么?</p><p>答:总体设计又称概要设计，是将软件需求转化为软件体系结构、确定系统级接口、全局数据结构和数据库模式。</p><p>14、启发设计规则有哪些?</p><p>答:<br>（1）模块功能的完善化；<br>（2）消除重复功能，改善软件结构；<br>（3）模块规模应该适中；<br>（4）模块的深度、宽度、扇出和扇入都应适当；<br>（5）模块的作用范围应该在控制范围之内；<br>（6）力争降低模块接口的复杂程度；<br>（7）设计单入口、单出口的模块；<br>（8）模块功能应该可以预测。</p><p>14、软件的详细设计阶段完成的主要任务是什么？</p><p>答：<br>（1）算法设计；<br>（2）数据结构设计；<br>（3）模块接口细节设计；<br>（4）测试用例设计；<br>（5）数据库物理设计；<br>（6）数据代码设计；<br>（7）其他设计；<br>（8）编写详细设计说明书并进行评审。</p><p>15、数据输入界面设计的主要原则有哪些？</p><p>答：在设计数据输入界面时应做到：尽量简化用户的工作、减少输入的出错率；减轻用户的记忆负担、尽可能减少输入量并实现自动输入； 对共同的输入设置默认值； 使用代码或缩写； 自动填入已输入过的内容；列表式输入; 数据分组输入。</p><p>16、代码设计的原则有哪些？</p><p>答：代码设计的原则是标准化、唯一性、可扩充性、简单性、规范性和适应性。</p><p>16、简要介绍用例图的三个要素。</p><p>答：用例图主要包括以下三个元素：<br>①用例（Use Case）：用例是系统的使用过程或要执行的动作序列，用来描述某个参与者使用系统所完成的功能。在图中用椭圆来表示，用例名称可写在椭圆中或椭圆下面。<br>②参与者（Actor）。或称角色或执行者，它是系统外部的一个实体（可以是任何的事物或人所扮演的角色等）。在图中用一个小人图形表示。<br>③关联。表示角色与用例之间的驱动和反馈关系，也可以表示用例间的包含与扩展关系。在图中用线段或带箭头的线段表示。</p><p>17、分别写出UML对象图中对象的三种表示方式。</p><p>答：在UML中，对象图和类图一样采用矩形图示，不过对象名称下方有下划线（类名称下方没有下划线），通常对象名采用：对象名：类名、 ：类名 或 对象名三种格式表示，中间形式是尚未给对象命名，最后一种形式是省略了类名。</p><p>18、举例说明类图和对象图之间的关系。</p><p>答：对象图展示了一组对象和它们之间的关系。对象图是类图的实例，对象之间的连接是类之间关联的实例。类图和对象图的不同点在于对象图显示类的多个对象实例，而不是实际的类。</p><p>19、活动图的主要作用是什么，状态图的主要作用是什么？</p><p>答：状态图和活动图都属于行为图，主要用于分析、设计阶段描述对象的行为。状态图适于描述单个对象状态的变化情况，活动图适于描述一个工作过程、多个对象之间的合作。</p><p>状态图描述一个特定对象的所有可能状态以及由于各种事件的发生而引起的状态间的转移。</p><p>活动图(Activity Diagram)是状态图的变种。状态图适于描述单个对象状态的变化情况，而活动图的目的是描述动作（执行的工作和活动），以及对象状态改变的结果，适于描述一个工作过程、多个对象之间的合作。与状态图不同的是，活动图中动作状态的迁移不是靠事件触发，当动作状态中的活动完成时就触发迁移，活动图中的一个活动结束后将立即进行下一个活动。</p><p>20、面向对象分析通常要建立哪三种模型？它们分别描述系统的哪些方面？</p><p>答：面向对象分析通常要建立三种模型，分别是对象模型、动态模型和功能模型。其中：<br>对象模型描述系统的数据结构，它是用来描述系统包含的对象及对象之间关系的模型；<br>动态模型描述系统的控制结构，它是用来确定各个对象之间交互及整体的控制结构的模型；<br>功能模型描述系统的功能，它是用来描述系统要实现的功能的模型。</p><p>21、对象模型有哪五种层次？</p><p>答：复杂问题(大型系统)的对象模型由5个层次组成，即主题层、类-＆-对象层、结构层、属性层和服务层。<br>（1）类-&amp;-对象层：定义类和属性。在这个层次将分析与待开发软件对应的各个现实世界的实体，并从中抽象出类和对象。<br>（2）结构层：定义对象和类之间的层次结构关系，如一般-特殊结构（即继承结构）、整体-部分结构（即组合结构）。<br>（3）属性层：定义属性。为类和对象层中抽取出来的各个类和对象设计静态属性和它们之间的关系。<br>（4）服务层：定义对象和类的动态属性以及对象之间的消息通信。<br>（5）主题层：主题是指导读者理解大型、复杂模型的一种机制。定义若干个主题，把有关的对象分别划归不同的主题，每个主题构成一个子系统。</p><p>22、建立对象模型的基本过程是什么？</p><p>答：建立对象模型的基本过程如下：<br>确定对象和类-&gt;确定结构 -&gt;确定主题 -&gt;确定服务和消息</p><p>23、程序设计语言发展至今已经历了哪几个时代？</p><p>答：第一代语言（机器语言）、第二代语言（汇编语言）、第三代语言（高级语言）。高级语言种类繁多，又可分为传统的基础语言、结构化语言和专用语言三类。</p><p>26、良好的编码风格包括哪几方面？</p><p>答：<br>(1）源程序文档化<br>(2）数据说明<br>(3）语句构造<br>(4）输入与输出<br>(5）效率</p><p>27、在软件开发时，应根据哪些因素选择程序设计语言？</p><p>答：<br>（1）项目的应用领域。<br>（2）用户的要求。<br>（3）软件开发工具。<br>（4）算法和数据结构的复杂性。<br>（5） 软件开发人员的知识。<br>（6） 系统的可移植性要求。</p><p>28、在软件开发时，应根据哪些因素选择程序设计语言？</p><p>答：<br>（1）项目的应用领域。<br>（2）用户的要求。<br>（3）软件开发工具。<br>（4）算法和数据结构的复杂性。<br>（5） 软件开发人员的知识。<br>（6） 系统的可移植性要求。</p><p>29、为什么要进行软件测试？软件测试要以什么目标和原则？</p><p>答：软件测试的目的是为了发现软件产品中存在的软件缺陷，进而保证软件产品的质量。软件测试是软件开发过程中的一个重要阶段，是软件产品正式投入运行前，对软件需求分析、设计规格说明和编码的最终复审，是软件质量保证的关键步骤。软件测试的结果也是分析软件可靠性的重要依据。<br>在软件测试中，应注意以下指导原则：<br>（1）所有测试都应追溯到需求<br>（2）坚持“尽早地和不断地进行软件测试”。<br>（3）测试用例应由输入数据和预期的输出结果两部分组成。<br>（4）程序员应避免测试自己的程序。<br>（5）在设计测试用例时，应当包括合理的输入条件和不合理的输入条件。<br>（6）充分注意测试中的群集现象。<br>（7）严格执行测试计划，排除测试的随意性。<br>（8）应当对每个测试结果做全面检查。<br>（9）在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。<br>（10）应长期保留所有测试用例。保留测试用例有助于以后修改程序后的回归测试。</p><p>30、软件测试包括哪几个过程？测试过程中包括哪些数据源？</p><p>答：测试过程分为4个步骤，即单元测试、组装测试、确认测试和系统测试。<br>数据源有：<br>（1）软件配置：包括软件需求规格说明、软件设计规格说明、源代码等。<br>（2）测试配置：包括测试计划、测试用例、测试驱动程序等。<br>（3）测试工具：测试工具为测试的实施提供某种服务，以减轻测试过程中的手工劳动，提高测试效率。</p><p>31、黑盒测试法与白盒测试法的本质区别是什么？它们的使用场合有何不同。</p><p>答：黑盒测试法与白盒测试法的根本区别是设计测试用例的方法不同。前者是测试产品的功能，后者是测试产品的内部结构和处理过程。<br>通过黑盒测试主要发现以下错误：<br>（1）是否有不正确或遗漏了的功能。<br>（2）界面是否有错，能否正确地接受输入数据，能否产生正确的输出信息。<br>（3）是否有数据结构或外部数据库访问错误。<br>（4）性能是否满足要求。<br>（5）是否有初始化或终止性错误。<br>白盒测试法是一种程序级的微观上的测试，不适合于大单元、大系统的测试，主要用于很小单元的测试，以及从事软件底层工作、生产构件的测试人员使用。</p><p>32、试比较测试与调试的异同。</p><p>答：软件测试的目的是尽可能多地发现程序中的错误，而调试的目的是根据测试时发现的错误，找出错误的原因和具体位置，并改正错误。测试与调试的不同如下表所示。</p><p><strong>测试与调试的不同：</strong></p><table><thead><tr><th>测试 (test)</th><th>调试 (debug)</th></tr></thead><tbody><tr><td>目的是发现错误</td><td>目的是找出错误位置并排除</td></tr><tr><td>有计划</td><td>被动的</td></tr><tr><td>以已知条件开始,使用预先定义的程序,有预知的结果</td><td>以不可知内部条件开始,结果一般不可预见</td></tr><tr><td>由独立的测试组，在不了解软件设计的条件下完成</td><td>由程序作者进行，谁开发的程序就由谁来调试</td></tr></tbody></table><p>33、试叙述面向对象的单元测试、组装测试、确定测试的内涵。</p><p>（1）面向对象的单元测试<br>面向对象的单元测试是进行面向对象集成测试的基础。面向对象的单元测试以类或对象为单位。由于类包含一组不同的操作，并且某些特殊的操作可能被多个类共享，因此，单元测试不能孤立地测试某个操作，而是将操作作为类的一部分来测试。<br>（2）面向对象的集成测试<br>因为在面向对象的软件中没有层次的控制结构，并且构成类的成分彼此之间存在着直接或间接的交互作用，所以，传统意义上的自顶向下和自底向上的集成策略将不再适用。<br>（3）面向对象的确认测试<br>在确认测试层次，不需要再考虑类的实现和交互的具体细节，只要验证交互过程及功能，包括提供的用户界面，用户可见的操作，软件的反应和输出的结果等情况，其中测试用例的选择主要是依据动态模型和系统的脚本描述。</p><p>34、为什么要进行软件维护？软件维护通常有几种类型？</p><p>对软件进行维护的根本目的是为了延长软件的生存期。软件维护的原因除了软件在开发过程中的错误需要修改外，根本的原因是变化，使用软件的机构的工作流程、组织机构、软件工作的软硬件环境等都在变化，要求使用的软件也跟着变化，所以必须对软件进行维护。<br>维护的类型有四种（1）改正性维护（2）适应性维护（3）完善性维护（4）预防性维护</p><p>35、 请说明软件维护组织中各种人员及其职责。</p><p>答：维护组织机构内一般设修改负责人、维护管理员、系统监督员、配置管理员、维护人员等。各自的职责是：<br>修改负责人是维护的行政领导，管理维护的人事工作。<br>维护管理员负责接受维护申请，他把申请转交给系统监督员（或称系统管理员）去评价。并负责向上级报告维护工作。<br>系统监督员对维护任务做出评价。<br>配置管理员严格把关程序修改过程，控制修改的范围，对软件配置进行审计。<br>维护人员负责分析程序的维护要求并进行程序的修改工作。</p><p>36、请说明软件维护的流程。</p><p>答：（1）确定维护的类型及维护要求（2）根据不同维护类型确定维护的时机和策略（3）实施维护任务。（4）维护复审。</p><p>37、什么是软件的可维护性。</p><p>答：软件可维护性是指维护人员理解、改正和改进这个软件的难易程度。</p><p>38、简述决定软件可维护性的因素。</p><p>答：1）可理解性2）可测试性3）可修改性4）可靠性5）可移植性6）可使用性7）效率</p><p>39、简述提高软件可维护性的方法。</p><p>答：1）建立明确的软件质量目标2）使用先进的软件开发技术和工具3）进行明确的质量保证审查4）选择可维护的程序设计语言5）改进程序文档。</p><p>40、软件维护的副作用有哪些？</p><p>答：代码的副作用，数据的副作用，文档的副作用。</p><p>41、软件质量的六个要素是什么？</p><p>答：软件质量的6个要素是：<br>（1）功能性：软件所实现的功能满足用户需求的程度。<br>（2）可靠性：在规定的时间或条件下，软件所维持其性能水平的程度。<br>（3）易使用性：对于一个软件，用户学习、操作、准备输入和理解输出时所做努力的程度。<br>（4）效率：在指定的条件下，用软件实现某种功能所需的计算机资源（包括时间）的有效程度<br>。<br>（5）可维护性：在一个可运行的软件中，为了满足用户需求、环境改变或软件错误发生时进行相应修改所做的努力的程度。<br>（6）可移植性：把程序从一个计算机系统或环境转移到另一个计算机系统或环境的容易程度。</p><p>42、软件工程标准化的意义有哪些？</p><p>答：软件工程标准化会给软件开发工作带来以下好处：<br>（1）提高软件的可靠性、可维护性和可移植性，从而提高软件产品的质量。<br>（2）提高软件的生产率，提高软件人员的技术水平。<br>（3）改善软件开发人员之间的通信效率、减少差错。<br>（4）有利于软件工程的管理。<br>（5）有利于降低软件成本、缩短软件开发周期，降低运行与维护成本。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>操作系统的特征：并发，共享，虚拟和异步</strong> </p><p>   *<em>并发*</em>:****<strong>计算机中存在多个运行的程序，需要OS管理和调度。</strong>  </p><p>   多个应用程序交替执行，需要知道所有运行的程序当前的执行的位置，当前正在执行的是哪一个应用，如果应用之间有切换的时候，切换到下一个应用的时候，它上次执行到什么位置，这次就从什么时候开始。当时的状态是什么样子，都需要操作系统来维护。  </p><p>   <strong>共享: “同时”共享 和 互斥共享</strong>  </p><p>   多个应用并发执行的时候，宏观上要体现出它们在同时访问资源的情况，而微观上要实现它们的互斥访问。比如说我们说到的内存，两个应用同时访问内存，那这个时候，每个应用需要知道它访问的是哪一个，另一个应用访问的是哪一个，他们俩之间不能访问出错，其中一个需要保护的内存资源，不能让另外一个应用去访问。在微观上需要对它们做很好的隔离，因为在数据总线上任何时刻只有一个应用去访问存储单元，这就是所说的微观上的互斥。  </p><p>   <strong>虚拟:利用多道程序设计技术(程序的交替运行)，让每个用户都觉得有一个计算机专门为他服务。</strong>  </p><p>   操作系统在每个应用执行的时候，这种交替执行的交替频率特别高，让用户在应用的时候感觉不太出来这台机器还有其他用户在用，当然负载大到一定程度，用户是可以感觉到的。  </p><p>   <strong>异步:1.程序的执行不是一贯到底的，而是走走停停，向前推进的速度不可预知。2.只要运行的环境相同，OS需要保证程序运行的结果也要相同。</strong>  </p><p>   如果说某个应用就是需要知道跟时间相关的这种走走停停的信息，也是可以在操作系统的支持之下，发现这种时间上的差异的。  </p><p>响应时间&#x3D;进程运行结束的时间—进程到达的时间  </p><p>周转时间：从一个批处理作业提交时刻开始直到该作业完成所经过的时间间隔（包括作业进入内存前的等待时间、在后备队列中的等待时间、占用CPU后的运行时间以及完成各种IO操作的时间）</p><p>磁盘访问总时间&#x3D;寻道时间+旋转时间+传输时间。其中，寻道时间最长</p><p><strong>静态重定位</strong>在逻辑地址转换为物理地址的过程中，<strong>地址变换在进程装入时一次完成，以后不再改变。</strong>程序的存储空间只能是连续的一片区域，而且**在重定位之后就不能再移动。这不利于内存空间的有效使用。  </p><p>动态重定位<strong>是在程序执行期间每次访问内存之前进行重定位。</strong>可变分区容易产生外部碎片。由于进程的位置发生了变化，所以要对进程在内存中的地址进行修改。<strong>修改的过程就是重定位的过程，所以这种做法也叫动态重定位</strong>。装入程序在把<strong>装入模块装入内存后</strong>，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。</p><p>重定位：就是把作业地址空间中使用的逻辑地址变换为存储空间的物理地址的过程，又称为地址映射 </p><p>  动态重定位：程序在执行的过程中还可以重定位，由地址变换机构进行地址变换，有以下两种实现方式：</p><pre><code>  重定位寄存器（一般用在段页式存储中）：即基址寄存器，将指令中的有效地址与重定位寄存器中的基址相加得到访问地址，从而实现地址动态修改；采用页表描述虚、实页面的对应关系。</code></pre><p><strong>对换</strong>是指<strong>将内存中的暂时还不能被运行的进程或者暂时用不到的程序和数据，调到外存上</strong>，以便腾出足够的内存供在外存中等待的作业使用</p><p><strong>分页</strong>是一种操作系统里存储器管理的一种技术，<strong>可以使电脑的主存使用存储在辅助存储器中的数据。</strong>操作系统会将辅助存储器（通常是磁盘）中的数据分区成固定大小的区块，称为“页”。<strong>当不需要时，将分页由主存（通常是内存）移到辅助存储器；当需要时，再将数据取回，加载主存中</strong></p><p>分时操作系统的特征</p><p>1）同时性，计算机系统能被多个用户同时使用；（2）独立性：用户和用户之间都是独立操作系统的，在同时操作时并不会发生冲突，破坏，混淆等现象；（3）及时性：系统能以最快的速度将结果显示给用户；（4）交互作用性：用户能和电脑进行人机对话 </p><p>首次适应算法：地址递增，找到第一个能满足的空闲区；  </p><p>最佳适应算法：空闲分区容量递增，找到最接近条件的最符合的空闲区； </p><p>最坏适应算法：空闲分区容量递减，挑选出容量最大的符合的空闲区； </p><p>邻近适应算法：由首次适应算法演变而来，从上一次结束的位置开始查找。</p><p>共有3个进程，5个资源，进程数小于资源数，则不会发生死锁的公式为<br> ①最多申请资源数&#x3D;资源总数&#x2F;进程数（可以整除的条件下）<br> ②最多申请资源数&#x3D;（资源总数&#x2F;进程数）+1（不可以整除的条件下）<br> 所以本题用②的计算方式，得出结果为5&#x2F;3+1&#x3D;2  </p><p>一、分区存储管理<br> 1、固定分区：<br> 优点：易于实现、开销小<br> 缺点：存在内部碎片(分区内未被利用空间)、分区总数固定，限制了并发执行的程序数量。 </p><p>2、动态创建分区：按照程序申请要求分配。<br> 优点： 没有内部碎片<br> 缺点：有外部碎片(难以利用的小空闲分区) </p><p>二、页式存储管理<br> 优点： 没有外部碎片，最后一页可能有内碎片但不大; 程序不必连续存放;便于改变程序占用空间大小。<br> 缺点： 程序仍需要全部装入内存。</p><p><strong>1）一个作业可由多个进程组成，且必须至少由一个进程组成，反过来则不成立。</strong><br> <strong>一个</strong>作业通常包括程序、数据和操作说明书3部分，每一个进程由PCB、程序和数据集合组成。这说明程序是进程的一部分，是进程的实体。</p><p> 1.<strong>先来先服务调度算法（FCFS）</strong>:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。 因此选A；  </p><p>2.<strong>短作业优先调度算法</strong>      <strong>(SPF):</strong> 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。           </p><p>3.<strong>最高响应比优先算法(HRN)：</strong>FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比&#x3D;1+作业等待时间&#x2F;作业处理时间。 因此选C；  </p><ol start="4"><li><strong>基于优先数调度算法(HPF)：</strong>每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。</li></ol><h2 id="常见的批处理作业调度算法"><a href="#常见的批处理作业调度算法" class="headerlink" title="常见的批处理作业调度算法"></a>常见的批处理作业调度算法</h2><ol><li><p><strong>先来先服务调度算法（FCFS）</strong>:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。</p></li><li><p><strong>短作业优先调度算法(SPF)</strong>: 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。 </p></li><li><p><strong>最高响应比优先算法(HRN)：</strong>FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比&#x3D;1+作业等待时间&#x2F;作业处理时间。</p></li><li><p>**基于优先数调度算法(HPF)**：每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。</p></li><li><p><strong>均衡调度算法</strong>，即多级队列调度算法**</p></li></ol><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ol><li><strong>先进先出算法(FIFO)：</strong>按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。</li><li><strong>时间片轮转算法(RR)：</strong>分时系统的一种调度算法。轮转的基本思想是，将CPU的处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。</li><li><strong>最高优先级算法(HPF)：</strong>进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。 </li><li><strong>多级队列反馈法：</strong>几种调度算法的结合形式多级队列方式。</li></ol><p><strong>进程的特征</strong></p><p>并发性：指多个进程实体同存于内存中，且在一段时间内同时运行。<strong>并发性是进程的重要特征</strong>，同时也成为操作系统的重要特征。 </p><p>  2、动态性：进程的实质是进程实体的一次执行过程，因此，<strong>动态性是进程最基本的特征。</strong> </p><p>  3、独立性：进程实体是一个独立运行、独立分配资源和独立接受调度的基本单位。 </p><p>  4、异步性：指进程按各自独立的、不可预知的速度向前推进，或者说实体按异步方式运行。</p><h2 id="空闲分区分配算法"><a href="#空闲分区分配算法" class="headerlink" title="空闲分区分配算法"></a>空闲分区分配算法</h2><ol><li><p><strong>首先适应算法：</strong>当接到内存申请时，查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配。此算法简单，可以快速做出分配决定。</p></li><li><p><strong>最佳适应算法：</strong>当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其进行分割并分配。此算法最节约空间，因为它尽量不分割到大的空闲区，其缺点是可能会形成很多很小的空闲分区，称为“碎片”。 </p></li><li><p><strong>最坏适应算法：</strong>当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。该算法的优点是避免形成碎片，而缺点是分割了大的空闲区后，在遇到较大的程序申请内存时，无法满足的可能性较大。</p></li></ol><h2 id="虚拟页式存储管理中的页面置换算法"><a href="#虚拟页式存储管理中的页面置换算法" class="headerlink" title="虚拟页式存储管理中的页面置换算法"></a>虚拟页式存储管理中的页面置换算法</h2><ol><li><p><strong>理想页面置换算法(OPT)：</strong>这是一种理想的算法，在实际中不可能实现。该算法的思想是：发生缺页时，选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。</p></li><li><p><strong>先进先出页面置换算法(FIFO)：</strong>选择最先进入内存的页面予以淘汰。</p></li><li><p><strong>最近最久未使用算法（LRU）：</strong>选择在最近一段时间内最久没有使用过的页，把它淘汰。</p></li></ol><p><strong>4. 最少使用算法（LFU）：</strong>选择到当前时间为止被访问次数最少的页转换。</p><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p><strong>1.先来先服务（FCFS）</strong> </p><p><strong>2.最短寻道时间优先（SSTF）</strong>：让离当前磁道最近的请求访问者启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题</p><p><strong>3.扫描算法（SCAN）或电梯调度算法：</strong>总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。</p><p><strong>4.循环扫描算法（CSCAN）：</strong>循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。</p><p> 同一进程内的所有线程共享该进程的虚拟地址空间</p><p>位示图法是利用一串二进制位的值来反映磁盘空间的分配使用情况。  </p><p> 空闲块法是文件系统建立了一张记录全部空闲物理块的空闲块表。 </p><p> 空闲块链表法是系统将所有的空闲物理块连成一个空闲块链表，用一个指针指向第一个空闲块，每个空闲块含有指向下一个空闲块的指针，最后一块的指针指向NULL，表示达到链尾。 </p><p> UNIX系统采用的是一种对空闲块链表改进的方法，把所有空闲块按固定数量分组，组与组之间形成链接关系，这就是空闲块成组链接法。</p><p>同步：直接制约；互斥：间接制约。 </p><p><strong>虚拟内存的实际容量</strong>≤内存容量+外存容量 虚拟内存的最大容量≤计算机的地址位数那容纳的最大容量 </p><p>Unix的文件系统是索引文件结构，MS-DOS的则是显式链接文件结构  </p><p>进程切换时核心态完成的，不能再用户态完成；</p><p><strong>LRU:最近最少使用淘汰算法.</strong></p><p>  就像排队，被叫到但是队中没有就缺了，被叫到的队中有则不缺，再把其放在队尾，继续叫号。</p><p>  缺页为：</p><p>4　　　　　　　　      缺1</p><p>4　　3　　　  　　　  缺1  </p><p>4　　3　　2 　　　　 缺1</p><p>4　　3　　2　　1　　缺1</p><p>3　　2　　1　　4　　不缺</p><p>2　　1　　4　　3　　不缺</p><p>1　　4　　3　　5　　缺1</p><p>1　　3　　5　　4　　不缺</p><p>1　　5　　4　　3　　不缺</p><p>5　　4　　3　　2　　缺1</p><p>4　　3　　2　　1　　缺1</p><p>  3　　2　　1　　5　　缺1</p><p>  2　　1　　5　　4　　缺1</p><p>我来为您详细解释RAID的概念：</p><p>RAID (Redundant Array of Independent Disks) 是一种将多个硬盘组合成一个逻辑单元的存储技术。主要目的是提升性能或提供数据冗余。以下是主要的RAID级别：</p><p>基本RAID级别：</p><p>RAID 0 (条带化)<br>至少需要2块硬盘<br>数据被平均分配到所有磁盘上<br>优点：读写性能最好<br>缺点：没有冗余，一旦有磁盘损坏，数据全部丢失<br>可用容量：所有磁盘容量之和<br>RAID 1 (镜像)<br>至少需要2块硬盘<br>数据被完整复制到每块磁盘<br>优点：提供完整数据冗余<br>缺点：存储效率低，只有50%<br>可用容量：单个磁盘容量<br>RAID 5<br>至少需要3块硬盘<br>数据和校验信息分布在所有磁盘上<br>优点：兼顾性能和冗余<br>缺点：写入性能相对较低<br>可用容量：(N-1)×单盘容量<br>复合RAID级别：</p><p>RAID 10 (RAID 1+0)<br>先做RAID 1镜像，再做RAID 0条带<br>至少需要4块硬盘<br>优点：高性能和高可靠性<br>可用容量：总容量的50%<br>RAID 50 (RAID 5+0)<br>多组RAID 5再做RAID 0<br>至少需要6块硬盘<br>优点：大容量，好性能，有冗余<br>可用容量：(N-M)×单盘容量（N为总盘数，M为RAID 5组数）<br>选择建议：</p><p>追求性能：RAID 0<br>追求安全：RAID 1<br>性能与安全平衡：RAID 5或RAID 10<br>大容量应用：RAID 50</p><p>广义指令，用户态和系统态都可 </p><p>未被修改的页直接从文件区读入，而被置换时不需要调出；已被修改的页面，被置换时需要调出到交换区，以后从交换区调入。 </p><p> 页表表项中的访问位是由CPU置位的 </p><p>  页表表项中的存在位是由操作系统代码置位的</p><p>多道批处理系统的优点：资源利用率大幅提升，系统吞吐量增大   缺点：用户响应时间长，没有交互功能 </p><p>  分时操作系统解决了人机交互功能，但不能处理一些紧急任务 </p><p>  实时操作系统的特点：及时性和可靠性 </p><p>  分布式操作系统的特点：分布性和并行性，  系统中各个计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行，协同完成 </p><p>静态重定位是在程序执行之前进行重定位，它根据装配模块将要装入的内存起始位置，直接修改装配模块中的有关使用地址的指令。静态重定位有着无需硬件支持的优点，但存在着如下的缺点：一是程序重定位之后就不能在内存中搬动了；二是要求程序的存储空间是连续的，不能把程序放在若干个不连续的区域内。</p><p>引发新的调度的几个时刻：</p><p>1、新进程到来；</p><p>2、当前进程时间片用完；</p><p>3、进程结束阻塞状态；比如退出系统调用并返回；而对于临界区中是否可以进行进程调度，一般而言是可以的；比如当进程访问外部设备时，进程由运行态转为阻塞态，此时进程重新调度</p><p> 临界区：每个进程中访问临界资源的那段程序叫做临界区。 </p><p>  进程对临界区的访问必须互斥，每次只允许一个进程进去临界区，其他进程等待</p><p> 多道操作系统特意准备： 特权指令（多道优先级）  跳转指令（程序跳转）</p><p>件存储结构&#x3D;文件物理结构&#x3D;磁盘文件结构</p><p>  连续文件类似于数组，顺序访问速度快，但是增删数据时要移动其他数据块，所以速度很慢，当文件很大时，增删文件内容会非常痛苦； </p><p>  链接文件类似于链表，随机访问速度慢，增删数据很快，不需要移动数据块，只需要改变指针指向即可，当文件很大时，随机访问文件内容可能非常慢； </p><p>  索引文件糅合了连续文件和链接文件，但更适合大文件； </p><p>  多级索引结构中级数越高适用的文件越大，但是出现相对较小文件时又会造成磁盘空间浪费，<br> 混合索引结构更灵活，可以既包括单索引，又包括二级索引，甚至包括三级，四级甚至更高级，能够兼容各个量级的大文件。</p><p><strong>一个新的磁盘是一个空白版</strong>，必须分成扇区以便磁盘控制器能读和写，这个过程称为低级格式化（或物理格式化）。<strong>低级格式化为磁盘的每个扇区采用特别的数据结构，包括校验码</strong>，Ⅲ错误。为了使用磁盘存储文件，操作系统还需要将自己的数据结构记录在磁盘上。这分为两步。<strong>第一步是将磁盘分为由一个或多个柱面组成的分区，每个分区可以作为一个独立的磁盘</strong>，Ⅰ错误。在分区之后，第二步是<strong>逻辑格式化（创建文件系统）</strong>。在这一步，操作系统将初始的文件系统数据结构存储道磁盘上。这些数据结构包括空闲和已分配的空间和一个初始为空的目录，Ⅱ、Ⅳ正确。</p><p>分时系统具有多路性、交互性、“独占”性和及时性的特征。 </p><p>  <strong>多路性</strong>指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。 </p><p>  <strong>交互性</strong>是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。 </p><p>  <strong>“独占”性</strong>是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。 </p><p>  <strong>及时性</strong>指，系统对用户提出的请求及时响应。</p><p>静态链接是指在程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开的链接方式。<br> 装入时动态链接是指将用户源程序编译后得到的一组目标模块，在装入内存时采用边装入边链接的链接方式。运行时动态链接是指对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。</p><h4 id="微内核的特点"><a href="#微内核的特点" class="headerlink" title="微内核的特点"></a>微内核的特点</h4><ol><li>足够小的内核</li></ol><p>  在微内核操作系统中，内核是指精心设计的、能实现现代OS最基本的核心功能的部分。微内核并非是一个完整的OS，而只是操作系统中最基本的部分，它通常用于： </p><p>  ① 实现与硬件紧密相关的处理； </p><p>  ② 实现一些较基本的功能； </p><p>  ③ 负责客户和服务器之间的通信。 </p><p>  它们只是为构建通用OS提供一个重要基础，这样就可以确保把操作系统内核做得很小。 </p><ol start="2"><li>基于客户&#x2F;服务器模式</li></ol><p>  由于客户&#x2F;服务器（Client&#x2F;Server）模式，具有非常多的优点，故在单机微内核操作系统中几乎无一例外地都采用客户&#x2F;服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(进程)中实现。例如用于提供对进程(线程)进行管理的进程(线程)服务器，提供虚拟存储器管理功能的虚拟存储器服务器，提供I&#x2F;O设备管理的I&#x2F;O设备管理服务器等，它们都是被作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。 </p><ol start="3"><li>应用“机制与策略分离”原理</li></ol><p>  在现代操作系统的结构设计中，经常利用“机制与策略分离”的原理来构造OS结构。所谓机制，是指实现某一功能的具体执行机构。而策略，则是在机制的基础上，借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。通常，机制处于一个系统的基层，而策略则处于系统的高层。在传统的OS中，将机制放在OS的内核的较低层，把策略放在内核的较高层次中。而在微内核操作系统中，通常将机制放在OS的微内核中。正因为如此，才有可能将内核做得很小。 </p><ol start="4"><li>采用面向对象技术</li></ol><p>  操作系统是一个极其复杂的大型软件系统，我们不仅可以通过结构设计来分解操作系统的复杂度，还可以基于面向对象技术中的“抽象”和“隐蔽”原则控制系统的复杂性，再进一步利用“对象”、“封装”和“继承”等概念来确保操作系统的“正确性”、“可靠性”、“易修改性”、“易扩展性”等，并提高操作系统的设计速度。正因为面向对象技术能带来如此多的好处，故面向对象技术被广泛应用于现代操作系统的设计中。   </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h1><h1 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h1><p>1.数据：所有能被输入到计算机中，且能被计算机处理的<strong>符号的集合</strong>。而数据结构中主要讨论结构化</p><p>数据。</p><p>2.数据元素：是数据（集合）中的一个“个体”，数据结构中的基本单位。表中的一行</p><p>3.数据项：一个<strong>数据元素可由若数据项组成</strong>，数据项是构成数据元素不可分割的单位。表中的一列</p><p>4.数据对象：数据对象是具有相同性质的<strong>数据元素的集合</strong>，是数据的一个子集。一张表或者是这张表的子表</p><p>5.关键码：也叫关键字（Key〉，是数据元素中能起标识作用的数据项</p><p>6.关系：数据元素之间的关系。<strong>数据结构中讨论的元素关系主要是指相邻关系或邻接关系</strong>。</p><p>7.数据类型是<strong>一个值的集合</strong>和定义在此集合上一<strong>组操作的总称</strong>。</p><p>（1）原子类型：其值不可再分的数据类型。</p><p>（2） 结构类型，其值可以再分解为考干成分（分量）的类型类型。</p><p>（3） 抽象数据类型：抽象数据组织和与之相关的操作。</p><p>8.数据类型：是一个值的集合和定义在此集合上的一组操作的总称。数据类型和数据结构的关系：数</p><p>据类型就是已经实现了的数据结构。</p><h2 id="数据结构相关定义"><a href="#数据结构相关定义" class="headerlink" title="数据结构相关定义"></a>数据结构相关定义</h2><p>数据结构包括：逻辑结构、存储结构(物理结构)和数据运算(数据操作)</p><p>数据的逻辑结构：数据元素之间的逻辑关系(线性和非线性结构)。</p><p>存储结构：顺序存储、链式存储、素引存储和散列存储。</p><p>数据操作：对数据要进行的运算。<strong>运算的定义</strong>是针对<strong>逻辑结构</strong>的，指出运算的功能。<strong>运算的实现</strong>是针对<strong>存储结构</strong>的，指出<strong>运算的具体操作步骤</strong>。</p><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><ol><li><p>ADT 是指一个数学模型以及定义在该模型上的一组操作。</p></li><li><p>ADT 的定义仅是一组逻辑特性描述，与其在计算机内的表示和实现开关。因此，不论ADT 的内部结构如何变化，只要其数学特性不变，都不影响其外部使用.</p></li><li><p>ADT 的形式化定义是三元组：ADT&#x3D;(D,S,P) D其中口是数据对象，S是D上的<strong>关系集</strong>，P是对D的<strong>基本操作集。</strong></p></li><li><pre><code>ADT Stack &#123;    数据对象:        一个有限线性表        操作集合:        push(x)    // 将元素x压入栈顶        pop()      // 删除并返回栈顶元素        peek()     // 返回栈顶元素但不删除        isEmpty()  // 判断栈是否为空        size()     // 返回栈中元素个数&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 逻辑结构</span><br><span class="line"></span><br><span class="line">数据元素之间的关系成为逻辑关系，相应的结构称为逻辑结构</span><br><span class="line"></span><br><span class="line">逻辑结构元素决定输入、存储、发送、处理和信息传递的基本操作功能。</span><br><span class="line"></span><br><span class="line">逻辑结构的类型：集合：没有关系。线性结构：一对一的关系，树型结构：一对多的关系。图状结构：多对多的关系</span><br><span class="line"></span><br><span class="line">![image-20241124095413926](https://raw.githubusercontent.com/a186232641/images/master/img/202411240954080.png)</span><br><span class="line"></span><br><span class="line">### 存储结构</span><br><span class="line"></span><br><span class="line">数据结构在计算机内存中的存储包括**数据元素的存储和元素之间的关系的表示**。数据的逻辑结构和物理结构是密不可分的两个方面，一个**算法的设计取决于所选定的逻辑结构**，而**算法的实现依赖于所采用的存储结构**。数据的存储结构有：顺序存储、链式存储、索引存储、散列存储。</span><br><span class="line"></span><br><span class="line">1. 顺序存储</span><br><span class="line">   1. 用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构（关系）。</span><br><span class="line">   2. 数据元素存放的地址是连续的。</span><br><span class="line">   3. 优点是可以实现**随机存取**，每个元素占有最少的存储空间。</span><br><span class="line">   4. 只能用相邻的一整块存储单元，可能产生外部碎片</span><br><span class="line">2. 链式存储</span><br><span class="line">   1. 每个数据元素增加指针指向另一元素</span><br><span class="line">   2. 地址可以不连续</span><br><span class="line">   3. 优点：不会出现碎片，充分利用存储单元</span><br><span class="line">   4. 缺点：需要额外的指针空间，只能顺序存取</span><br><span class="line">3. 索引存储</span><br><span class="line">   1. 建立附加的索引表，格式为(关键字,地址)</span><br><span class="line">   2. 优点：检索速度快</span><br><span class="line">   3. 缺点：需要额外的索引表空间，增删数据时需要修改索引表</span><br><span class="line">4. 散列存储</span><br><span class="line">   1. 散列存储</span><br><span class="line">   2. 根据关键字直接计算存储地址（哈希存储）</span><br><span class="line">   3. 优点：**检索、增加和删除**操作都很快</span><br><span class="line">   4. 可能出现冲突，解决冲突需要额外开销</span><br><span class="line"></span><br><span class="line">### 算法</span><br><span class="line"></span><br><span class="line">算法定义：是对特定问题求解方法的一种描述，指令的有限序列，每条指令表示一个或多个操作</span><br><span class="line"></span><br><span class="line">#### 算法特性</span><br><span class="line"></span><br><span class="line">有穷性：算法必须在有限步骤后结束，且每步都在有限时间内完成。</span><br><span class="line"></span><br><span class="line">确定性：每条指令必须有明确含义，不存在二义性，**算法只有一个入口和一个出口**。</span><br><span class="line"></span><br><span class="line">可行性：算法必须能执行，所有操作都可通过基本运算执行。</span><br><span class="line"></span><br><span class="line">输入与输出：输入：可以有零个或多个输入，来自特定对象集合。输出：有一个或多个输出，与输入有特定关系</span><br><span class="line"></span><br><span class="line">#### 算法描述</span><br><span class="line"></span><br><span class="line">可用多种方法描述：自然语言描述，形式语言描述，计算机程序设计语言描述。</span><br><span class="line"></span><br><span class="line">算法和程序的区别：程序是算法用特定程序设计语言的具体实现，**不是所有程序都是算法**。</span><br><span class="line"></span><br><span class="line">#### 算法设计的要求</span><br><span class="line"></span><br><span class="line">1. 正确性：满足具体问题需求</span><br><span class="line">2. 可读性：易于理解和交流</span><br><span class="line">3. 健壮性：能适当处理非法或错误输入</span><br><span class="line">4. 通用性：处理结果适用于一般数据集合</span><br><span class="line"></span><br><span class="line">### 时空复杂度</span><br><span class="line"></span><br><span class="line">#### 影响算法效率的因素</span><br><span class="line"></span><br><span class="line">- 算法策略选择</span><br><span class="line">- 问题规模</span><br><span class="line">- 程序设计语言</span><br><span class="line">- 编译程序产生的机器代码质量</span><br><span class="line">- 指令执行速度</span><br><span class="line"></span><br><span class="line">#### 时间复杂度</span><br><span class="line"></span><br><span class="line">常见的时间复杂度（从快到慢）：</span><br><span class="line"></span><br><span class="line">1. O(1)：常量时间阶，执行次数固定</span><br><span class="line">2. O(log n)：对数时间阶</span><br><span class="line">3. O(n)：线性时间阶</span><br><span class="line">4. O(n log n)：线性对数时间阶</span><br><span class="line">5. O(n^k)：k≥2，k次方时间阶，执行次数是k次多项式</span><br><span class="line"></span><br><span class="line">- 复杂度大小关系：O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(n³)</span><br><span class="line">- 指数与多项式关系：O(2ⁿ) &lt; O(n!) &lt; O(nⁿ)</span><br><span class="line"></span><br><span class="line">#### 时间复杂度类型</span><br><span class="line"></span><br><span class="line">1. 最坏时间复杂度：最坏情况下的时间复杂度</span><br><span class="line">2. 平均时间复杂度：所有可能输入等概率出现时的期望运行时间</span><br><span class="line">3. 最好时间复杂度：最好情况下算法的时间复杂度</span><br><span class="line"></span><br><span class="line">#### 空间复杂度</span><br><span class="line"></span><br><span class="line">1. 基本概念：指算法运行所需存储空间的度量，表示为S(n) = O(f(n))，n为问题规模</span><br><span class="line"></span><br><span class="line">2. 存储空间包括三个方面：指令常数变量所占空间，输入数据所占空间，辅助存储空间（主要考察这部分）。</span><br><span class="line"></span><br><span class="line">1. 常见的空间复杂度：一维数组a[n]：O(n)，二维数组a[n][m]：O(n*m)，算法原地工作：O(1)</span><br><span class="line"></span><br><span class="line"># 线性表</span><br><span class="line"></span><br><span class="line">![image-20241125101729158](https://raw.githubusercontent.com/a186232641/images/master/img/202411251017555.png)</span><br><span class="line"></span><br><span class="line"># 树</span><br><span class="line"></span><br><span class="line">- 平衡二叉树，或是一棵空树，或符合以下特性：     </span><br><span class="line"></span><br><span class="line">​     **【平衡特性1】**：左子树的深度和右子树的深度相差不能超过1，可以是0（代表左右子树深度一样）、-1（代表左子树比右子树少一层）、1（代表左子树比右子树多一层） </span><br><span class="line"></span><br><span class="line">​    **【平衡特性2】它的左右子树也要是平衡二叉树** </span><br><span class="line"></span><br><span class="line">查找树，**或是一棵空树**，或满足符合以下特性：     </span><br><span class="line"></span><br><span class="line">​    **【查找特性1】**：若左子树不为空，左子树节点**所有的值**均要小于根节点； </span><br><span class="line"></span><br><span class="line">​    **【查找特性2】：** 若右子树不为空，右子树节点**所有的值**均要大于根节点； </span><br><span class="line"></span><br><span class="line">  **【查找特性3】它的左右子树也要是查找树**</span><br><span class="line"></span><br><span class="line">如果是**二叉树**，那么必须要**先序+中序**，或者**中序+后序**，但是题目中说的是**树**，**树的先序（根）== 二叉树的先序**，**树的后序（根）== 二叉树的中序**，所以是一定**可以构造出来**的。</span><br><span class="line"></span><br><span class="line"># 图</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0cf12c036e83e88c75d46946d6d0b69b.png#pic_center)</span><br><span class="line"></span><br><span class="line">一个图G 若满足:①不存在重复边;②不存在顶点到自身的边，则称图G为**简单图**。</span><br><span class="line">若图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为**多重图**。</span><br><span class="line"></span><br><span class="line">**完全图**：任意两个顶点之间都存在边</span><br><span class="line"></span><br><span class="line">**连通、连通图和连通分量**</span><br><span class="line"></span><br><span class="line">在无向图中，若**从顶点v到顶点w 有路径存在**，则称v 和w 是**连通**的。**若图G 中任意两个顶点都是连通的**，则称图G为**连通图**，否则称为非连通图。**无向图中的极大连通子图称为连通分量**。若一个图有n个顶点，并且边数小于n − 1，则此图必是非连通图。如下图(a)所示，</span><br><span class="line"></span><br><span class="line"> 有3个连通分量</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d9f4f74f3c967ae965eb8e3ff714afed.png#pic_center)</span><br><span class="line"></span><br><span class="line">在有向图中，若从顶点v 到顶点w 和从顶点w 到项点v 之间**都有路径,**则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。**有向图中的极大强连通子图**称为有向图的强连通分量</span><br><span class="line"></span><br><span class="line">图的深度类似于数的先序遍历，图的广度类似于树的层次遍历</span><br><span class="line"></span><br><span class="line">无向图: vi的度=所连边数=矩阵第i行(或者i列)中1的个数。  有向图: vi的度数=入度＋出度=第i行元素之和+第i列元素之和(这里元素指1)</span><br><span class="line"></span><br><span class="line">要保证在任意连接方式下都能连通具有10个顶点的无向图，至少需要（）条边</span><br><span class="line"></span><br><span class="line">![img](https://uploadfiles.nowcoder.com/files/20181121/42853204_1542800268729_equation?tex=%5Cfrac%7B(n-1)(n-2)%7D%7B2%7D%2B1)</span><br><span class="line"></span><br><span class="line">第一个顶点和最后一个顶点相同的路径称为**回路**；序列中顶点不重复出现的路径称为**简单路径**；回路显然不是**简单路径**</span><br><span class="line"></span><br><span class="line">存在回路的有向图不存在拓扑序列，若**拓扑排序输出结束**后所**余下的顶点都有前驱**，则说明只得到了部分顶点的拓扑有序序列，图中存在回路</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/65c94af0f4f69462d672282dd52cef94.png#pic_center)</span><br><span class="line"></span><br><span class="line"> 如上图的AOE网，在AOE网中仅有一个入度为0的顶点，称为开始顶点(源点)，它表示整个工程的开始；网中也仅存在一个出度为0的顶点，称为结束顶点(汇点)，它表示整个工程的结束。我们把路径上各个活动所持续的时间之和称为路径长度，**从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。**</span><br><span class="line">**完成整个工程的最短时间就是关键路径的长**度，即**关键路径上各活动花费开销的总和**。这是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。</span><br><span class="line"></span><br><span class="line">对于关键路径，需要注意以下几点:</span><br><span class="line">①关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可通过加快关键活动来缩短整个工程的工期。但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。</span><br><span class="line">②网中的关键路径并不唯一，</span><br><span class="line">且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</span><br><span class="line"></span><br><span class="line">**判断有向图是否存在环**的2种方法（深度遍历，拓扑排序）</span><br><span class="line"></span><br><span class="line">带权的连通无向图的**最小代价生成树**不唯一的，只有当权值不相同时才唯一，**最小代价唯一**，树不唯一，因为可能有的边权值相同，导致有多种组成方式的树</span><br><span class="line"></span><br><span class="line">![image-20241129142345926](https://raw.githubusercontent.com/a186232641/images/master/img/202411291423449.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol><p>在n个结点的无向图中，若该图是连通图,则其边数大于等于n-1，<br>在n个结点的无向图中，若边数大于(n-2)(n-1)&#x2F;2，则该图必是连通图</p><pre><code>![img](http://uploadfiles.nowcoder.com/images/20151220/811262_1450603018360_072774B6B658B3603E1AA7198722775C)  6个城市，顶多4个中间城市，因为先经过A再经过B和先经过B再经过A是不一样的，所以用排列数   途径0个中间城市：    A(0,4) = 1    途径1个中间城市：     A(1,4) = 4     途径2个中间城市：     A(2,4) = 12     途径3个中间城市：     A(3,4) = 24     途径4个中间城市：     A(4,4) = 24  拓扑有序序列： 把AOV网络中各顶点按照他们相互之间的优先关系排列到一个线性序列的过程。若vi 是vj前驱，则vi  一定在vj，对于没有优先关系的点， 顺序任意。AOV网 (Activity On Vertex Network)- 用顶点表示活动，用弧表示活动之间的优先关系- 是一个有向无环图(DAG)- 若从顶点i到顶点j有一条弧，表示活动i必须在活动j之前完成- 常用于表示工程项目中各个活动之间的先后顺序- 主要用于确定活动的执行次序，比如课程的先修关系AOE网 (Activity On Edge Network)- 用边表示活动，用顶点表示事件- 也是一个有向无环图(DAG)- 边上的权值表示完成该活动所需的时间- 顶点表示某些活动完成的事件节点- 从源点到汇点具有最大路径长度的路径叫做关键路径- 主要用于工程估算，可以：  - 计算整个工程完成的最短时间  - 找出关键路径  - 确定哪些活动是关键活动![img](https://uploadfiles.nowcoder.com/images/20161106/3814779_1478422466632_097B0BAC2D6050FF5370024F82ACE77E)必须完成1-6所有的关键路径上的关键活动，才算完成工程这个网有三条关键路径： 1.  b、d、c、g    2. b、d、e、h   3.  b、f、h   缩短工期的活动要涵盖三条路径。无向图：多重链接表有向图：十字链表&amp;边集数组共有：邻接表＆邻接矩阵![逆邻接表](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ced0a38074cb47489f9201c21e3e6de7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径。把关键路径上的活动称为关键活动   完成整个工程的最短时间就是关键路径的长度，也就是关键路径上各活动花费开销的总和。这是因为关键活动影响了整个工程的时间，即如果关键活动不能按时完成的话，整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。 在一个有向图的拓扑序列中，若顶点 a 在顶点 b 之前，则图中必有一条a到b的路径Bellman-Ford 算法 这是一个解决带负权边的单源最短路径问题的算法。主要特点：1. 可以处理负权边，能检测负权回路2. 时间复杂度 O(VE)，其中 V 是顶点数，E 是边数3. 基本思想：对所有边进行 V-1 次松弛操作Kruskal 算法 这是一个构建最小生成树的贪心算法。适合边少的情况主要特点：1. 时间复杂度 O(E log E)，主要来自边的排序2. 使用并查集数据结构判断是否形成环3. 适合稀疏图Prim 算法 另一个构建最小生成树的贪心算法。适合顶点少的情况主要特点：1. 时间复杂度 O(E log V)（使用二叉堆实现）2. 从单个顶点开始逐步扩展3. 适合稀疏图Dijkstra 算法 解决非负权边的单源最短路径问题。![img](https://uploadfiles.nowcoder.com/images/20211030/143856044_1635595463386/60B79DE48BEF0084DE83F724803E98F6) Dijkstra是一种用来求单源最短路径的算法。 **单源是**什么意思？   从一个顶点出发，Dijkstra算法只能求一个顶点到其他点的最短距离而不能任意两点。       **算法思想**： 维护一个集合 S，集合内的点是已经确定最短路径的结点；      每次操作找出与集合相邻的点中距离起点最近的结点加入集合中，并确定它的最短路径值为它的前一已确定结点的最短路径值+该边权值，存在dis数组中。       **算法流程**： 首先把结点1加入集合（红色结点），蓝色结点为相邻结点， s=&#123;1&#125;，dis[]=&#123;0,∞,∞,∞,∞,∞,∞,∞&#125;      与S相邻的结点为2、3、5，把相邻结点路径最短的加入集合（即结点5） s=&#123;1,5&#125;，dis[]=&#123;0,1,∞,∞,∞,∞,∞,∞&#125;      与S相邻的结点为2、3、6、8，把相邻结点路径最短的加入集合（即结点3） s=&#123;1,5,3&#125;，dis[]=&#123;0,1,2,∞,∞,∞,∞,∞&#125;  与S相邻的结点为2、4、6、8，把相邻结点路径最短的加入集合（即结点2和4） s=&#123;1,5,3,2,4&#125;，dis[]=&#123;0,1,2,3,3,∞,∞,∞&#125;      与S相邻的结点为6、7、8，把相邻结点路径最短的加入集合（即结点8） s=&#123;1,5,3,2,4,8&#125;，dis[]=&#123;0,1,2,3,3,4,∞,∞&#125;      与S相邻的结点为6、7，把相邻结点路径最短的加入集合（即结点6和7） s=&#123;1,5,3,2,4,8,6,7&#125;，dis[]=&#123;0,1,2,3,3,4,5,5&#125;      # 排序插入排序平均时间复杂度为O(n^2)  插入排序最坏情况时间复杂度为O(n^2)冒泡排序平均时间复杂度为O(n^2)  冒泡排序最坏情况时间复杂度为O(n^2)堆排序平均时间复杂度为O(nlogn)希尔排序平均时间复杂度大致为O(n^1.5)归并排序平均时间复杂度为O(nlogn)   归并排序最坏情况时间复杂度为O(nlogn)快速排序最坏情况时间复杂度为O(n^2)数组元素，基本有序，所以快速排序是最慢的，因为会退化成冒泡排序 选择排序时间复杂度都是O（n^2),堆排序都是O(nlogn),但是基本有序对插入排序是最好的 因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)不稳定的含义是建立在有两个相同元素在排序前后，相对位置发生了变化。### 基数排序基数排序是通过“分配”和“收集”过程来实现排序。  1）首先根据个位数值（只看个位）来排序：  253 674 924 345 627  2）再看十位（只看十位数值大小）来排序：  924 627 345 253 674  3）最后看百位：  253 345 627 674 924![img](https://uploadfiles.nowcoder.com/images/20190226/242025553_1551168741392_E70A7C7F55EE4951924DEBF98CC9513D) **快速排序的原理**：**通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都不大于基准值，另一部分不小于基准值，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归****进行，以此达到整个数据变成有序序列。**最差情况下时间复杂度**   ：最差的情况就是每一次取到的元素就是数组中最小/最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序) 这种情况时间复杂度就好计算了，就是冒泡排序的时间复杂度：T[n] = n * (n-1) = n2+ n; 综上所述：快速排序最差的情况下时间复杂度为：O( n2 )，快速排序的最坏情况基于每次划分对基准值的选择，基本的快速排序选取第一个元素作为基准。这样在**数组已经有序的情况下，每次划分将得到最坏的结果**。直接选择排序的时间复杂度与初始排序无关（关键字比较次数与记录的初始排列无关的）已知数据表A中每个元素距其最终位置不远，为节省时间排序，应采用直接插入排序堆排序的时间复杂度是O(n*log(n))，堆排序中建堆过程的时间复杂度是O(n) 建堆有2种方法   第一种方法：**HeapInsert**（本题就是这种方法），它可以假定我们事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。这种插入建堆的时间复杂度是**O(NlogN)**   第二种方法：**Heapify** 从最后一个非叶子节点一直到根结点进行堆化的调整。如果当前节点小于某个自己的孩子节点（大根堆中），那么当前节点和这个孩子交换。这种建堆的时间复杂度是**O(N)**     Heapify是一种类似下沉的操作，HeapInsert是一种类似上浮的操作。待排序元素规模较小时，宜选取哪种排序算法效率最高冒泡排序在最好情况下，下列排序算法中 排序算法时间复杂度最低的是直接插入排序。希尔排序的思想是：先将待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成），分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。 </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2024/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2024/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/222fe425475cf2e344f09d4985d0947a.png" alt="在这里插入图片描述"></p><h3 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h3><h3 id="1-1-1-计算机硬件的发展"><a href="#1-1-1-计算机硬件的发展" class="headerlink" title="1.1.1 计算机硬件的发展"></a>1.1.1 计算机硬件的发展</h3><p>计算机系统&#x3D;<strong>硬件+软件</strong></p><p>摩尔定律，<strong>集成电路上的晶体管数量每18月就会翻一翻</strong>，所以每18月计算机的处理效率就会提高一倍。</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241323638.png" alt="image-20241124132336492"></p><h2 id="1-2-计算机系统层次结构"><a href="#1-2-计算机系统层次结构" class="headerlink" title="1.2 计算机系统层次结构"></a>1.2 计算机系统层次结构</h2><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241323360.png" alt="image-20241124132317759"></p><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><ul><li>冯诺曼体系结构特点:<ul><li>计算机硬件系统由五大部件组成(<strong>存储器、运算器、控制器、输出设备、输入设备</strong>)</li><li><strong>指令和数据以同等地位存于存储器</strong>，可按地址寻访</li><li><strong>指令和数据用二进制表示</strong></li><li><strong>指令由操作码和地址码组成</strong></li><li>存储程序</li><li>以<strong>运算器</strong>为中心</li></ul></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1e19b556dfdb19218953d62f26064fd.png" alt="在这里插入图片描述"></p><ul><li><h5 id="现代计算机的组织结构"><a href="#现代计算机的组织结构" class="headerlink" title="现代计算机的组织结构"></a>现代计算机的组织结构</h5></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c26b5953b18fb5ad6035c76b44073080.png" alt="在这里插入图片描述"></p><ul><li><p>&lt;1&gt; 输入设备，是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等</p></li><li><p>&lt;2&gt; 输出设备，就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机。</p></li><li><p>&lt;3&gt; 存储器，存储器分为 主存储器(内存储器，CPU能直接访问)和 辅助存储器(外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才可以被CPU访问)。</p><p><strong>主存储器</strong>的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式(<strong>相联存储器</strong>既可以既可以按照<strong>地址寻址</strong>，又可以按照<strong>内容寻址</strong>，为了与传统存储器区别，又称为<strong>内容寻址的存储器</strong>！)</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/309a748b65828c9af3944a37602e37a3.png" alt="在这里插入图片描述"></p><p>&lt;4&gt; 运算器，是计算机的运算单元，用于算术运算和逻辑运算，运算器的核心单元是算术逻辑单元(ALU)</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/59370b5b078eef087414167b20a06ca6.png" alt="在这里插入图片描述"></p></li></ul><p>&lt;5&gt; 控制器，控制器是计算机的指挥中心，有其指挥各部件自动协调第进行工作，现代计算机将<strong>运算器和控制器</strong>集成到一个芯片上，合成为中央处理器，简称CPU。有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/41438ab8fcd23f311c5b1013a4abe6bf.png" alt="在这里插入图片描述"></p><p>按照指令和数据流可以分为：</p><ul><li>单指令流和单数据流系统（SISD），即传统的冯·诺依曼体系结构。</li><li>单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统。</li><li>多指令流和单数据流系统（MISD），这种计算机实际上不存在。</li><li>多指令流和多数据流系统（MIMD），包括多处理器和计算机系统。</li></ul><h4 id="1-2-3-计算机软件的分类"><a href="#1-2-3-计算机软件的分类" class="headerlink" title="1.2.3 计算机软件的分类"></a>1.2.3 计算机软件的分类</h4><h5 id="系统软件和应用软件"><a href="#系统软件和应用软件" class="headerlink" title="系统软件和应用软件"></a>系统软件和应用软件</h5><ol><li>计算机软件，一般分为系统软件和应用软件<ul><li>系统软件包括 <strong>操作系统，数据库管理系统，语言处理系统(比如编译器)，分布式软件系统，网络软件系统，标准库系统，服务性系统</strong>(比如连接程序)。</li><li>应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序。</li></ul></li></ol><h5 id="三个级别的语言"><a href="#三个级别的语言" class="headerlink" title="三个级别的语言"></a>三个级别的语言</h5><ul><li>1)<strong>机器语言</strong>。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。</li><li>2)<strong>汇编语言</strong>。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li><li>3)<strong>高级语言</strong>。高级语言(如C、C++、Java等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</li></ul><p>由<strong>高级语言转换到汇编语言</strong>的过程叫做<strong>编译</strong>，由<strong>汇编语言转换到机器语言</strong>的过程叫做<strong>汇编</strong>，边翻译边执行的叫做解析。</p><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d82f6c97ea5a51a3346a3a42b85df158.png" alt="在这里插入图片描述"></p><p>IR存放当下<strong>欲执行的指令</strong>；PC存放<strong>下一条指令的地址</strong>；</p><p>MAR存放<strong>欲访问的存储单元地址</strong>；MDR存放<strong>从存储单元取来的数据</strong>！</p><p>地址译码器是<strong>主存的构成部分，不属于CPU</strong>；地址寄存器虽然一般属于主存，但是现代计算机中绝大多数CPU内集成了地址寄存器！</p><p>关于CPU存取速度的比较：寄存器（CPU内部）&gt; Cache(高速的SRAM) &gt; 内存 （SDRAM）</p><h3 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ee87767dc4377de8c9b2d8ede73410d4.png" alt="在这里插入图片描述"></p><ol><li>机器字长<br>计算机的位数（机器字长），表示<strong>计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数</strong>。计算机字长通常选定为字节(8位)的整数倍，通常是2,4,8倍。不同的计算机，字节可能不同</li></ol><blockquote><p>机器字长、指令字长、存储字长的区别和联系是什么？</p><ul><li><p><strong>机器字长</strong>：计算机能直接处理的二进制数据的位数，机器字长<strong>一般等于内部寄存器的大小</strong>，它决定了<strong>计算机的运算精度</strong>。</p></li><li><p>指令字长：一个<strong>指令</strong>字中包含的二进制代码的位数。</p></li><li><p>存储字长：一个存储单元存储的二进制代码的长度。<strong>等于MDR的位数</strong>， 它们都必须是字节的整数倍。</p></li><li><p>数据字长：<strong>数据总线一次能传送信息的位数</strong>，它可以不等于MDR的位数。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。。</p></li></ul></blockquote><ol start="2"><li><p>数据通路带宽:数据总线一次所能传送信息的位数.</p></li><li><p>主存容量MAR的位数反映存储单元的个数，如MAR为16位，表示存储单元为2^16 &#x3D; 64K;若MDR为32位，则存储容量为2^16x32.</p></li><li><p>运算速度</p><ol><li><p>吞吐量，指系统在单位时间内处理请求的数量 ；从用户观点看，它是评价计算机系统性能的综合参数！</p><p>响应时间，指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结构的等待时间。</p></li><li><p>CPU时钟周期。通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，每个动作至少需要1个时钟周期。1&#x2F;f</p><p>主频(CPU时钟频率)。机器内部主时钟的频率，是衡量机器速度的重要参数。</p><ul><li>CPU周期又称为机器周期，由多个时钟周期组成！</li><li>指令周期&gt;CPU周期&gt;时钟周期</li></ul></li><li><p>CPI（Clock cycle Per Instruction），即执行<strong>一条指令所需的时钟周期数</strong>。</p><ol><li>CPU执行时间，指运行一个程序所花费的时间。<br><strong>CPU执行时间</strong> &#x3D; CPU时钟周期数&#x2F;主频 &#x3D; (指令条数xCPI)&#x2F;主频<br>CPU的性能取决于三个要素:<strong>主频、CPI 、指令条数</strong></li></ol></li><li><p>IPS(Instructions Per Second) &#x3D;主频&#x2F;平均CPI，每秒执行多少指令</p><p>MIPS(Million Instructions Per Second)&#x3D;即每秒执行多少百万条指令。<br>MFLOPS(Mega Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x106),即每秒执行多少百万次浮点运算。<br>GFLOPS(Giga Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x109)，即每秒执行多少十亿次浮点运算。</p><p>TFLOPS(Tera Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x1012)，即每秒执行多少万亿次浮点运算。</p></li></ol></li></ol><p>同一个功能既可以由软件实现又可以由硬件实现吗？</p><pre><code>软件和硬件是两种完全不同的形态，硬件是实体，是物质基础；软件是一种信息，看不见、摸不到。但在逻辑功能上，软件和硬件是等效的。因此，在计算机系统中，许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。一个最大的区别就是，硬件实现比软件实现的速度快很多，但是成本也高！所以，芯片在流片之后，如果发现bug可以用软件修复就用软件修复！</code></pre><h4 id="机器字长、指令字长、存储字长的区别和联系是什么？"><a href="#机器字长、指令字长、存储字长的区别和联系是什么？" class="headerlink" title="机器字长、指令字长、存储字长的区别和联系是什么？"></a>机器字长、指令字长、存储字长的区别和联系是什么？</h4><ul><li><p>4.机器字长、指令字长、存储字长的区别和联系是什么？</p></li><li><p><strong>机器字长</strong>：计算机能直接处理的二进制数据的位数，机器字长<strong>一般等于内部寄存器的大小</strong>，它决定了<strong>计算机的运算精度</strong>。<br>指令字长：一个指令字中包含的二进制代码的位数。<br>存储字长：一个存储单元存储的二进制代码的长度。等于MDR的位数， 它们都必须是字节的整数倍。<br>数据字长：数据总线一次能传送信息的位数，它可以不等于MDR的位数。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和<strong>机器的指令字长与数据字长</strong>相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p></li></ul><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><h3 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h3><h4 id="总线：概念与分类"><a href="#总线：概念与分类" class="headerlink" title="总线：概念与分类"></a>总线：概念与分类</h4><ol><li>什么是总线<ol><li>定义：构成计算机系统的互联机构，是多个<strong>系统功能部件之间进行数据传送</strong>的公共通路</li><li>功能：计算机在各系统功能部件之间实现<strong>地址、数据和控制信息的交换</strong></li><li>特征：在争用资源的基础上进行工作</li></ol></li><li>特点<ol><li>分时：同一时刻只允许有一个部件向总线发送信息，如有多个部件，则分时地向总线发送信息。</li><li>共享：总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享，<strong>某一时刻只允许一个部件向总线发送信息</strong>，但<strong>多个部件可以同时从总线上接收相同信息</strong></li><li>总线设备<ol><li>主设备：获得<strong>总线控制权</strong>的设备 </li><li>从设备：被主设备访问的设备，只能响应从主设备发来的各种总线命令</li></ol></li><li>总线的分类<ol><li><strong>片内总线</strong>：CPU芯片内部的总线，在<strong>芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线</strong>。</li><li><strong>系统总线</strong>：<strong>计算机系统内各功能部件</strong>（CPU、主存、IO接口）之间相互连接的总线 按系统总线传输信息内容分为3类<ol><li>数据总线：双向，与机器字长、存储字长有关</li><li>地址总线：单向，与存储地址、I&#x2F;O地址有关</li><li>控制总线：每根线都是单向的，有出、有入</li></ol></li><li><strong>通信总线</strong>：用于<strong>计算机系统之间，或计算机系统与其他系统之间的通信</strong><ol><li>按时序控制方式，分为<strong>同步总线和异步总线</strong></li><li>按数据传输方式，分为<strong>并行总线和串行总线</strong></li></ol></li></ol></li></ol></li></ol><h4 id="总线：组成与特性"><a href="#总线：组成与特性" class="headerlink" title="总线：组成与特性"></a>总线：组成与特性</h4><ol><li><p>总线的内部结构：地址线、数据线、控制线组成，数据线常常和地址线采用分时复用方式</p><ol><li>仲裁总线：包括总线请求线和总线授权线。</li><li>中断和同步总线：用于处理带优先级的中断操作。</li><li>公用线：时钟信号线，电源线，地线，系统复位线。</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241349599.png" alt="image-20241124134917407"></p></li><li><p>总线特性</p><ol><li>物理特性：总线的物理连接方式</li><li>功能特性：每根线的功能</li><li>电气特性：每根线上信号的传递方向及有效电平范围 </li><li>时间特性：规定了每根总线在什么时间有效</li></ol></li></ol><h4 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h4><ol><li>总线的传输周期：指一次总线操作所需的时间（申请阶段、寻址阶段、传输阶段、结束阶段）总线传输周期通常由<strong>若干个总线时钟周期</strong>构成</li><li>总线时钟周期：机器的时钟周期</li><li><strong>总线的工作频率</strong>：总线周期&#x3D;N 个时钟周期，则总线的工作频率&#x3D;时钟频率&#x2F; N。</li><li>总线的时钟频率：机器的时钟频率</li><li><strong>总线宽度</strong>：又称为总线位宽，是指总线上同时能够传输的数据位数，通常是指数据总线的根数</li><li><strong>总线带宽</strong>：单位时间内总线上传输的最大字节数（MB&#x2F;s）。计算公式：总线带宽 &#x3D; 总线宽度 * 总线频率</li><li>总线复用：指一种信号线在不同时间传输不同的信息，可以使用较少的线传输更多的信息</li><li>信号线数：地址线、数据线和控制线的总和</li></ol><h4 id="总线的传输方式"><a href="#总线的传输方式" class="headerlink" title="总线的传输方式"></a>总线的传输方式</h4><ol><li><p>串行传送：使用一条传输线，采用脉冲传送</p><ol><li>主要优点：<ul><li>只需要一条传输线</li><li>对长距离传输特别重要</li><li>成本比较低廉</li></ul></li><li>缺点：速度慢</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241405955.png" alt="image-20241124140543760"></p></li><li><p>并行传送</p><ol><li>特点：同时传送多个数据位</li><li>系统总线上传送的信息必须采用并行传送方式（出于速度和效率上的考虑）</li></ol></li><li><p>分时传送：分时传送即总线的分时复用，共享总线的部件分时使用总线</p></li></ol><h4 id="总线接口"><a href="#总线接口" class="headerlink" title="总线接口"></a>总线接口</h4><p>接口是CPU和主存、外设之间通过总线进行连接的逻辑部件</p><p>接口的典型功能：<strong>控制、缓冲、转换、整理、程序中断</strong>等。</p><p>一个适配器（即接口）的两个接口：一个同系统总线相连，采用并行方式，另外</p><p>一个同设备相连，可能采用并行方式或是串行方式。</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241408550.png" alt="image-20241124140808869"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241409654.png" alt="image-20241124140954175"></p><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><ol><li><p>单总线结构</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241411187.png" alt="image-20241124141137769"></p><ol><li><p>CPU、主存、I&#x2F;O设备（通过I&#x2F;O接口）都挂在一组总线上</p><p>2.运行I&#x2F;O设备之间、I&#x2F;O设备与主存之间直接交换信息</p></li><li><p>直接通信能力：CPU与主存可直接进行信息交换，CPU与外设可直接进行信息交换，无需经过中间设备的干预。</p></li><li><p>优点：结构简单，成本低，易于接入新的设备</p></li><li><p>缺点：带宽低，负载重，多个部件只能争用唯一的总线，不支持并发传送操作</p></li><li><p>使用要求：连接到总线上的逻辑部件必须高速运行，需要使用总线时，能迅速获得总线控制权；而当不再使用总线时，能迅速放弃总线控制权。否则，由于一条总线由多种功能部件共用，可能导致很大的时间延迟。</p></li></ol></li></ol><p> 总线带宽&#x3D;(总线频率&#x2F;总线周期包含的时钟周期数)×(数据量&#x2F;总线周期)</p><h1 id="数据的表示与运算"><a href="#数据的表示与运算" class="headerlink" title="数据的表示与运算"></a>数据的表示与运算</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fbfd556035d1515cb69fb9497f34cbe6.png" alt="在这里插入图片描述"></p><h2 id="2-1-数制与编码"><a href="#2-1-数制与编码" class="headerlink" title="2.1 数制与编码"></a>2.1 数制与编码</h2><h3 id="2-1-1-进位计数制及其相互转化"><a href="#2-1-1-进位计数制及其相互转化" class="headerlink" title="2.1.1 进位计数制及其相互转化"></a>2.1.1 进位计数制及其相互转化</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5586a24cc9076b70895dc628ea9be86a.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/61ec3b0ee1a4f9fc13d97168eab59bcd.png" alt="在这里插入图片描述"></p><h4 id="2-1-2-BCD码（Binary-Code-Decimal码）"><a href="#2-1-2-BCD码（Binary-Code-Decimal码）" class="headerlink" title="2.1.2 BCD码（Binary-Code Decimal码）"></a>2.1.2 BCD码（Binary-Code Decimal码）</h4><p>每一个十进制数看成4位2进制数</p><p>8421 每一位代表权重</p><p>5421</p><p>2421</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e45a2f6305f8d3f8e66d0aa3a77d2d9.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e29dab138174435e7cee71aca4e0a668.png" alt="在这里插入图片描述"></p><h5 id="字符编码ASCII码"><a href="#字符编码ASCII码" class="headerlink" title="字符编码ASCII码"></a>字符编码ASCII码</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/49b74cc4a0c0cfd36da3c125f6dcc9ac.png" alt="在这里插入图片描述"></p><h3 id="2-1-5-校验码"><a href="#2-1-5-校验码" class="headerlink" title="2.1.5 校验码"></a>2.1.5 校验码</h3><p>任意两个码字之间最少变化的二进制位数称为<strong>码距</strong>，码距大于等于2的数据校验码开始具有检错的能力。码距越大，检错、纠错能力越强。奇偶校验码的码距等于2,可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能检测出偶数位错误；海明码的码距大于2,因此不仅可以发现错误，还能指出错误的位置。仅靠增加奇偶校验位的位数不能提高正确性，还要考虑码距。</p><p>具有检、纠错能力的数据校验码的实现原理：在编码中，除合法码字外，再加入一些非法码字，当某个合法码字出现错误时，就变为非法码字。合理安排非法码字的数量和编码规则就能达到纠错的目的。</p><h5 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h5><p>奇校验码 加上校验位 1的个数为奇数个</p><p>偶校验码加上校验位 1的个数为偶数个</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a970ee36dbd145e24b24ae7465936371.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ecdbffc1c4bc3b60fe4c6f4aa8d2e7d2.png" alt="在这里插入图片描述"></p><h3 id="2-海明（汉明）校验码"><a href="#2-海明（汉明）校验码" class="headerlink" title="2.海明（汉明）校验码"></a>2.海明（汉明）校验码</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ef82d56a4c9123c1ac62b4960087b3d7.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c261e94fd65b5e3f3a031df84dca8759.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/23f22c043b055368a835173b17bab7c2.png" alt="在这里插入图片描述"></p><p>​<img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221040495.png" alt="image-20241122104000839"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221040873.png" alt="image-20241122104048405"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bbf970905e8ede6037ca72b5f87057f6.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd84a82040f97c80c743bc10bbbb46c0.png" alt="在这里插入图片描述"></p><h3 id="3-循环冗余校验（CRC）码"><a href="#3-循环冗余校验（CRC）码" class="headerlink" title="3. 循环冗余校验（CRC）码"></a>3. 循环冗余校验（CRC）码</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/249fbfb07d9f25b2bc8e40b54a57f41b.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/34535ed57e695cee662b0f6b33f8443f.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e79227259e72d22c83804c3b8f836e6e.png" alt="在这里插入图片描述"></p><p>这里可以进行异或运算</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1d91dfb26bed6bbac415fbb90f0ed223.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ede6ae9725ae977d507bee0a6bfc6763.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e9b7a972b8da33d2fcfa1b66226eaf1.png" alt="在这里插入图片描述"></p><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>1.无符号数和有符号数<br>计算机中参与运算的有两大类，<strong>有符号数和无符号数</strong><br>无符号数：机器字长全部二进制位均为数值位，没有符号位。<img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221138060.png" alt="image-20241122113841651"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221139350.png" alt="image-20241122113904133"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221141885.png" alt="image-20241122114151170">有符号数：</p><p>机器数：保存在计算机当中（原码表示法）</p><p>真值：带有正负号 0正1负 </p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221250451.png" alt="image-20241122124949269"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221254592.png" alt="image-20241122125419570"><br>$$<br>2^4 &#x3D; 10000<br>$$</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221406362.png" alt="image-20241122140626126"></p><p>补码：解决加减法归一化问题把减法转换成加法</p><p>正数：原码&#x3D;反码&#x3D;补码</p><p>负数  反码&#x3D;原码符号为不变，其余位取反，补码 &#x3D; 反码+1</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221419814.png" alt="image-20241122141924369"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221424665.png" alt="image-20241122142432006"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221435983.png" alt="image-20241122143524432"></p><h5 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h5><p>补码表示很难直接判断其真值大小</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221439906.png" alt="image-20241122143942325"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221442870.png" alt="image-20241122144209847"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221444032.png" alt="image-20241122144427209"></p><h3 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h3><h4 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h4><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221449852.png" alt="image-20241122144925594"></p><h4 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h4><ul><li>为什么要引入浮点数表示<ul><li>编程困难，程序员要调节小数点的位置；</li><li>数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长；</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221451336.png" alt="image-20241122145130956"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221453337.png" alt="image-20241122145327344"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221456126.png" alt="image-20241122145629928"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221459156.png" alt="image-20241122145914061"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221506255.png" alt="image-20241122150611964"></p><h3 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h3><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221510086.png" alt="image-20241122151003646"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221511254.png" alt="image-20241122151151182"></p><h3 id="算法移位"><a href="#算法移位" class="headerlink" title="算法移位"></a>算法移位</h3><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221522353.png" alt="image-20241122152228956"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221523789.png" alt="image-20241122152306490"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221524389.png" alt="image-20241122152435292"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221525063.png" alt="image-20241122152524774"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221526890.png" alt="image-20241122152605732"></p><p>溢出判断</p><p><img src="/../images/image-20241122152748295.png" alt="image-20241122152748295"></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h4 id="在计算机中，为什么要采用二进制来表示数据？"><a href="#在计算机中，为什么要采用二进制来表示数据？" class="headerlink" title="在计算机中，为什么要采用二进制来表示数据？"></a>在计算机中，为什么要采用二进制来表示数据？</h4><ul><li><p>1)在计算机中，为什么要采用二进制来表示数据？</p><p>从可行性来说，采用二进制，只有0和1两个状态，能够表示0、1两种状态的电子器件很多，如开关的接通和断开、晶体管的导通和截止、磁元件的正负剩磁、电位电平的高与低等，都可表示0、1两个数码。使用二进制，电子器件具有实现的可行性。<br>从运算的简易性来说，二进制数的运算法则少，运算简单，使计算机运算器的硬件结构大大简化(十进制的乘法九九口诀表有55条公式，而二进制乘法只有4条规则)从逻辑上来说，由于二进制0和1正好和逻辑代数的假( false)和真(true)相对应，有逻辑代数的理论基础，用二进制表示二值逻辑很自然。</p></li></ul><h4 id="2-计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。"><a href="#2-计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。" class="headerlink" title="2)计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。"></a>2)计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。</h4><ul><li><p>2)计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。</p><p>计算机采用二进制来表示数据，在字长足够时，可以表示任何一个整数。而二进制表示小数时只能够用1(2)的和的任意组合表示，即使字长很长，也不可能精确表示出所有小数，只能无限逼近。例如0.1就无法用二进制精确地表示。</p></li></ul><h4 id="3-字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？"><a href="#3-字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？" class="headerlink" title="3)字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？"></a>3)字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？</h4><ul><li><p>3)字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？</p><p>字长相同时，浮点数取字长的一部分作为阶码，所以表示范围比定点数要大，而取一部分作为阶码也就代表着尾数部位的有效位数减少，而定点数字长的全部位都用来表示数值本身，精度要比同字长的浮点数更大。</p></li></ul><h4 id="4-用移码表示浮点数的阶码有什么好处？"><a href="#4-用移码表示浮点数的阶码有什么好处？" class="headerlink" title="4)用移码表示浮点数的阶码有什么好处？"></a>4)用移码表示浮点数的阶码有什么好处？</h4><ul><li><p>4)用移码表示浮点数的阶码有什么好处？</p><p>移码的两个好处<br>①浮点数进行加减运算时，时常要比较阶码的大小，相对于原码和补码，移码比较大小更方便。<br>②检验移码的特殊值(0和max)时比较容易。阶码以移码编码时的特殊值如下。<strong>0</strong>:表示指数为负无穷大，相当于分数分母无穷大，整个数无穷接近0,在尾数也为0时可用来表示0:尾数不为零表示未正规化的数。<strong>max</strong>:表示指数正无穷大，若尾数为0,则表示浮点数超出表示范围（正负无穷大）；尾数不为0,则表示浮点数运算错误</p></li></ul><h4 id="在高级语言编程中所定义的-unsigned-short-int-long-float-double型数据是怎么表示的？什么称为无符号整数的“溢出”？"><a href="#在高级语言编程中所定义的-unsigned-short-int-long-float-double型数据是怎么表示的？什么称为无符号整数的“溢出”？" class="headerlink" title=".在高级语言编程中所定义的 unsigned&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double型数据是怎么表示的？什么称为无符号整数的“溢出”？"></a>.在高级语言编程中所定义的 unsigned&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double型数据是怎么表示的？什么称为无符号整数的“溢出”？</h4><ul><li><p>2.在高级语言编程中所定义的 unsigned&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double型数据是怎么表示的？什么称为无符号整数的“溢出”？</p><p>unsigned型数据就是无符号整数，不考虑符号位。直接用全部二进制位对数值进行编码得到的就是无符号数，一般都用补码表示。</p><p>int型数据就是定点整数，一般用补码表示。int型数据的位数与运行平台和编译器有关，一般是32位或16位。例如，真值是-12的int型整数，在机器内存储的机器数（假定用32位寄存器寄存）是1111-1111-1111-1111-1111-1111-1111-0100.</p><p>long型数据和short型数据也都是定点整数，只是位数不同，分别是长整型和短整型数，通常用补码表示。</p><p>float型数据是用来表示实数的浮点数。现代计算机用IEEE754标准表示浮点数，其中32位单精度浮点数就是float型，64位双精度浮点数就是 double型。</p><p>需要注意的是，C语言中的int型和 unsigned型变量的存储方式没有区别，都按照补码的形式存储，在不溢出范围内的加减法运算也是相同的，只是int型变量的最高位代表符号位，而unsigned型中的最高位表示数值位，两者在C语言中的区别体现在输出时到底是采用%d还是采用%u。</p><p>对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低n位，舍弃高位。这样，会产生以下两种结果。<br>①保留的低n位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第n+1位，称此时发生了“溢出”现象<br>②保留的低n位数能正确表达计算结果，即高位的舍去并不影响其运算结果。</p></li></ul><h4 id="对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？"><a href="#对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？" class="headerlink" title="对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？"></a>对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？</h4><ul><li><p>4.对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？</p><p>不是，可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数就是一定的。m位编码只能表示2m个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多(有时可能由于一个值有两个或多个编码对应，编码个数会有少量差异)。</p></li></ul><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/66b98e81fc90bfc3506c9467633e2ee8.png" alt="在这里插入图片描述"></p><h2 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h2><h4 id="3-1-1-存储器的分类"><a href="#3-1-1-存储器的分类" class="headerlink" title="3.1.1 存储器的分类"></a>3.1.1 存储器的分类</h4><p>相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项）去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。所以它是 按内容或地址进行寻址的，价格较为昂贵。 一般用<strong>来制作TLB、相联 Cache</strong>等。</p><p>按在计算机中的作用对存储器分类：</p><ul><li>主存储器,简称主存。CPU可以直接随机地对其进行访问，也可以和高速缓存器及辅助存储器交换数据。</li><li>辅助存储器,简称辅存，不能与CPU直接相连，用来存放当前暂时不用的程序和数据</li><li>高速缓冲存储器,位于主存和CPU之间，用来存放正在执行的程序段和数据</li></ul><p>按存储介质分类：</p><ul><li>磁表面存储器（磁盘，磁带），磁心存储器半导体存储器（MOS型存储器，双极存储器）和光存储器（光盘）。</li></ul><p>按存取方式分类：</p><ul><li>随机存储器（RAM）。存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存取单元的物理位置无关，主要用作主存或高速缓冲存储器。</li><li>只读存储器（ROM）。存储器的内容只能随机读出而不能写入。。即使断电，内容也不会丢失。</li><li>串行访问存储器。对存储单元进行读&#x2F;写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如<strong>磁带</strong>）与直接存取存储器（如<strong>磁盘</strong>）。</li></ul><p>按信息的可保存性分类：</p><p>断电后，存储信息即消失的存储器，称为<strong>易失性存储</strong>器，如RAM。断电后信息仍然保持的存储器，称为<strong>非易失性存储器</strong>，如ROM，磁表面存储器和光存储器。<strong>若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出；若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。</strong>具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0ad326410974404693b1611fa29a8899.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b69d4cba3caa693102dcbd1ceaa46b2b.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f543b20ba92e2b0f7b36027241668f37.png" alt="在这里插入图片描述"></p><h4 id="3-1-2-存储器的性能指标"><a href="#3-1-2-存储器的性能指标" class="headerlink" title="3.1.2 存储器的性能指标"></a>3.1.2 存储器的性能指标</h4><ol><li>存储容量：存储字数*字长</li><li>单位成本：每位价格&#x3D;总成本&#x2F;总容量</li><li>存储速度：数据传输率&#x3D;数据的宽度&#x2F;存储周期</li></ol><h3 id="3-2-存储器的层次结构"><a href="#3-2-存储器的层次结构" class="headerlink" title="3.2 存储器的层次结构"></a>3.2 存储器的层次结构</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d679ff8ea252bd55dc150e7192e63007.png" alt="在这里插入图片描述"></p><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c0da5ba7f02869ddb4946d76a475bbd1.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ba662c9ed01b6ed33ccaafaf9cceb1af.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/01a402cd59466ba8d78a84dc85e7b3c9.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/75311fdb93ed457c1a4d815dedc0d0a7.png" alt="在这里插入图片描述"></p><h3 id="3-3-半导体随机存储器"><a href="#3-3-半导体随机存储器" class="headerlink" title="3.3 半导体随机存储器"></a>3.3 半导体随机存储器</h3><h4 id="3-3-1-SRAM和DRAM"><a href="#3-3-1-SRAM和DRAM" class="headerlink" title="3.3.1 SRAM和DRAM"></a>3.3.1 SRAM和DRAM</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e5460ab4f1bfd43e2553d29986523916.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bafd8beffd2da2f327ae25594d8bce54.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0952215dccce3a125a3d23f46d66ba12.png" alt="在这里插入图片描述"></p><p>译码码驱动：线选法，重合法</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a94e96d6fbd602f22ce5009b593b4159.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8196643f948aba6fbcb84d2096abd038.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b80ae8ca6e1989312e1b56d9babc9574.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/67d9a67b5fb662c9539d9d98b61c46ee.png" alt="在这里插入图片描述"></p><h4 id="3-3-2-只读存储器"><a href="#3-3-2-只读存储器" class="headerlink" title="3.3.2 只读存储器"></a>3.3.2 只读存储器</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/64d34d40cce418724674050e12f718f1.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b441dc3a74080edd97b6c3d929ecdc64.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b441dc3a74080edd97b6c3d929ecdc64.png" alt="在这里插入图片描述"></p><h3 id="3-4-主存储器与CPU的连接"><a href="#3-4-主存储器与CPU的连接" class="headerlink" title="3.4 主存储器与CPU的连接"></a>3.4 主存储器与CPU的连接</h3><h4 id="3-4-2-主存容量的扩展"><a href="#3-4-2-主存容量的扩展" class="headerlink" title="3.4.2 主存容量的扩展"></a>3.4.2 主存容量的扩展</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/27cc715d7f1edaef7eefe834728a9f91.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fe0e728489330c379894f4c1846d7818.png" alt="在这里插入图片描述"></p><h5 id="2-字扩展"><a href="#2-字扩展" class="headerlink" title="2.字扩展"></a>2.字扩展</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ff121420aaeef4bb67dd9faa3e88c43.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c6c2896bdadcb8b76a967953713f894.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/84817bb7cbb74e127e7658b66fc7ef8b.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1cf638a2a58f440c4c8916bddd317c8.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3d5e06ae818437e8c5d219eb22d63846.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6303cfeb16aee98b1f0356c9ba859846.png" alt="在这里插入图片描述"></p><h3 id="3-5-双端口RAM和多模块存储器"><a href="#3-5-双端口RAM和多模块存储器" class="headerlink" title="3.5 双端口RAM和多模块存储器"></a>3.5 双端口RAM和多模块存储器</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca200997a2c7b8316e60fa50e2348b5.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4b2bdf4b79975daefb6e0d3cf924a74e.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/692ea89e2fb1b8835b8814fd58d1bf86.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a4841cc3dfbb384cb7837adea1b56c6.png" alt="在这里插入图片描述"></p><h4 id="3-6-1-程序访问的局部性原理"><a href="#3-6-1-程序访问的局部性原理" class="headerlink" title="3.6.1 程序访问的局部性原理"></a>3.6.1 程序访问的局部性原理</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e832742d19e68be59b1e8cd21538c604.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b0118ba3bf0e00d9127d520f3bb7b4a7.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f6b83fb5fb8220f48d3285d78b8d5956.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f04787838a813b4eb48d401c242240cd.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f043f952cca03789fb4384d347038a03.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/806fcd43467a1e23af7492d6828b5a52.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f5bb151f88c68bf3e3f1615881ae6efa.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a5cd63d9f8053955cfa333d16b63f5d7.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b9eda1e34499c1a9a237fceae2f00365.png" alt="在这里插入图片描述"></p><p>SCI总线—-SCI（serial communication interface）由Motorola公司推出。是一种通用异步通信接口UART，与MCS-51的异步通信功能基本相同。</p><p> PCI总线—-PCI（peripheral component interconnect）<strong>总线是当前最流行的总线之一，</strong>它是由Intel公司推出的一种局部总线。它定义了32位数据总线，且可扩展为64位。是基于奔腾等新一代微处理器而发展的总线。</p><p> ISA总线—-ISA（industrial standard architecture）<strong>总线标准是IBM 公司1984年为推出PC&#x2F;AT机而建立的系统总线标准</strong>，所以也叫AT总线。它是对XT总线的扩展，以适应8&#x2F;16位数据总线要求。它在80286至80486时代应用非常广泛，以至于奔腾机中还保留有ISA总线插槽。ISA总线有98只引脚。 </p><p>VESA总线—-VESA（video electronics standard association）<strong>总线是 1992年由60家附件卡制造商联合推出的一种局部总线，简称为VL(VESA local bus)总线</strong>。它的推出为微机系统总线体系结构的革新奠定了基础。</p><p>程序执行的效率与数据的存储结构、数据的逻辑结构、程序的控制结构、所处理的数据量等有关</p><p>高级程序语言结构丰富、可读性好、可维护性强、可靠性高、易学易掌握、写出来的程序可移植性好，重用率高，但是执行效率低</p><p>用高级语言编写的程序在计算机中运行时，首先被编译成目标程序，然后再解释成能被计算机运行的机器指令代码，再由计算机具体执行。其代码对应的改变是从源程序变到目标程序，再到机器指令代码。</p><p>DS段寄存器不允许直接赋值</p><p>MOV指令使用立即寻址方式，立即数是保存在代码段中</p><p>AX 寄存器称为累加器，常用于存放算术、逻辑运算中的操作数或结果。另外，所有的I&#x2F;O指令都要使用累加器与外设接口传递数据。  </p><p>BX 寄存器称为基址寄存器，常用来存放访问内存时的地址。 </p><p>CX 寄存器称为计数寄存器，在循环、串操作指令中用作计数器。 </p><p>DX 寄存器称为数据寄存器，在寄存器间接寻址中的I&#x2F;O指令中存放I&#x2F;O端口的地址。 </p><p>  此外，在做双字长乘除法运算时，DX 与AX合起来存放一个双字长数(32位)，其中DX存放高16位，AX存放低16位</p><p>DRAM 芯片的地址线，在芯片中，是分时复用的，仅需一半的引脚数，即够用。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通道是一种通过执行通道程序管理I/O操作的控制器，它使主机（CPU和内存）与I/O操作之间达到更高的并行程度。由于它的任务是管理实现输入/输出操</span><br><span class="line">作，提供一种传送通道，所以将这种部件称作“通道”。CPU把数据传输功能下放给通道，这样，通道与CPU分时使用内存，就可以实现CPU与外设的并行工</span><br><span class="line">作。在采用通道方式的指令系统中，除了供CPU编程使用的机器指令系统外，还设置另外供通道专用的一组通道指令，用通道指令编制通道程序，存入存储器。当</span><br><span class="line">需要进行I/O操作时，CPU只需启动通道，然后可以继续执行自身程序，通道则执行通道程序，管理与实现I/O操作。整个系统分为二级管理，一级是CPU</span><br><span class="line">对通道的管理，二级是通道对设备控制的管理。 </span><br><span class="line"></span><br><span class="line">通道就是可以通数据的</span><br><span class="line">CPU发出一条通道命令，然后由通道和外设交换数据，之后CPU就做其它的事情，通道和外设交换完数据后再向CPU汇报，CPU再处理</span><br></pre></td></tr></table></figure><p>  ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。<br> 标准ASCII  码也叫基础ASCII码，使用7 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符</p><p> 完整的ZigBee 协议栈自上而下由应用层、应用汇聚层、网络层、数据链路层和物理层组成。 </p><p>  以下为各层在Zigbee结构中的作用： </p><p>  物理层：作为Zigbee协议结构的最低层，提供了最基础的服务，为上一层MAC层提供了服务，如数据的接口等等。同时也起到了与现实 (物理) 世界交互的作用； </p><p>  MAC层：负责不同设备之间无线数据链路的建立，维护，结束，确认的数据传送和接收； </p><p>  网络&#x2F;安全层：保证了数据的传输和完整性，同时可对数据进行加密；  </p><p>  应用&#x2F;支持层：根据设计目的和需求使多个器件之间进行通信；</p><p>汇编语言是符号化了的二进制代码，与高级语言相比，更容易有效执行；与机器语言相比，可移植性较好，但是没有机器语言的执行效率高。</p><p> 为什么要制定总线标准? </p><p> 便于机器的扩充和新设备的添加，有了总线标准，不同厂商可以按照同样的标准和规范生产各种不同功能的芯片、模块和整机，用户可以根据功能需求去选择不同厂家生产的、基于同种总线标准的模块和设备，甚至可以按照标准，自行设计功能特殊的专用模块和设备，以组成自己所需的应用系统。这样可使芯片级、模块级、设备级等各级别的产品都具有兼容性和互换性，以使整个计算机系统的可维护性和可扩充性得到充分保证。</p><p> 实际流水中会出现三种相关也就是使流水线很难充分实现的三个冲突：资源相关、数据相关、控制相关 </p><p>  资源相关：指当指令在重叠执行过程中，不同指令争用同一功能部件产生资源冲突时产生的 </p><p>  数据相关：指令在流水线中重叠执行时，当后继指令需要用到前面的指令产生的结果时发生的 </p><p>  控制相关：当流水线遇到转移指令引起的。统计表明，转移指令约占总指令的四分之一左右，比起数据相关，它会使流水线丧失更多的功能 </p><p>  数据相关：写后读相关，读后写相关，写后写相关</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><ol><li>计算机网络的基本概念从三个角度定义：</li></ol><ul><li>应用角度：强调资源共享和独立功能</li><li>物理角度：强调网络协议和硬件设备的组成</li><li>功能角度：强调通信手段和互联互通能力</li></ul><p>计算机网络是分布在不同地理位置的多个独立的自治计算机的集合。   </p><p>计算机网络的的功能:<br> 数据通信: 实现计算机之间的数据传输,将不同地理位置的计算机连接起来进行统一管理。<br> 资源共享: 资源共享可以是软件共享、数据共享和硬件共享、是各计算机分工协作,提高资源利用率。<br> 分布式处理: 当某一计算机负载过重时,将任务分配给其他计算机<br> 提高可靠性: 各台计算机可以互为替代机<br> 负载均衡: 将任务均衡分配给计算机</p><ol start="2"><li><p>计算机网络的发展经历了三个阶段：</p><ul><li><p>以主机为中心的终端系统</p></li><li><p>以通信子网为中心的计算机互连</p></li><li><p>标准化的网络体系结构</p></li></ul></li></ol><h3 id="计算机网络的术语包括："><a href="#计算机网络的术语包括：" class="headerlink" title="计算机网络的术语包括："></a>计算机网络的术语包括：</h3><ul><li>通信子网：传输网络，提供信息传输服务。</li><li>资源子网：主机集合，提供计算资源</li><li>边缘部分：由<strong>所有连接在因特网上的主机</strong>组成。这部分用户直接使用，用来进行通信（传送数据、音频或视频）和资源共享</li><li>核心部分：由<strong>大量网络和连接这些网络的路由器</strong>组成。这部分为边缘部分提供服务（提供连通性和交换）</li></ul><ol start="4"><li>结点、网络、主机</li></ol><ul><li>网络：由若干结点和连接这些结点的链路组成</li><li>互联网：互联网是”网络的网络”</li><li>主机：连接在网上的计算机都称为主机</li></ul><p>物理层：</p><p>​中继器：中继器（RP repeater）是工作在物理层上的连接设备。适用于<strong>完全相同的两类网络的互连</strong>，主要功能是通过对数据信号的重新发送或者转发，来扩大网络传输的距离。</p><p>​集线器，</p><p>​网卡网线</p><p>​调制解调器，  </p><p>数据链路层：</p><p>​网桥：网桥能够互连两个采用不同数据链路层协议、不同传输介质与不同传输速率的网络</p><p>​二层交换机</p><p>​网卡  </p><p>网络层：路由器，三层交换机  </p><p>传输层：四层交换机</p><p> 脉码调制是对  <a href="http://baike.so.com/doc/4104719-4303763.html">模拟信号</a>  进行处理、量化、编码后转换为数字信号的一种调制方式。</p><p>  调制的目的是把要传输的  <a href="http://baike.so.com/doc/4104719.html">模拟信号</a>  或  <a href="http://baike.so.com/doc/32748.html">数字信号</a>  变换成适合信道传输的信号，解调为调制的反过程</p><h3 id="计算机网络主要由三大组成部分：硬件、软件、协议"><a href="#计算机网络主要由三大组成部分：硬件、软件、协议" class="headerlink" title="计算机网络主要由三大组成部分：硬件、软件、协议"></a>计算机网络主要由三大组成部分：硬件、软件、协议</h3><ol><li>硬件<ul><li>网络节点：包括端节点（计算机）和中间节点（交换机、集中器、复用器、路由器、中继器）</li><li>通信链路：信息传输的通道，包括物理链路（传输介质）、逻辑链路（信道）</li></ul></li><li>软件<ul><li>包括各种实现<strong>资源共享</strong>的软件、为用户使用的各种工具软件</li><li>主要有<strong>通信软件</strong>（网络协议软件）、<strong>网络操作系统</strong>、网络管理&#x2F;安全控制软件、网络应用软件</li></ul></li><li>协议<ul><li>是<strong>计算机网络的核心</strong></li><li>协议规定了网络<strong>传输数据时所遵循的规则</strong></li></ul></li></ol><h3 id="计算机网络：功能"><a href="#计算机网络：功能" class="headerlink" title="计算机网络：功能"></a>计算机网络：功能</h3><ol><li><strong>数据通信</strong><ul><li>是计算机网络<strong>最基本和最重要的功能</strong></li><li>用来实现联网计算机之间的各种信息传输</li><li>实现将分散在不同地理位置的计算机联系起来</li><li><strong>进行统一的调配</strong>、控制和管理</li><li>应用示例：文件传输、IP电话、email、视频会议、信息发布、交互式媒体、音乐</li></ul></li><li>资源共享<ul><li>包括软件共享、硬件共享、数据共享</li><li>使计算机网络中的资源互通有无、分工协作</li><li>从而极大地提高硬件资源、软件资源和数据资源的利用率</li></ul></li><li>提供高可靠性服务<ul><li>利用可替代的资源，提供连续的高可靠服务</li></ul></li><li>节省资金<ul><li>替代昂贵的大中型机系统</li></ul></li><li>分布式处理<ul><li>当计算机网络中的某个计算机系统负荷过重时</li><li>可以将其处理的某个复杂任务分配给网络中其他计算机系统</li><li>从而利用空闲计算机资源以提高整个系统的利用率</li></ul></li><li>其它功能<ul><li>实现电子化办公与服务</li><li>远程教育</li><li>娱乐等功能</li><li>满足了社会的需求，方便了人们学习、工作和生活</li><li>具有巨大的经济效益</li></ul></li><li></li></ol><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><h3 id="按地理范围划分"><a href="#按地理范围划分" class="headerlink" title="按地理范围划分"></a>按地理范围划分</h3><ol><li><p>广域网(WAN)</p><ul><li><p>范围：大、大于100KM</p></li><li><p>传输技术：宽带</p></li><li><p>通信质量：延迟大，出错率高</p></li><li><p>拓扑结构：不规则，<strong>点到点</strong>类型</p></li><li><p>是<strong>互联网的核心部分</strong>，任务是通过长距离运送主机所发送的数据</p></li></ul></li><li><p>城域网(MAN)</p><ul><li><p>范围：中等、小于100KM，<strong>一般是一个城市</strong>，可跨越几个街区甚至整个城市</p></li><li><p>传输技术：宽带、基带</p></li><li><p>拓扑结构：<strong>总线类型</strong></p></li></ul></li><li><p>局域网(LAN)</p><ul><li><p>范围：小、小于20KM</p></li><li><p>传输技术：基带，10-1000Mbps</p></li><li><p>通信质量：延迟低，出错率低（最低可达10⁻¹¹）</p></li><li><p><strong>拓扑结构：总线、环</strong></p></li><li><p>一般用微型计算机或工作站通过高速通信线路相连，地理上局限在较小的范围</p></li></ul></li><li><p>个域网(PAN)</p><ul><li><p>在个人工作的地方范围内的电子设备用无线技术连接起来，也称为<strong>无线个人区域网</strong>(WPAN)</p></li><li><p>范围很小，大约在10m左右</p></li><li><p>是一个<strong>低功率、小范围、低速率、低价格</strong>的电缆替代技术</p></li></ul></li></ol><h3 id="按通信传播方式划分"><a href="#按通信传播方式划分" class="headerlink" title="按通信传播方式划分"></a>按通信传播方式划分</h3><ol><li>点对点传输方式的网络<ol><li>每条物理线路连接一对计算机，由一对对机器间的多条传输线路构成</li><li>如果通信的两台主机之间没有直接连接的线路，那他们之间的分组传输就要通过中间节点的接收、存储和转发，直到目的节点。</li><li>拓扑结构为网状、环形、树形、星形等</li></ol></li><li>广播方式网络<ol><li>一台计算机发送的信息可被网络上所有的计算机接收</li><li>拓扑结构为总线形</li></ol></li></ol><h3 id="按拓扑结构划分"><a href="#按拓扑结构划分" class="headerlink" title="按拓扑结构划分"></a>按拓扑结构划分</h3><ol><li>星形结构<ol><li>网络有一个中心节点，其它节点与其构成点到点连接</li><li>特点：容易实现：传输介质一般都是采用双绞线，节点扩展、移动方便：扩展只需从集线器或交换机等集中设备中拔除一条线即可，维护容易：一个节点出现故障不会影响其它节点的连接，可任意拆走故障节点。网络传输数据快：例如1000Mbps、甚至10G以太网。</li></ol></li><li>树形结构<ol><li>网络由一个根结点、多个中间分支节点和叶子节点构成</li><li>信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换</li><li>特点：连结简单，维护方便，适用于汇集信息的应用要求。资源共享能力较低，可靠性不高，任何一个工作站或链路的故障都会影响整个网络的运行</li></ol></li><li>总线结构<ol><li>网络所有节点挂接到一条总线上，各节点共用总线带宽，采用广播式信道，需要有介质访问控制规程以防止冲突。</li><li>特点：组网费用低：不需要另外的互联设备，直接通过一条总线进行连接，扩展较灵活：需要扩展用户时只需要添加一个接线器即可，但所能连接的用户数量有限，维护容易：单个节点失效不影响整个网络的正常通信，但是如果总线一断，则整个网络或者相应主干网段就断了，一次仅能一个端用户发送数据，其他端用户必须等待到获得发送权。</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241048890.png" alt="image-20241124104823398"></p><ol start="4"><li><p>环形结构</p><ol><li>所有节点连接成一个闭合的环，<strong>结点之间为点到点连接</strong></li><li>一般仅适用于令牌网，<strong>传输介质一般是同轴电缆</strong></li><li>实现简单，投资小，功能简单，仅能当作一般的文件服务模式</li><li>环中数据只能单向传输，信息在每台设备上的延迟时间是固定的，特别适合实时控制的局域网系统</li><li>维护困难，扩展性能差：添加或移动节点时必须中断整个网络，在环的两端作好连接器才能连接</li></ol></li><li><p>全连接结构：<strong>点到点全连接</strong>，可靠性最高，建造成本也高，只适用于节点数很少的广域网中。</p></li><li><p>网状结构</p><ol><li>点到点部分连接</li><li>多用于广域网，由于连接的不完全性，需要有交换节点</li><li>系统可靠性高，比较容易扩展</li><li>结构复杂，每一结点都与多点进行连结</li><li>因此必须采用路由算法和流量控制方法</li><li>目前<strong>广域网基本上采用网状结构</strong></li></ol><p><strong>早期以太网采用的拓扑结构基本是总线型</strong>。总线型所需的电缆较少、价格便宜、管理成本高，不易隔离故障点、采用共享的访问机制，易造成网络拥塞。早期以太网多使用总线型的拓扑结构，采用同轴缆作为传输介质，连接简单，通常在小规模的网络中不需要专用的网络设备，但由于它存在的固有缺陷，已经逐渐被<strong>以集线器和交换机为核心的星型网络所代替</strong>。</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241053576.png" alt="image-20241124105305001"></p><p><img src="https://uploadfiles.nowcoder.com/images/20170910/9991577_1505029031971_BF7DF5BFE3A36B3AD457E86AEC1026E0" alt="img"></p><p><img src="https://uploadfiles.nowcoder.com/images/20210529/999940255_1622270248407/844416D21E3F1287A00DBFD03FDE71A8" alt="img"></p></li></ol><h1 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h1><h3 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h3><p>环形网络常用的访问控制方法是基于令牌的访问控制，是一种分布式访问控制技术。</p><p>典型的环形网络有 Token-Ring 和 FDDI 等</p><p>FDDI（光纤分布数据接口）的基本结构为逆向双环，。一个环为主环，另一个环为备用环。当主环上的设备失效或光缆发生故障时,通过从主环向备用环的切换可继续维持FDDI的正常工作。这种故障容错能力是其它网络所没有的。</p><ol><li><p>分层</p><ol><li>结构清晰，简化设计与实现，便于更新与维护</li><li>使独立性和适应性增强，每层通过自己内部的功能实现一种特定的服务，并且只依赖自己的下层提供的服务</li></ol></li><li><p>分层原则</p><ol><li>各个层之间有清晰的边界，便于理解</li><li>每个层实现特定的功能，功能尽可能独立。当某一层具体实现方法更新时，只要保持上下层的接口不变，便不会对相邻层产生影响</li><li>层次的划分有利于国际标准协议的制定</li><li>层的数目应该适中：层数太少，每层协议太复杂，层数太多，则体系结构太复杂。</li></ol></li><li><p>计算机网络体系结构</p><ol><li>计算机网络中，<strong>层、协议和层间接口的集合被称为计算机网络体系结构</strong></li><li>分层结构与每层的功能</li><li>服务与层间接口</li><li>协议</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241059255.png" alt="image-20241124105938454"></p></li></ol><h3 id="协议、接口、服务"><a href="#协议、接口、服务" class="headerlink" title="协议、接口、服务"></a>协议、接口、服务</h3><ol><li>实体(Entity)<ol><li>定义：<strong>任何可以发送或接收信息的硬件或软件进程</strong>。这可以是具体的硬件设备，也可以是软件程序</li></ol></li><li>对等层(Peer Layer)<ol><li>两个不同系统的同级层次</li></ol></li><li>对等实体(Peer Entity)<ol><li>分别位于<strong>不同系统对等层中的两个实体</strong></li><li>对等实体之间可以进行通信和信息交换</li></ol></li><li>接口：相邻两层之间交互的界面，定义<strong>相邻两层之间的操作及下层对上层的服务</strong>。</li><li>服务：<strong>某一层及其以下各层的一种能力</strong>，通过<strong>接口提供给其相邻上层</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241101573.png" alt="image-20241124110152941"></p><h4 id="协议的三个要素"><a href="#协议的三个要素" class="headerlink" title="协议的三个要素"></a>协议的三个要素</h4><ol><li>语义：解释控制信息<strong>每个部分的意义</strong>，规定了需要发出<strong>何种控制信息</strong>以及完成的动作与响应</li><li>语法：是用户数据与控制信息的<strong>结构与格式</strong></li><li><strong>时序</strong>：是对事件发生顺序的详细说明（也可称为”<strong>同步</strong>“）</li></ol><h3 id="协议数据单元"><a href="#协议数据单元" class="headerlink" title="协议数据单元"></a>协议数据单元</h3><ol><li>概念:网络体系结构中，<strong><em>对等层</em>之间交换的信息报文</strong>统称为协议数据单元（PDU）</li><li>组成:PDU由<strong>协议控制信息</strong>（协议头）和<em><strong>数据</strong></em>（SDU）组成</li><li>协议控制信息:地址,序号,长度,分段标志,差错控制信息等.</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241106401.png" alt="image-20241124110621993"></p><ol start="4"><li>各层协议数据单元的名称<ol><li>传输层以上：报文（Message）</li><li>传输层：段（Segment）</li><li>网络层：分组或包（Packet）</li><li>数据链路层：帧（Frame）</li><li>物理层：比特（Bit）</li></ol></li></ol><h3 id="协议数据传送过程"><a href="#协议数据传送过程" class="headerlink" title="协议数据传送过程"></a>协议数据传送过程</h3><ol><li><p>PDU的封装过程</p><ol><li>下层把上层的PDU作为本层的数据(SDU)加以封装</li><li>然后加入本层的协议头部（和尾部）</li><li>形成本层的PDU</li></ol></li><li><p>数据的封装与拆封过程</p><ol><li>数据在源站<strong>自上而下递交的过程实际上就是不断封装的过程</strong></li><li>到达目的地后<strong>自下而上递交的过程就是不断拆封的过程</strong></li></ol></li><li><p>每一层只处理本层的协议头部</p></li><li><p>通信过程的关键特点</p><ol><li><strong>通信只在对等层间进行</strong>，非对等层之间不能互相”通信”</li><li>对等层实体之间实现的是<strong>虚拟的逻辑通信</strong>（间接的、逻辑的、虚拟的）</li><li><em><strong>下层向上层提供服务</strong></em></li><li><em><strong>上层依赖下层提供的服务</strong></em>来与其它主机上的对等层通信</li><li>实际通信在最底层完成</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241113585.png" alt="image-20241124111309361"></p></li></ol><h3 id="两种体系结构"><a href="#两种体系结构" class="headerlink" title="两种体系结构"></a>两种体系结构</h3><h4 id="ISO-OSI标准体系结构"><a href="#ISO-OSI标准体系结构" class="headerlink" title="ISO&#x2F;OSI标准体系结构"></a>ISO&#x2F;OSI标准体系结构</h4><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241115239.png" alt="image-20241124111458942"></p><ol><li><p>物理层</p><ol><li><p>在物理媒体上正确地、透明地传送比特流</p></li><li><p>主要定义两种设备：</p><ol><li>数据终端设备(DTE)</li><li>数据通信设备(DCE)的物理和逻辑连接方法</li></ol></li><li><p>机械特性，电气特性，功能特性，过程特性</p></li></ol></li><li><p>数据链路层</p><ol><li>在两个相邻节点间传输数据，使之对网络层呈现为一条无错的链路</li><li>主要功能与服务：<ol><li>建立与拆除数据链路连接</li><li>组帧（帧封装，按顺序传送，处理返回的确认帧）</li><li>定界与同步（产生&#x2F;识别帧边界）</li><li><strong>差错检测&#x2F;恢复</strong></li><li><strong>流量控制</strong></li></ol></li></ol></li><li><p>网络层</p><ol><li>定义了能<strong>够标识所有结点的逻辑地址、路由实现的方式和学习的方式</strong></li><li>选择合适的路由，<strong>把分组从源端传送到目的端</strong></li><li>主要功能：<ul><li>流量控制：协调A的<strong>发送速度和B的接收速度</strong></li><li>差错控制：通信两结点之间约定特定的检错规则</li><li>拥塞控制：<strong>当网络处于拥塞状态时，采取措施缓解拥塞</strong></li><li>异构网络的连接：<strong>大量的异构网络通****过路由器相互连接起来</strong></li></ul></li></ol></li><li><p>传输层</p><ol><li>在源端与目的端之间提供可靠的透明数据传输</li><li>使上层服务用户不必关系通信子网的细节</li><li>主要功能：</li><li>地址映射：源端进程地址映射到网络地址</li><li>多路复用与分用：<ol><li>多个传输连接共用一条网络连接</li><li>一条传输连接使用多个网络连接</li><li>进行数据分段并在目的端重新组装 </li><li>传输连接的建立与释放：提供”面向连接”和”无连接”两种服务 </li><li>传输差错校验与恢复 </li><li>流量控制：防止数据传输过载</li></ol></li></ol></li><li><p>会话层</p><ol><li><p>允许不同主机上各进程之间的会话</p></li><li><p>利用传输层提供的端到端服务，向表示层提供增值服务</p></li><li><p>主要功能：</p><ul><li><p>建立同步：向表示层或用户进程提供建立连接并在连接上有序地传输数据</p></li><li><p>负责<strong>管理主机间的会话进程</strong></p></li><li><p>包括<strong>建立、管理以及终止进程间的会话</strong></p></li><li><p>使用校验点可使通信会话在通信失效时从校验点恢复通信，实现数据同步</p></li></ul></li></ol></li><li><p>表示层</p><ol><li>主要用于处理两个通信系统中<strong>交换信息的表示方式</strong></li><li>处理不同机器采用的编码和表示方法不同的问题</li><li>主要功能：</li></ol><ul><li><p>采用抽象的标准方法定义数据结构</p></li><li><p>采用标准的编码形式</p></li><li><p>提供数据压缩、加密和解密服务</p></li><li><p>关心面向应用的信息的语法和语义</p></li></ul></li><li><p>应用层</p></li></ol><h3 id="TCP-IP体系结构"><a href="#TCP-IP体系结构" class="headerlink" title="TCP&#x2F;IP体系结构"></a>TCP&#x2F;IP体系结构</h3><p>TCP&#x2F;IP协议采用4层体系结构，由下向上依次是：网络接口层，网际层，传输层，应用层，网络接口层</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241308473.png" alt="image-20241124130838141"></p><ol><li>网络接口层<ol><li>是TCP&#x2F;IP模型的最底层，负责从主机或结点接收IP分组并将它们发送到指定物理网路上</li><li>相当于OSI参考模型的物理层和数据链路层</li><li>TCP&#x2F;IP标准并没有定义具体的网络接口协议，旨在提供灵活性</li><li>各物理网络可以使用自己的数据链路层协议和物理层协议</li><li>典型的物理网络类型：<ul><li>局域网：以太网、令环网、令牌总线网等</li><li>公共数据网络：电话网、SDH、X.25、帧中继和ATM等</li></ul></li><li>典型协议包括<ol><li>HDLC协议（高级数据链路控制协议）在帧数据中凡是出现连续五个1时，就在输出位流末尾加0</li><li>PPP协议（点到点协议）</li><li>STP生成树协议</li><li>FR（帧中继协议）</li></ol></li></ol></li><li>网际层<ol><li>主要功能是消息寻址及把逻辑地址和名称转换成物理地址</li><li>通过判定从源计算机到目标计算机的路由</li><li>控制通信子网的操作</li><li>常用协议<ol><li><p>网络协议（IP）</p></li><li><p>网络控制报文协议ICMP</p><ol><li><p>ICMP差错报告报文共有5种情况： </p><p>  1.终点<strong>不可达</strong>：无法交付时，向源点发 </p><p>  2.源点抑制：<strong>拥塞</strong>丢包时，向源点发送，使源点知道应降低发送速率 </p><p>  3.时间超过：生存时间为0的数据报或在预先规定的时间内不能收到，丢弃并向源点发时间超过报文 </p><p>  4.<strong>参数问题****：首部字段不正确</strong> </p><p>  5.改变<strong>路由</strong>（重定向）：改变路由报文发给主机，使主机知道下次应将数据报发送给另外的路由</p><p>  -t :不停的ping对方主机，直到你按下Control-C； </p><pre><code>-a：解析计算机NetBios名； -n：发送count指定的Echo数据包数； -l ：定义echo数据包大小。</code></pre></li></ol></li><li><p>地址转换协议ARP</p></li><li><p>反向地址转换协议RARP</p></li><li><p>路由协议OSPF等</p></li></ol></li></ol></li><li>传输层<ol><li>主要功能是提供从一个应用程序（进程）到另一个应用程序（进程）的通信称为<strong>端对端的通信</strong></li><li><strong>端到端的通信</strong>实际是指从源进程发送数据到目标进程的通信过程</li></ol></li><li>传输层<ol><li>UDP协议（用户数据报协议）<ol><li>为应用程序提供一种无需建立连接就可以发送封装的IP数据报的方法</li><li>特点：无连接、不可靠</li></ol></li><li>TCP协议（传输控制协议）<ol><li>是一种面向连接的、可靠的、基于字节流的传输层通信协议</li><li>特点：面向连接、可靠传输、字节流传输</li></ol></li></ol></li><li>应用层<ol><li>FTP（文件传输协议）</li><li>Telnet（远程登录协议）</li><li>DNS（域名服务）</li><li>SMTP（简单邮件传输协议）</li><li>HTTP（超文件传输协议）</li></ol></li></ol><p>第一层：物理层 </p><p>第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY  </p><p>第三层：网络层 IP、IPX、APPLETALK、ICMP  </p><p>第四层：传输层 TCP、UDP、SPX  </p><p>第五层：会话层 RPC、SQL、NFS 、X WINDOWS、ASP </p><p>第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG  </p><p>第七层：应用层 HTTP,FTP,SNMP等</p><h3 id="TCP-IP与OSI模型比较"><a href="#TCP-IP与OSI模型比较" class="headerlink" title="TCP&#x2F;IP与OSI模型比较"></a>TCP&#x2F;IP与OSI模型比较</h3><ol><li>二者都采取分层的体系结构<ul><li>将庞大且复杂的问题划分为若干个较容易处理的、范围较小的问题</li><li>各层的功能也大体相似</li></ul></li><li>二者都是基于独立的协议的概念</li><li>二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信</li></ol><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>将两台 PC 机通过网卡用网线直接连接，应该采用哪种类型的双绞线？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RJ-11电话接口，</span><br><span class="line">RJ-45网络接口</span><br></pre></td></tr></table></figure><p>以太网双绞连接线有两种：一种是广泛使用的直连接线，另一种是特殊情况下使用的交叉线，如果是pc连接交换机或其他网络接口等，或是其它连接的双方地位不对等的情况下都使用<strong>直连接线</strong>，而如果连接的两台设备是对等的，例如都是两台pc机，笔记本等，就要使用<strong>交叉线</strong>了，两者的差别是线序不一致，接口是一样的。</p><p><strong>直通线</strong>用于连接<strong>不同类</strong>设备：<strong>电脑—交换机, 交换机—-路由器</strong> </p><p>  <strong>交叉线</strong>用于连接相同类设备：<strong>电脑—-电脑 , 交换机—-交换机</strong> </p><p>  <strong>反转线</strong>用于电脑直接连接路由器：. 电脑—-路由器 </p><p><strong>同类交叉不同直连</strong> </p><p> 标准568A：绿白-1，绿-2，橙白-3，蓝-4，蓝白-5，橙-6，棕白-7，棕-8。 </p><p>  标准568B：橙白-1，橙-2，绿白-3，蓝-4，蓝白-5，绿-6，棕白-7，棕-8。 </p><p>  两端都是568A或者568B的双绞线是直通线；一端是568A，一端是568B的双绞线是交叉线。</p><p><strong>快速以太网</strong>是指100Mbps速率以上的<br>  单模光纤传输适合距离远，不会色散，传输可靠，但仅一个模式； </p><p>  多模光纤传输适合短距离，可以多个模式传输，但会发生色散，不够可靠；</p><p>串行通信：串行通信是指 使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度。其只需要少数几条线就可以在系统间交换信息，特别适用于计算机与计算机、计算机与外设之间的<strong>远距离通信</strong>。   </p><p>​    并行是指多比特数据同时通过并行线进行传送，这样数据传送<strong>速度大大提高</strong>，但并行传送的线路长度受到限制，因为长度增加，干扰就会增加，数据也就容易出错。   </p><p>路由器、网桥（交换机）和集线器分别工作于网络层、数据链路层和物理层</p><p><strong>交换机</strong>每个端口<strong>独享带宽</strong>，<strong>集线器</strong>每个端口<strong>共享带宽</strong>  </p><p>路由器可以隔绝广播域，也可以隔绝冲突域，交换机只能隔绝冲突域，不能隔绝广播域。集线器只起信号发达和转发的作用。  </p><p>交换机下不同的端口处于不同的冲突域中，但所有的端口都处于同一个广播域 </p><p>  1、骨干网：它由所有用户共享，负责传输骨干数据流。 </p><p>   2、接入网：提供通常说的最后一公里的连接——即用户和骨干网络之间的连接。 </p><p>T1载波的数据速率是1.544Mbps</p><p> E1载波的数据速率是2.048Mbps，<br> E2载波数据速率为8.448Mbps，<br> E3载波数据速率为34.368Mbps，<br> E4载波数据速率为139.24Mbps，<br> E5载波数据速率为565.148Mbps</p><p>  电路交换具有以下优缺点： </p><p>​    <strong>优点</strong>： （1）由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。 （2）通信双方之间的屋里通路一旦建立，双方可以随时通信，实时性强。（3）双方通信时按发送顺序传送数据，不存在失序问题。（4）电路交换既适用于传输模拟信号，也适用于传输数字信号。（5）电路交换的交换设备及控制均比较简单。 </p><p>​    分组交换具有以下优缺点。  </p><p>​     <strong>优点</strong>：（1）分组交换不需要为通信双反预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送分组。（2）由于采用存储转发方式，加之交换节点具有路径选择，当某条传输线路故障时可选择其他传输线路，提高了传输的可靠性。（3）通信双反不是固定的战友一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。（4）加速了数据在网络中的传输。因而分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了传输时间。（5）分组长度固定，相应的缓冲区的大小也固定，所以简化了交换节点中存储器的管理。（6）分组较短，出错几率减少，每次重发的数据量也减少，不仅提高了可靠性，也减少了时延。  </p><p>同轴电缆 只能数字信号。</p><p>  双绞线（twisted pair，TP） 双绞线，模拟信号，数字信号。传输距离最多100m，与同轴电缆相比，双绞线易受外部电磁波的干扰，线路本身也产生噪声，误码率较高</p><p>  屏蔽双绞线（英语：Shielded Twisted Pair，STP）,是一种广泛用于数据传输的铜质双绞线可以抗电磁干扰。 </p><p>  非屏蔽双绞线(UTP：Unshilded Twisted Pair) </p><p>光纤比屏蔽双绞线要好抗电磁干扰</p><p>Cisco路由器用于查看路由表信息的命令是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show run//看运行状况</span><br><span class="line">show ip route//看路由表 show int//看断口*</span><br><span class="line">show ip int br//看端口ip地址 show cdp nei//察看cdp邻居</span><br><span class="line">show ip pro//察看ip协议</span><br></pre></td></tr></table></figure><p>曼彻斯特编码的核心特点：</p><ol><li>编码规则：</li></ol><ul><li>1：高到低电平跳变</li><li>0：低到高电平跳变</li><li>每个码元中间必有跳变</li></ul><ol><li>技术特点：</li></ol><ul><li>自同步(信号跳变提供时钟)</li><li>无直流分量</li><li>便于检错(每位必有跳变)</li></ul><ol><li>缺点：</li></ol><ul><li>带宽占用大(是基带的2倍)</li><li>传输距离受限</li></ul><ol><li>改进版本： 差分曼彻斯特编码：用跳变的有无表示数据，抗干扰能力更强</li></ol><p>主要应用于以太网802.3标准和令牌环网络。</p><p>10BASE-T采用的物理拓扑结构是星型，逻辑拓扑结构是总线型 </p><p>100BASE-T 是逻辑物理都是星型结构 </p><p>450MHz系统：误差不得超过5×10^-6 (即20ppm) 900MHz系统：误差不得超过3×10^-6 (即4ppm)</p><p> 一个码元携带的信息量n（比特）与码元取的离散值个数N具有如下关系： </p><p>  n &#x3D; log2N </p><p>  数据速率指单位时间内信道上传送的信息量(比特数) </p><p>  数字信道的通频带(即带宽)决定了信道中能不失真的传输脉冲序列的最高速率，即信道容量 </p><p>  <strong>R &#x3D; B log2N &#x3D; 2W log2N</strong> </p><p>  其中B为最大码元速率，B  &#x3D; 2W Baud </p><p>  其中W 为信道带宽</p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>以太网的协议结构包括理层、数据链路层   数据链路层分层为逻辑链路控制子层（LLC）和媒体访问控制子层(MAC)。不同的物理层对应不同的MAC子层，LLC子层则完全独立。</p><p><img src="https://z3.ax1x.com/2021/03/21/656v3d.png" alt="img"></p><p><img src="https://uploadfiles.nowcoder.com/images/20190922/4004164_1569140086568_F44F95D62917BD2A431B3A218AB53122" alt="img"></p><p>ADSL(非对称数字用户线)是一种利用现有电话线路进行数据传输的宽带技术。其特点是:</p><ol><li>非对称传输:下行速率(最高24Mbps)远大于上行速率(最高1Mbps)</li><li>**频分复用:**：异步传输</li></ol><ul><li>低频段(0-4KHz):传输语音</li><li>中频段:上行数据</li><li>高频段:下行数据</li></ul><ol><li>通过电话线传输,无需重新布线,适合家庭宽带使用</li></ol><p>主要优点是可复用现有电话线路,成本低,但传输距离受限(通常不超过5.5公里)。</p><p>MAC地址也叫物理地址、硬件地址或链路地址，MAC地址则是48位的，IP地址才是32位的</p><p>MAC 地址是由 48 位二进制数组成，通常表示为 12 个十六进制数，每两个十六进制数为一组，中间用冒号或减号分隔。   </p><p><strong>网桥</strong>连接不同网段，是数据链路层设备，可以隔绝碰撞域    </p><p><img src="https://uploadfiles.nowcoder.com/images/20200217/969156946_1581908541437_131FA92C75D60B62AFCDCCF2872A039F" alt="img"></p><p>数据链路层一般都提供3种基本服务，即无确认的无连接服务、有确认的无连接服务、有确认 的面向连接的服务。 </p><p>  （1）无确认的无连接服务 无确认的无连接服务是源机器向目的机器发送独立的帧，而目的机器对收到的帧不作确认。 如果由于线路上的噪声而造成帧丢失，数据链路层不作努力去恢复它，恢复工作留给上层去完成。 这类服务适用于误码率很低的情况，也适用于像语音之类的实时传输，实时传输情况下有时数据延误比数据损坏影响更严重。 大多数局域网在数据链路层都使用无确认的无连接服务。 </p><p>  （2）有确认的无连接服务 这种服务仍然不建立连接，但是所发送的每一帧都进行单独确认。 以这种方式，发送方就会知道帧是否正确地到达。如果在某个确定的时间间隔内，帧没有到达，就必须重新发此帧。  </p><p>  （3）有确认的面向连接的服务 采用这种服务，源机器和目的机器在传递任何数据之前，先建立一条连接。 在这条连接上所发送的每一帧都被编上号，数据链路层保证所发送的每一帧都确实已收到。 而且，它保证每帧只收到一次，所有的帧都是按正确顺序收到的。面向连接的服务为网络进程间提供了可靠地传送比特流的服务。</p><p> IEEE 802.1—概述、体系结构和网络互连，以及网络管理和性能测量。</p><p> IEEE 802.2—逻辑链路控制LLC。最高层协议与任何一种局域网MAC子层的接口。</p><p> IEEE 802.3—CSMA&#x2F;CD网络，定义CSMA&#x2F;CD总线网的MAC子层和物理层的规范。</p><p> IEEE 802.4—令牌总线网。定义令牌传递总线网的MAC子层和物理层的规范。</p><p> IEEE 802.5—令牌环形网。定义令牌传递环形网的MAC子层和物理层的规范。</p><p> IEEE 802.6—城域网。</p><p> IEEE 802.7—宽带技术。</p><p> IEEE 802.8—光纤技术。</p><p> IEEE 802.9—综合话音数据局域网。</p><p> IEEE 802.10—可互操作的局域网的安全。</p><p> IEEE 802.11—无线局域网。</p><p> IEEE 802.12—优先高速局域网(100Mb&#x2F;s)。</p><p> IEEE 802.13—有线电视(Cable-TV)</p><p> <strong>ARP</strong> (Address Resolution Protocol) 协议数据单元封装在数据链路层中发送。 </p><p>  ARP 协议是一种网络层协议，它的作用是在没有其他方式可以获徖目标主机的物理地址的情况下，通过发送 ARP 广播请求来获得目标主机的物理地址。 </p><p> <strong>ARP 协议的数据单元封装在数据链路层的帧中发送</strong>，它发送的是广播数据帧，用于在网络中所有主机之间进行地址解析。 </p><p> 总之,ARP 协议数据单元封装在数据链路层中发送。</p><p>交换机本身就是一种二层设备，所有的接口组成一个广播域。但是在VLAN配置后，每一个VLAN组成一个广播域。因此VLAN是划分广播域的一种技术</p><p>异步传输模式(Asynchronous Transfer Mode)：ATM信元是固定长度的分组，共有53个字节，分为2部分，前面5个字节为信头，主要完成寻址的功能，后面48个字节为信息段，用来装载来自不同用户，不同业务的信息。语音，数据，图像等所有的数字信息都要经过切割，封装成同一格式的信元在网中传递，并在接收端恢复成所需的格式。</p><p>PPP(Point-to-point Protocol)是使用<strong>串行线路通信的面向字节的协议</strong>，该协议应用在直接连接两个结点的链路之上。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单链接的一种共同的解决方案。</p><p>PPP是在SLIP的基础上发展而来的，它既可以在异步线路上传输，也可以在同步线路上使用；不仅用于Modem链路，也用于租用的路由器到路由器的线路 </p><p>PPP有三个组成部分：</p><ol><li><p>链路控制协议LCP：用于建立、配置、测试和管理数据链路</p></li><li><p>网络控制协议NCP：PPP允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</p></li><li><p>一个将IP数据报封装到串行链路的方法</p></li></ol><p>  注意： 1. PPP提供差错检测但不提供纠错功能，只保证无差错接收(通过硬件进行CRC校验)。它是不可靠的传输协议，因此也不使用序号和确认机制</p><ol start="2"><li><p>它仅仅支持点对点的链路通信，不支持多点线路</p></li><li><p>PPP只支持全双工网路</p></li><li><p>PPP的两端可以运行不同的网络层协议，但仍然可以使用同一个PPP进行通信</p></li><li><p>HDLC(High-level Data Link Control，高级数据链路控)协议是一种面向比特的高效链路层协议</p></li></ol><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>逆地址解析协议（Reverse Address Resolution Protocol，RARP），是一种网络协议，互联网工程任务组（IETF）在RFC903中描述了RARP[1]。RARP使用与ARP相同的报头结构，作用与ARP相反。RARP用于将MAC地址转换为IP地址。其因为较限于IP地址的运用以及其他的一些缺点，因此渐为更新的BOOTP或DHCP所取代。</p><p>IPX网络的地址长度为80位 (bit，由两部分构成，第一部分是32位的网络号，第二部分是48位的节点号。IPX地址通常用十六进制数来表示。IPX网络号是由网管人员分配的，可以根据需要来定义网络号。IPX节点号通常是网络接口本身的MAC地址。</p><p>RARP的工作原理：<strong>ARP和RARP属于网络层协议。但是工作内容属于数据链路层</strong>。</p><ol><li>发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败</li></ol><p>广域网是覆盖范围最大的网，主要包括<strong>公用电话交换网(<strong>PSTN)、</strong>分组交换网</strong>（X.25）、<strong>数字数据网</strong>（DDN）、<strong>帧中继</strong>（FR）、交换式多兆数据服务（SMDS）、<strong>异步传输模式</strong>（ATM）这几种网络。  </p><p>  以太网是局域网采用的通信标准。</p><h3 id="路由算法的典型算法："><a href="#路由算法的典型算法：" class="headerlink" title="路由算法的典型算法："></a>路由算法的典型算法：</h3><p>LS算法 </p><p>Dijkstra算法  </p><p>链路向量选路算法  </p><p>距离向量算法  </p><p><img src="https://uploadfiles.nowcoder.com/files/20200802/963196997_1596363041239_20200802181023.png" alt="img"></p><p>分段发生在传输层，分片发生在网络层  </p><p>IPv6首部的40字节包含以下字段：</p><ul><li>版本号：4位</li><li>通信量类：8位</li><li>流标签：20位</li><li>有效载荷长度：16位</li><li>下一个首部：8位</li><li>跳数限制：8位</li><li>源地址：128位（16字节）</li><li>目的地址：128位（16字节）</li></ul><p>网络中的三大表 MAC表 链路层交换机维护，记录着MAC地址与交换机接口的对应关系&hellip; ARP表 主机维护，ARP协议是网络层协议，负责ip地址与mac地址的映射 路由表，这个大家都懂，可以用netstat -r 或route查看</p><p>OSPF(Open Shortest Path First<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88">开放式最短路径优先</a>）是一个<a href="https://baike.baidu.com/item/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">内部网关协议</a>(Interior Gateway Protocol，简称IGP），用于在单一<a href="https://baike.baidu.com/item/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F">自治系统</a>（autonomous system,AS）内决策<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1">路由</a>。是对<a href="https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE">链路状态路由协议</a>的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。著名的迪克斯加算法(Dijkstra)被用来计算最短路径树。OSPF分为OSPFv2和OSPFv3两个版本,其中OSPFv2用在<a href="https://baike.baidu.com/item/IPv4">IPv4</a>网络，OSPFv3用在<a href="https://baike.baidu.com/item/IPv6">IPv6</a>网络。OSPFv2是由RFC 2328定义的，OSPFv3是由RFC 5340定义的。与<a href="https://baike.baidu.com/item/RIP">RIP</a>相比，OSPF是链路状态协议，而RIP是<a href="https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E5%8D%8F%E8%AE%AE">距离矢量协议</a>。</p><p>OSPF（Open Shortest Path First打开最短路径）是内部网关协议。 BGP (Border Gateway Protocol边界网关协议)，是用于交换Internet路由信息的外部网关协议。 </p><p><strong>内部网关协议IGP</strong>是在一个自治网络内网关（主机和路由器）间交换路由信息的协议。路由信息能用于网间协议（IP）或者其它网络协议来说明路由传送是如何进行的。IGP协议包括RIP、OSPF、IS-IS、IGRP、EIGRP。</p><p>OSPF开放最短路径优先(Open Shortest Path First)，是一个内部网关协议(Interior Gateway Protocol,简称IGP)，用于在单一自治系统(autonomous system,AS)内决策路由。与RIP相对，<strong>OSPF是链路状态路由协议，而RIP是距离向量路由协议（</strong>采用UDP<strong>）。</strong></p><p> <strong>BGP</strong>属于<strong>外部或域间路由协议</strong>。BGP的主要目标是为处于不同AS中的路由器之间进行路由信息通信提供保障。<strong>BGP既不是纯粹的矢量距离协议，也不是纯粹的链路状态协议，</strong>通常被称为<strong>通路向量路由协议</strong>。这是因为BGP在发布到一个目的网络的可达性的同时，包含了在<strong>IP分组到达目的网络过程中所必须经过的AS的列表</strong>。通路向量信息时十分有用的，因为只要简单地查找一下<strong>BGP路由更新的AS编号就能有效地避免环路</strong>的出现。BGP对网络拓扑结构没有限制，其特点包括：</p><p>  （1）<strong>实现自治系统间通信</strong>，传播网络的可达信息。BGP  是一个外部网关协议，允许一个AS与另一个AS进行通信。<strong>BGP允许一个AS向其他AS通告其内部的网络的可达性信息</strong>，或者是通过该AS可达的其他网络的路由信息。同时，AS也能够从另一个AS中了解这些信息。与距离向量选路协议类似，BGP为每个目的网络提供的是下一跳（next-hop）结点的信息。 </p><p>  （2）多个BGP路由器之间的协调。如果在一个自治系统内部有多个路由器分别使用BGP与其他自治系统中对等路由器进行通信，<strong>BGP可以协调者一系列路由器，使这些路由器保持路由信息的一致性</strong>。 </p><p>  （3）BGP支持基于策略的选路（policy-base routing）。一般的距离向量选路协议确切通告本地选路中的路由。而BGP则可以实现由本地管理员选择的策略。BGP路由器可以为域内和域间的网络可达性配置不同的策略。</p><p>  （4）可靠的传输。<strong>BGP路由信息的传输采用了可靠地TCP协议</strong></p><p>（5）路径信息。在BGP通告目的网络的可达性信息时，<strong>处理指定目的网络的下一跳信息之外，通告中还包括了通路向量（path  vector），</strong>即去往该目的网络时需要经过的AS的列表，使接受者能够了解去往目的网络的通路信息。 </p><p>  （6）增量更新。BGP不需要再所有路由更新报文中传送完整的路由数据库信息，只需要在启动时交换一次完整信息。后续的路由更新报文只通告网络的变化信息。这种网络变化的信息称为增量（delta）。 </p><p>  （7）BGP支持无类型编制（CIDR）及VLSM方式。通告的所有网络都以网络前缀加子网掩码的方式表示。 </p><p>  （8）路由聚集。BGP允许发送方把路由信息聚集在一起，用一个条目来表示多个相关的目的网络，以节约网络带宽。 </p><p>  （9）BGP还允许接收方对报文进行鉴别和认证，以验证发送方的身份。</p><p>因特网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。    </p><p>网络层提供的是一种无连接、不可靠但尽力而为的数据报传输服务，将数据报从原主机传送到目的主机。</p><p>A: 10.0.0.0~10.255.255.255 即10.0.0.0&#x2F;8 </p><p>B:172.16.0.0~172.31.255.255即172.16.0.0&#x2F;12 </p><p>C:192.168.0.0~192.168.255.255 即192.168.0.0&#x2F;16</p><p>静态路由是指由用户或网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。 直接路由是指路由器各网络接口所直连的网络之间进行通信所使用的路由。直接路由是在配置完路由器网络接口的IP地址后自动生成的，因此，如果没有对这些接口进行特殊的限制，这些接口所直连的网络之间就可以直接通信。</p><p>1.<strong>路由器</strong>是一种具有<strong>多个输入端口和多个输出端口的专用计算机</strong>,其任务是转发分组。也就是说,将路由器某个输入端口收到的分组,按照分组要去的目的地(即目的网络),把该分组从路由器的某个合适的输出端口转发给下一跳的路由器。<br> 2.整个路由器的结构可划分为2个部分：<strong>路由选择部分，分组转发部分。</strong></p><p> 3.<strong>路由器选路处理器的主要工作是为经过路由器的每个数据分组寻找一条合适的转发路径</strong>，并将该数据分组从路由器的某个端口输出。为了完成这项工作，每个路由器中部维护一个包合路径信息的赂由表。当路由器收到一个数据分组时，通过该分组IP地址的网络地址标识查询路由表，以决定这个数据分组的翰出端口。<br> 4.<strong>衡量路由器性能的重要参数是路由器每秒钟能够处理的分组数</strong>。</p><p>  局域网：以太网（Ethernet）、 令牌环网（Token Ring）、 光纤分布式接口网络（FDDI）环形拓扑、 异步传输模式网（ATM） 无线局域网（WLAN）。 </p><p>  广域网：QoS，公用电话交换网(PSTN)、分组交换网（X.25）、数字数据网（DDN）、帧中继（FR）、交换式多兆数据服务（SMDS）、异步传输模式（ATM）（主要用于广域网），ISDN，ADSL </p><p>  城域网：分布式队列双总线(DQDB) </p><p>帧中继(Frame Relay)是一种<strong>网络与数据终端设备(DTE)接口标准</strong>。由于光纤网比早期的电话网误码率低得多,因此,可以减少X.25的某些差错控制过程,从而可以减少结点的处理时间,提高网络的吞吐量。帧中继就是在这种环境下产生的。帧中继提供的是数据链路层和物理层的协议规范,任何高层协议都独立于帧中继协议,因此,大大地简化了帧中继的实现。目前帧中继的主要应用之一是局域网互联,特别是在局域网通过广域网进行互联时,使用帧中继更能体现它的低网络时延、低设备费用、高带宽利用率等优点。  </p><p>帧中继网络使用 LMI(本地管理接口)协议监控 PVC 的状态。</p><p>LMI 协议主要功能：</p><ol><li>状态查询和通告</li><li>PVC可达性验证</li><li>拥塞通知</li><li>多播</li></ol><p>LMI 协议类型：</p><ul><li>Cisco</li><li>ANSI</li><li>ITU-T Q.933</li></ul><p><img src="https://uploadfiles.nowcoder.com/images/20200608/960308249_1591598593918_8C1F8C895C26E918BE3DA77EF019118E" alt="img"></p><p><img src="https://uploadfiles.nowcoder.com/images/20200608/960308249_1591598530827_3B9BEE7A46CBE3A73949938DFF5D5577" alt="img"></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><img src="https://uploadfiles.nowcoder.com/images/20170816/891535_1502864700025_4308DBEC28931D574B5E88B33BBCC75B" alt="img"></p><p>UDP报头只有四个域：源端口号，目的端口号，数据报长度，检验和。</p><p><img src="https://uploadfiles.nowcoder.com/images/20210509/456404358_1620549843682/D1103D0B32CCF0C8AAF36BE7603EA3A5" alt="img"></p><p><strong>源端口地址</strong>不是端口号。是ip地址+端口号。</p><p><strong>传输层的复用与分用。</strong> </p><p>  复用：应用层所有的应用进程都可以通过传输层再传送到IP层(网络层)。 </p><p>  分用：传输层从IP层收到发送给各应用进程的数据后，分别交付到指定的各应用进程。 </p><p>  传输层的复用与分用是通过协议端口号实现的。</p><p>TCP是面向连接的，UDP是面向无连接的 </p><ol start="2"><li><p>TCP提供可靠交付，UPD不保证可靠交付 </p></li><li><p>TCP是面向字节流的，UDP是面向报文的 </p></li><li><p>TCP有拥塞控制，UDP没有拥塞控制 </p></li><li><p>TCP固定头部有20个字节，UDP固定头部有8个字节 </p></li><li><p>TCP是全双工通信，UDP支持一对一，一对多，多对一和多对多交互通信</p></li></ol><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>Telnet是位于OSI模型的第7层—应用层上的一种协议，是一个通过创建虚拟终端提供连接到远程主机终端仿真的TCP&#x2F;IP协议。这一协议需要通过用户名和口令进行认证，是Internet远程登陆服务的标准协议。应用Telnet协议能够把本地用户所使用的计算机变成远程主机系统的一个终端 </p><p>发送：smtp，mime<br>接收：pop3，i ma p </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMTP：简单邮件传输协议，使用TCP连接，端口号为25，</span><br><span class="line">SNMP：简单网络管理协议，使用UDP 161端口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SNMP:(Simple Network Management Protocol)简单网络管理协议, 是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，它是一种应用层协议。 SNMP 使网络管理员能够管理网络效能，发现并解决网络问题以及规划网络增长。通过 SNMP 接收随机消息（及事件报告）网络管理系统获知网络出现问题。</span><br><span class="line">SNMP是一系列协议组和规范，它们提供了一种从网络上的设备中收集网络管理信息的方法，也为设备向网络管理工作站报告问题和错误提供了一种方法。</span><br></pre></td></tr></table></figure><p><strong>SNMP基于传输层UDP用户数据报协议</strong>，在管理者和被管理设备（确切的说是agent）之前传递信息。<br>SNMP管理包括下面三个部分：<br>1.MIB管理信息库<br>2.SMI管理信息的结构和标识（也称管理信息接口SMI）<br>3.SNMP简单网络管理协议</p><p>DNS：</p><p>最少情况：当本机DNS高速缓存中有该域名的DNS信息时，则不需要查询任何域名服务器，最少发出0次DNS查询。最多情况：因为均采用迭代查询方式，在最坏情况下，本地域名服务器需要依次迭代地向根域名服务器、顶级域名服务器（.com）、权限域名服务器（xyz.com）、权限域名服务器（abc.xyz.com）发出DNS查询请求，因此最多发出4次DNS查询。  </p><p>Socket通信中客户端和服务端的主要调用函数：</p><p>服务端：</p><ol><li>socket() - 创建套接字</li><li>bind() - 绑定地址</li><li>listen() - 监听连接</li><li>accept() - 接受连接</li><li>recv()&#x2F;send() - 接收&#x2F;发送数据</li><li>close() - 关闭连接</li></ol><p>客户端：</p><ol><li>socket() - 创建套接字</li><li>connect() - 连接服务器</li><li>send()&#x2F;recv() - 发送&#x2F;接收数据</li><li>close() - 关闭连接</li></ol><p>1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。</p><p> 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p><p> 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。</p><p>   2xx (成功)表示成功处理了请求的状态代码。</p><p> 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><p> 201 (已创建) 请求成功并且服务器创建了新的资源。</p><p> 202 (已接受) 服务器已接受请求，但尚未处理。</p><p> 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p><p> 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。</p><p> 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。</p><p> 206 (部分内容) 服务器成功处理了部分 GET 请求。</p><p>   3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p><p> 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p> 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</p><p> 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p> 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p><p> 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p><p> 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p><p> 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>   4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><p> 400 (错误请求) 服务器不理解请求的语法。</p><p> 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p> 403 (禁止) 服务器拒绝请求。</p><p> 404 (未找到) 服务器找不到请求的网页。</p><p> 405 (方法禁用) 禁用请求中指定的方法。</p><p> 406 (不接受) 无法使用请求的内容特性响应请求的网页。</p><p> 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。</p><p> 408 (请求超时) 服务器等候请求时发生超时。</p><p> 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p><p> 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。</p><p> 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。</p><p> 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。</p><p> 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p><p> 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。</p><p> 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。</p><p> 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。</p><p> 417 (未满足期望值) 服务器未满足”期望”请求标头字段的要求。</p><p>   5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p><p> 500 (服务器内部错误) 服务器遇到错误，无法完成请求。</p><p> 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p><p> 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。</p><p> 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。</p><p> 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p> 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本</p><p>状态码分为5类，如下：</p><p>1××(“继续努力”) &#x3D;&gt; 表示接收到请求并且继续处理</p><p>2××（“开心”） &#x3D;&gt; 表示动作被成功接收、理解和接受</p><p>3××（“又要跑一趟”） &#x3D;&gt; 为了完成指定的动作，必须接受进一步处理</p><p>4××（“自己的问题自己解决”） &#x3D;&gt; 客户端发生错误，请求中包含错误语法，请求不能被正确执行</p><p>5××（“服务不到位”） &#x3D;&gt; 服务端出现错误，服务器不能正确地执行请求。</p><p>常见的状态码：</p><p>200 &#x3D;&gt; 表明该请求被成功地完成，所请求的资源发送回了客户端</p><p>301 &#x3D;&gt; 永久转移</p><p>304 &#x3D;&gt; 服务端文件未做修改，客户端利用本地的缓存文件即可</p><p>403 &#x3D;&gt; 禁止访问</p><p>404 &#x3D;&gt; 请求的资源不存在（eg: 输错了网址、资源被删除）</p><p>503 &#x3D;&gt; 服务器暂时无法提供服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DNS，Domain Name System或者Domain Name Service（域名系统或者余名服务）。域名系统为Internet上的主机分配域名地址和IP地址。用户使用域名地址，该系统就会自动把域名地址转为IP地址。 </span><br><span class="line">ADNS是硬件防火墙的意思. </span><br><span class="line">PDNS 本身是一个支持 mysql 数据库的 dns 服务器。</span><br><span class="line"></span><br><span class="line">TFTP 使用UDP</span><br><span class="line">FTP 使用TCP</span><br><span class="line">FTP需要建立双重连接，一个控制连接，一个是数据连接。</span><br><span class="line"></span><br><span class="line">在给FTP服务器设计ACL时，在控制方面，端口号为21，一般用于登录认证，在数据传输方面，若为主动模式，则端口号为20；若为被动模式，则由服务端和客户端协商而定</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411292145681.png" alt="image-20241129214503616"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411301126006.png" alt="image-20241130112609352"></p><p>1.IP租用请求：<br>   DHCP客户机初始化TCP&#x2F;IP，通过UDP端口67向网络中发送一个<strong>DHCP discover广播包</strong>，请求租用IP地址。</p><p> 2.IP租用提供：<br>   任何接收到DHCP discover广播包<strong>并且能够提供IP地址的DHCP服务器</strong>，<strong>都会通过UDP端口68给客户机回应一个DHCP offer广播包</strong>，提供一个IP地址。</p><p> 3.IP租用选择：<br>   <strong>客户机从不止一台DHCP服务器接收到提供之后</strong>，<strong>会选择第一个收到的DHCP offer包</strong>，并向<strong>网络中广播一个DHCP request消息包，表明自己已经接受了一个DHCP服务器提供的IP地址</strong>。<br>   所有其他的DHCP服务器撤消它们的提供以便将IP地址提供给下一次IP租用请求。 </p><p> 4.IP租用确认：<br>   被客户机选择的DHCP服务器在收DHCP request广播后<br>   1)即<strong>发送 DHCP positive 确认信息</strong>，以确定此租约成立，且此信息中还包含其它 DHCP 选项信息。<br>   2)当客户机请求的是一个无效的或重复的 IP 地址，则 DHCP 服务器在第五步发送 DHCP negative 确认信息，客户机收到 DHCP negative 确认信息初始化失败。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8a2e667684a495c99da1c2b5e030601~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20220216122452533.png"></p><p>http 80</p><p>  ftp 20&#x2F;21</p><p>  ssh 22</p><p>  telnet 23</p><p>  smtp 25</p><p>tcpdump抓取网络数据包进行分析<br>top 实时监控活动进程的运行情况 有对应命令字段 cpu使用率 内存使用率<br>netstat 查看网络连接信息<br>ifconfig 查看网卡信息     </p><p>DNS server间的查询模式是迭代式，而客户端之间为递归式。  </p><p>DNS<br>  服务的常见资源记录类型：A记录（主机地址）、CNAME记录（别名）、MX记录（邮件主机）、NS记录（名称服务器）、SOA记录（起始授权机构）、PTR记录（IP反向解析）、SRV记录（MS<br>  DNS服务器的活动目录）。 </p><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><p>**MITM:**通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。 </p><p>  <strong>钓鱼攻击：</strong>一种企图从电子通讯中，<strong>通过伪装成信誉卓著的法人媒体以获得如用户名、密码和信用卡明细等个人敏感信息的犯罪诈骗过程。</strong>这些通信都声称（自己）来自社交网站拍卖网站\网络银行、电子支付网站\或网络管理者，以此来诱骗受害人的轻信。网钓通常是通过e-mail或者即时通讯进行。它常常导引用户到URL与界面外观与真正网站几无二致的假冒网站输入个人数据。就算使用强式加密的SSL服务器认证，要侦测网站是否仿冒实际上仍很困难。 </p><p>  <strong>水坑攻击</strong>：在受害者必经之路设置了一个“**水坑(陷阱)**”。最常见的做法是，黑客分析攻击目标的上网活动规律，寻找攻击目标经常访问的网站的弱点，先将此网站“攻破”并植入攻击代码，一旦攻击目标访问该网站就会“中招”。</p><p> 实现防火墙的主流技术有三种： </p><p>  1、包过滤技术 </p><p>  加入IP数据包过滤功能的路由器逐一审查请求包的头部信息息（包 括 IP 层所承载的上层协议的协议号、数据包的源地址、目的地址、源端口和目的端 口等），并与预先设定好的防火墙过滤规则（Filtering Rule）进行比较，根据匹配与否来决定包的放行或舍弃。以达到拒绝发送可疑的IP数据包的目的。</p><p>  2、应用网关技术 </p><p>  指在web服务器上或某一台单独主机上运行***服务器软件，对网络上的信息进行监听和检测，并对访问内网的数据进行过滤，从而起到隔断内网与外网的直接通信的作用，保护内网不受破坏。 </p><p>  3、状态检测技术 </p><p>  状态防火墙，即 ASPF（Application Specific Packet Filter，基于应用层状态 的包过滤）</p><p>  其采用的是一种基于连接的状态检测机制，将属于同一连接的所有包作为一个整体的数据流看待，构成连接状态表，通过规则表与状态表的共同配合，对表中的各个连接状态因素加以识别。这里动态连接状态表中的记录可以是以前的通信信息。</p><p> 1.XSS<br>  全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。 </p><p>  2.CSRF 的全称是“跨站请求伪造”，而 XSS的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类。CSRF  顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为  Session ID 也是大多保存在 cookie里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS  或链接欺骗等途径，让用户在本机（即拥有身份 cookie的浏览器端）发起用户所不知道的请求。 </p><p>  3.XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为<br>  XSRF</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库理论</title>
      <link href="/2024/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
      <url>/2024/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP</title>
      <link href="/2024/07/09/SpringAOP/"/>
      <url>/2024/07/09/SpringAOP/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202407092138687.png" alt="image-20240709213854654"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202407092139201.png" alt="image-20240709213910559"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202407092140582.png" alt="image-20240709213959285"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202407092141662.png" alt="image-20240709214103517"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql实战45讲读书笔记</title>
      <link href="/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一条SQL查询语句是如何执行的？"><a href="#一条SQL查询语句是如何执行的？" class="headerlink" title="一条SQL查询语句是如何执行的？"></a>一条SQL查询语句是如何执行的？</h2><p><img src="/../images/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p><ol><li><p>Server 层</p><ol><li>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等）</li></ol></li><li><p>存储引擎层</p><ol><li>存储引擎层负责数据的存储和提取</li><li>架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</li><li>执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB</li><li>你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表</li></ol></li></ol><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist #查看全部连接</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait_timeout #控制客户端无动静后最长的连接时间</span><br><span class="line">SHOW VARIABLES LIKE &#x27;wait_timeout&#x27;;</span><br><span class="line">SET GLOBAL wait_timeout = &lt;desired_timeout_in_seconds&gt;;</span><br></pre></td></tr></table></figure><p>连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><ol><li>长连接<ol><li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接</li></ol></li><li>短连接<ol><li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li></ol></li></ol><p>使用长连接后存在的问题</p><ol><li>内存占用太大被系统杀掉，mysql表现异常重启</li></ol><p>如何解决</p><ol><li>定期断开长连接。</li><li>MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>缓存以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p><strong>缓存失效非常快</strong></p><h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><ol><li><p>词法分析</p><ol><li>你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么</li><li>如识别”select”这个关键字</li></ol></li><li><p>语法分析</p><p>词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法</p></li></ol><h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><p>选择走哪个索引</p><h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><ol><li>检查执行权限<ol><li>无<ol><li>返回没有权限错误</li></ol></li><li>有<ol><li>调用存储引擎层接口</li></ol></li></ol></li></ol><h2 id="日志系统：一条SQL更新语句是如何执行的？"><a href="#日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="日志系统：一条SQL更新语句是如何执行的？"></a>日志系统：一条SQL更新语句是如何执行的？</h2><ol><li>更新语句会把表T上所有缓存结果都清空</li><li>分析器会通过词法和语法解析知道这是一条更新语句</li><li>优化器决定要使用ID这个索引。</li><li>执行器负责具体执行，找到这一行，然后更新</li></ol><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><p>redo log是<strong>InnoDB引擎特有的日志</strong></p><p>Redo log 比作粉板 mysql比作账本</p><p>粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体流程：</p><p>InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。</p><p>循环写</p><p>write pos是当前记录的位置一边写一边后移、checkpoint是当前要擦除的位置也是往后推移并且循环的，擦除记录前要把记录更新到数据文件</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong></p><p><img src="/../images/16a7950217b3f0f4ed02db5db59562a7.png" alt="img"></p><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog(归档日志)"></a>binlog(归档日志)</h4><ol><li><p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</p></li><li><p><strong>redo log</strong>是物理日志，记录的是“<strong>在某个数据页上做了什么修改</strong>”；<strong>binlog</strong>是逻辑日志，记录的是这个语句的原始逻辑，<strong>比如“给ID&#x3D;2这一行的c字段加1</strong> ”。</p></li><li><p>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ol><p>update语句的内部流程</p><p><img src="/../images/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img"></p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p> Redo Log 进入 Prepared 状态时，表示该事务的 Redo Log 已经被<strong>持久化到磁盘</strong>，但还没有提交。</p><p>通过将 binlog 持久化到磁盘</p><p>为什么需要两阶段提交？</p><p>redo log和binlog是两个<strong>独立的逻辑</strong>，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><ol><li><p><strong>先写redo log后写binlog</strong></p><p>假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的<strong>binlog里面就没有这条语句</strong>。</p><p>如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</p></li><li><p><strong>先写binlog后写redo log</strong></p></li></ol><p>​如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my.cnf</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line">sync_binlog = 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事务隔离：为什么你改了我还看不见？"><a href="#事务隔离：为什么你改了我还看不见？" class="headerlink" title="事务隔离：为什么你改了我还看不见？"></a>事务隔离：为什么你改了我还看不见？</h2><h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p><ol><li>脏读（dirty read）</li><li>不可重复读（non-repeatable read）</li><li>幻读（phantom read）</li></ol><p>SQL标准的事务隔离级别包括：</p><ol><li><p>读未提交（read uncommitted）</p><p>一个事务还没提交时，它做的变更就能被别的事务看到</p></li><li><p>读提交（read committed）</p><p>一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>可重复读（repeatable read）</p><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</p></li><li><p>串行化（serializable ）</p><p>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure></li></ol><p><img src="/../images/7dea45932a6b722eb069d2264d0066f8.png" alt="img"></p><ol><li><p>读未提交</p><p>V1、V2、V3 都是2</p></li><li><p>读提交</p><p>V1&#x3D;1、V2、V3 都是2</p></li><li><p>可重复读</p><p>V1 v2都是1、 v3是2</p></li><li><p>串行化</p><p>事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。</p><p> V1、V2值是1，V3的值是2。</p></li></ol><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p><img src="/../images/d9c313809e5ac148fc39feff532f0fee.png" alt="img"></p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><p>这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><h4 id="什么时候删除回滚日志"><a href="#什么时候删除回滚日志" class="headerlink" title="什么时候删除回滚日志"></a>什么时候删除回滚日志</h4><p>在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p><h4 id="为什么建议你尽量不要使用长事务"><a href="#为什么建议你尽量不要使用长事务" class="headerlink" title="为什么建议你尽量不要使用长事务"></a>为什么建议你尽量不要使用长事务</h4><p>这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><h4 id="如何避免长事务"><a href="#如何避免长事务" class="headerlink" title="如何避免长事务"></a>如何避免长事务</h4><ol><li>确认是否使用了set autocommit&#x3D;0。确认是否使用了set autocommit&#x3D;0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</li><li>只读事务可以去掉</li><li>业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li><li>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警&#x2F;或者kill；</li><li>把innodb_undo_tablespaces设置成2（或更大的值）。</li></ol><h4 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h4><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li><li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit work and chain #提交事务并自动启动下一个事务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60#查找持续时间超过60s的事务</span><br></pre></td></tr></table></figure><h2 id="深入浅出索引（上）"><a href="#深入浅出索引（上）" class="headerlink" title="深入浅出索引（上）"></a>深入浅出索引（上）</h2><p>给表添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_username ON users (username);</span><br><span class="line">CREATE INDEX idx_username_email ON users (username, email);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建时添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">列定义后面使用 INDEX 或 KEY 关键字来实现。</span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    username VARCHAR(255),</span><br><span class="line">    email VARCHAR(255),</span><br><span class="line">    INDEX idx_username (username),</span><br><span class="line">    INDEX idx_email (email)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    username VARCHAR(255),</span><br><span class="line">    email VARCHAR(255),</span><br><span class="line">    KEY idx_username (username),</span><br><span class="line">    KEY idx_email (email)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何删除索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_username ON users;</span><br><span class="line">想删除 users 表上的 PRIMARY KEY 索引</span><br><span class="line">ALTER TABLE users DROP PRIMARY KEY;</span><br><span class="line">如果要删除的索引是唯一索引</span><br><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><p><img src="/../images/dcda101051f28502bd5c4402b292e38d.png" alt="img"></p><p>索引类型</p><ol><li><p>主键索引 ｜ 聚簇索引</p><p>主键索引的叶子节点存的是整行数据</p></li><li><p>非主键索引 ｜ 二级索引</p><p>非主键索引的叶子节点内容是主键的值</p></li></ol><p>查询非主键索引会查到主键id 然后从主键树中查找 id并返回数据，叫做回表</p><h4 id="基于主键索引和普通索引的查询有什么区别？"><a href="#基于主键索引和普通索引的查询有什么区别？" class="headerlink" title="基于主键索引和普通索引的查询有什么区别？"></a>基于主键索引和普通索引的查询有什么区别？</h4><ul><li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为<strong>回表</strong>。</li></ul><h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>如果插入id为400 但R5所在的页满，会导致页分裂</p><p>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>解决办法</p><ol><li>使用自增主键</li></ol><p>​自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p><p><strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><h2 id="深入浅出索引（下）"><a href="#深入浅出索引（下）" class="headerlink" title="深入浅出索引（下）"></a>深入浅出索引（下）</h2><p><img src="/../images/dcda101051f28502bd5c4402b292e38d-20240525220555522.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where k between 3 and 5</span><br></pre></td></tr></table></figure><ol><li>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</li><li>再到ID索引树查到ID&#x3D;300对应的R3；</li><li>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</li><li>再回到ID索引树查到ID&#x3D;500对应的R4；</li><li>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。</li></ol><p><strong>回到主键索引树搜索的过程，我们称为回表</strong></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>select ID from T where k between 3 and 5，这时只需要<strong>查ID的值</strong>，而<strong>ID的值已经在k索引树</strong>上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p><strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p><img src="/../images/89f74c631110cfbc83298ef27dcd6370.jpg" alt="img"></p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p><p>你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p><p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><h4 id="在建立联合索引的时候，如何安排索引内的字段顺序"><a href="#在建立联合索引的时候，如何安排索引内的字段顺序" class="headerlink" title="在建立联合索引的时候，如何安排索引内的字段顺序"></a><strong>在建立联合索引的时候，如何安排索引内的字段顺序</strong></h4><p>当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>在索引遍历过程中，对索引中包含的字段先做判断</p><p><img src="/../images/b32aa8b1f75611e0759e52f5915539ac.jpg" alt="img"></p><p>索引下推的执行流程</p><p><img src="/../images/76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="img"></p><h2 id="全局锁和表锁-：给表加个字段怎么有这么多阻碍？"><a href="#全局锁和表锁-：给表加个字段怎么有这么多阻碍？" class="headerlink" title="全局锁和表锁 ：给表加个字段怎么有这么多阻碍？"></a>全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h2><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><figure class="highlight plaintext"><figcaption><span>tables with read lock (FTWRL)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</span><br></pre></td></tr></table></figure><p>使用场景</p><p>全局锁的典型使用场景是，做全库逻辑备份</p><p>缺点</p><p>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</p><p>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</p><p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p>single-transaction方法只适用于所有的表使用事务引擎的库。**如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一</p><p><strong>既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢</strong>？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：</p><ul><li>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</li><li>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ol><li><p>表锁</p><ol><li>表锁的语法是 lock tables … read&#x2F;write、unlock tables主动释放锁也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li><li></li></ol></li><li><p>元数据锁(meta data lock，MDL)</p><p>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，<strong>保证读写的正确性</strong>。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<strong>表结构做变更</strong>，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>在MySQL 5.5版本中引入了MDL，当对一个表做<strong>增删改查操作的时候，加MDL读锁</strong>；当要对<strong>表做结构变更操作</strong>的时候，<strong>加MDL写锁</strong>。</p></li></ol><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p><img src="/../images/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg" alt="img"></p><ol><li>session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。</li><li>session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。</li><li>有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。</li><li>，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</li></ol><h4 id="如何安全地给小表加字段？"><a href="#如何安全地给小表加字段？" class="headerlink" title="如何安全地给小表加字段？"></a><strong>如何安全地给小表加字段？</strong></h4><ol><li><p>解决长事务</p></li><li><p>MySQL的information_schema 库的 innodb_trx 表你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p><ol><li><pre><code>use information_schemaselect * from innodb_trx<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">3. 你要变更的表是一个热点表，上面的请求很频繁，而你不得不加个字段，你该怎么做呢，alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好</span><br><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">   ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h2 id="事务到底是隔离的还是不隔离的？"><a href="#事务到底是隔离的还是不隔离的？" class="headerlink" title="事务到底是隔离的还是不隔离的？"></a>事务到底是隔离的还是不隔离的？</h2><p>一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</p><p><img src="/../images/823acf76e53c0bdba7beab45e72e90d6.png" alt="img"></p><p>begin&#x2F;start transaction 命令<strong>并不是一个事务的起点</strong>，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。如果你想要<strong>马上启动一个事务</strong>，可以使用start transaction with consistent snapshot 这个命令。</p><p>这里设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = 1;  -- 开启自动提交</span><br><span class="line">SET autocommit = 0;  -- 关闭自动提交</span><br></pre></td></tr></table></figure><p>在MySQL里，有两个“视图”的概念：</p><ul><li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。</li><li>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li></ul><h4 id="“快照”在MVCC里是怎么工作的？"><a href="#“快照”在MVCC里是怎么工作的？" class="headerlink" title="“快照”在MVCC里是怎么工作的？"></a>“快照”在MVCC里是怎么工作的？</h4><p>InnoDB里面每个事务有一个唯一的事务ID，叫作<strong>transaction id</strong>。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p><p>每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id</p><p>数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。</p><p><img src="/../images/68d08d277a6f7926a41cc5541d3dfced.png" alt="img"></p><p>虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。</p><p>语句更新会生成undo log（回滚日志）吗？那么，<strong>undo log在哪呢？</strong></p><p>图2中的三个虚线箭头，就是<strong>undo log；而V1、V2、V3并不是物理上真实存在的</strong>，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p><p> InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</p><p><img src="/../images/882114aaf55861832b4270d44507695e.png" alt="img"></p><p>对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p><ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol><p><strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p><p><img src="/../images/9416c310e406519b7460437cb0c5c149.png" alt="img"></p><p>从图中可以看到，**第一个有效更新是事务C，把数据从(1,1)改成了(1,2)**。这时候，这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。</p><p>第二个有效更新是事务B**，把数据从(1,2)改成了(1,3)**。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。</p><p>你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。</p><p>好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p><ul><li>找到(1,3)的时候，<strong>判断出row trx_id&#x3D;101</strong>，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为<strong>一致性读</strong>。</p><h3 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h3><p><strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p><img src="/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/images/86ad7e8abe7bf16505b97718d8ac149f.png" alt="img" style="zoom:75%;"><p>如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事<strong>务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操</strong>作。</p><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>当前读。其实，除了update语句外，<strong>select语句如果加锁</strong>，也是当前读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select k from t where id=1 lock in share mode;</span><br><span class="line">select k from t where id=1 for update;</span><br></pre></td></tr></table></figure><p><img src="/../images/cda2a0d7decb61e59dddc83ac51efb6e.png" alt="img"></p><p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p><p>事务C’没提交，也就是说**(1,2)这个版本上的写锁还没释放<strong>。而事务B是</strong>当前读<strong>，必须</strong>要读最新版本，而且必须加锁<strong>，因此就被锁住了，必须等到</strong>事务C’释放这个锁**，才能继续它的当前读。</p><p><img src="/../images/540967ea905e8b63630e496786d84c92.png" alt="img"></p><h4 id="事务的可重复读的能力是怎么实现的？"><a href="#事务的可重复读的能力是怎么实现的？" class="headerlink" title="事务的可重复读的能力是怎么实现的？"></a>事务的可重复读的能力是怎么实现的？</h4><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><p>设置数据库的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><h2 id="普通索引和唯一索引，应该怎么选择？"><a href="#普通索引和唯一索引，应该怎么选择？" class="headerlink" title="普通索引和唯一索引，应该怎么选择？"></a>普通索引和唯一索引，应该怎么选择？</h2><p><img src="/../images/1ed9536031d6698570ea175a7b7f9a46.png" alt="img"></p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p><strong>InnoDB的数据是按数据页为单位来读写的</strong>。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p><p>查找到索引所在的数据页，然后一条条比对</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><h5 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h5><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个<strong>数据页还没有在内存中的话</strong>，在不影响数据一致性的前提下，InooDB会将这些<strong>更新操作缓存在change buffer</strong>中，这样就不需要从磁盘中读入这个数据页了。</p><p>在下次查询需要访问这个数据页的时候，将数据页读入内存，然后<strong>执行change buffer中与这个页有关的操作</strong>。通过这种方式就能保证这个数据逻辑的正确性。</p><p>虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，<strong>change buffer在内存中有拷贝，也会被写入到磁盘上。</strong></p><p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为<strong>merge</strong>。</p><h5 id="什么条件下可以使用change-buffer呢？"><a href="#什么条件下可以使用change-buffer呢？" class="headerlink" title="什么条件下可以使用change buffer呢？"></a>什么条件下可以使用change buffer呢？</h5><p>对于<strong>唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束</strong>。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要将数据页读入内存才能判断。如果<strong>都已经读入到内存</strong>了，那<strong>直接更新内存会更快，就没必要使用change buffer</strong>了。</p><p>因此，唯一索引的更新就不能使用change buffer，实际上也只有<strong>普通索引可以使用</strong>。</p><p>change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数<strong>innodb_change_buffer_max_size</strong>来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><h4 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h4><p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将<strong>更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程</strong>。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，<strong>change buffer反而起到了副作用</strong>。</p><h4 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h4><p>普通索引和唯一索引应该怎么选择。其实，这两类索引在<strong>查询能力上是没差别的</strong>，主要考虑的是对<strong>更新性能的影响</strong>。所以，我建议你尽量选择普通索引。</p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p><p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p><h4 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h4><p><img src="/../images/980a2b786f0ea7adabef2e64fb4c4ca3.png" alt="img"></p><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1在内存中，直接更新内存；</li><li>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息</li><li>将上述两个动作记入redo log中（图中3和4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p><p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p><p><strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。</strong></p><h2 id="MySQL为什么有时候会选错索引？"><a href="#MySQL为什么有时候会选错索引？" class="headerlink" title="MySQL为什么有时候会选错索引？"></a>MySQL为什么有时候会选错索引？</h2><h4 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h4><p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。</p><p>当然，扫<strong>描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素</strong>进行综合判断。</p><p>我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在<strong>判断扫描行数</strong>的时候出问题了。</p><h4 id="扫描行数是怎么判断的？"><a href="#扫描行数是怎么判断的？" class="headerlink" title="扫描行数是怎么判断的？"></a><strong>扫描行数是怎么判断的？</strong></h4><p>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“<strong>基数</strong>”（cardinality）。</p><h5 id="MySQL是怎样得到索引的基数的呢？"><a href="#MySQL是怎样得到索引的基数的呢？" class="headerlink" title="MySQL是怎样得到索引的基数的呢？"></a>MySQL是怎样得到索引的基数的呢？</h5><p>nnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p><img src="/../images/e2bc5f120858391d4accff05573e1289.png" alt="img"></p><p>Q1的结果还是符合预期的，rows的值是104620；但是Q2的rows值是37116，偏差就大了。而图1中我们用explain命令看到的rows是只有10001行，是这个偏差误导了优化器的判断。</p><p>到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划不用，却选择了扫描行数是100000的执行计划呢？</p><p>这是因为，如果使用<strong>索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的</strong>。</p><p>优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t 可以用来重新统计索引信息</span><br></pre></td></tr></table></figure><h4 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h4><p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢？</p><p>一种方法是，像我们第一个例子一样，<strong>采用force index强行选择一个索引</strong>。**MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p><p><img src="/../images/9582401a6bed6cb8fd803c9555750b54.png" alt="img"></p><p>既然优化器放弃了使用索引a，说明a还不够合适，所以<strong>第二种方法就是，我们可以考虑修改语句，引导MySQL使用我们期望的索引。</strong>比如，在这个例子里，显然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。</p><p><img src="/../images/14cd598e52a2b72dd334a42603e5b894.png" alt="img"></p><p><strong>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</strong></p><h2 id="怎么给字符串字段加索"><a href="#怎么给字符串字段加索" class="headerlink" title="怎么给字符串字段加索"></a>怎么给字符串字段加索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table SUser add index index1(email);</span><br><span class="line">alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure><img src="/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/images/d31da662bee595991862c439a5567eb7.jpg" alt="img" style="zoom:50%;"><img src="/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/images/134583875561de914991fc2e192cf842.jpg" alt="img" style="zoom:50%;"><p>使用第一种查询到直接返回</p><p>第二种查询到需要再查ID 然后才返回</p><p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct email) as L from SUser;</span><br></pre></td></tr></table></figure><ol><li>直接创建完整索引，这样可能比较占用空间；</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li><li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li></ol><h2 id="为什么我的MySQL会“抖”一下？"><a href="#为什么我的MySQL会“抖”一下？" class="headerlink" title="为什么我的MySQL会“抖”一下？"></a>为什么我的MySQL会“抖”一下？</h2><p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p><p><img src="/../images/349cfab9e4f5d2a75e07b2132a301fda.jpeg" alt="img"></p><p>掌柜在什么情况下会把粉板上的赊账记录改到账本上？</p><ul><li><p>第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确的账目记录到账本中才行。这个场景，对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。我在第二讲画了一个redo log的示意图，这里我改成环形，便于大家理解。</p><p><img src="/../images/a25bdbbfc2cfc5d5e20690547fe7f2e5-20240601171530918.jpg" alt="img"></p></li><li><p>第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去。</p><ul><li>“内存不够用了，要先将脏页写到磁盘”，<strong>InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页；</li><li>第三种是，使用了并且是脏页。</li><li>当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</li><li>这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。<br>你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：</li></ul></li></ul></li><li><p>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</p></li><li><p>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。<br>这样的效率最高。</p></li><li><p>第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。</p></li><li><p>第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。<br>这种场景，对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p></li></ul><h4 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h4><p>首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。</p><p>这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设置成磁盘的IOPS。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</p><h5 id="如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？"><a href="#如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？" class="headerlink" title="如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？"></a><strong>如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？</strong></h5><p>一个是脏页比例，一个是redo log写盘速度。数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%</p><p>InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      return 100;</span><br><span class="line">  return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。</p><p><strong>根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong></p><p><img src="https://static001.geekbang.org/resource/image/cc/74/cc44c1d080141aa50df6a91067475374.png" alt="img"></p><p>你就要合理地设置innodb_io_capacity的值，并且**平时要多关注脏页比例，不要让它经常接近75%**。</p><p>一旦一个查询请求需要在执行过程中<strong>先flush掉一个脏页时</strong>，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在<strong>准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</strong></p><p>在InnoDB中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p><p>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</p><h2 id="为什么表数据删掉一半，表文件大小不变"><a href="#为什么表数据删掉一半，表文件大小不变" class="headerlink" title="为什么表数据删掉一半，表文件大小不变?"></a>为什么表数据删掉一半，表文件大小不变?</h2><h4 id="参数innodb-file-per-table"><a href="#参数innodb-file-per-table" class="headerlink" title="参数innodb_file_per_table"></a>参数innodb_file_per_table</h4><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：</p><p>​这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</p><p>​这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。</p><p><strong>将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</strong></p><p>我们在删除整个表的时候，可以使用<strong>drop table命令回收表空间</strong>。但是，我们遇到的更多的删除<strong>数据的场景是删除某些行</strong>，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</p><h4 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h4><p><img src="/../images/f0b1e4ac610bcb5c5922d0b18563f3c8.png" alt="img"></p><p>们要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，<strong>可能会复用这个位置</strong>。但是，磁盘文件的大小并不会缩小。</p><p>现在，你已经知道了InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，会怎么样？</p><p>答案是，整个数据页就可以被复用了。</p><p><strong>数据页的复用跟记录的复用是不同的。</strong></p><p>记录的复用，只限于符合范围条件的数据。</p><p>R4这条记录被删除后，如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</p><p>而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID&#x3D;50的记录需要使用新页的时候，page A是可以被复用的。</p><p>如果<strong>相邻的两个数据页利用率都很小</strong>，系统就会把这两个页上的数据合到其中一个页上，<strong>另外一个数据页就被标记为可复用</strong>。</p><p>delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p><p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果<strong>数据是随机插入的</strong>，就可能造成索引的数据页分裂。</p><p><img src="/../images/8083f05a4a4c0372833a6e01d5a8e6ea.png" alt="img"></p><p>可以看到，由于page A满了，再插入一个ID是550的数据时，就不得不再申请一个新的页面page B来保存数据了。页分裂完成后，page A的末尾就留下了空洞（注意：实际上，可能不止1个记录的位置是空洞）。</p><p>更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</p><p>经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。</p><p><strong>重建表，就可以达到这样的目的。</strong></p><h4 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h4><p>你可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。</p><p>于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。显然地，表B的主键索引更紧凑，数据页的利用率也更高。如果我们把表B作为临时表，数据从表A导入表B的操作完成后，用表B替换A，从效果上看，就起到了收缩表A空间的作用。</p><p>你可以使用alter table A engine&#x3D;InnoDB命令来重建表。在MySQL 5.5版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自动完成转存数据、交换表名、删除旧表的操作。</p><p><img src="/../images/02e083adaec6e1191f54992f7bc13dcd.png" alt="img"></p><p>图3</p><p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个DDL不是Online的。</p><p><strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</li><li>用临时文件替换表A的数据文件。</li></ol><p><img src="/../images/2d1cfbbeb013b851a56390d38b5321f0.png" alt="img"></p><p>图4</p><p>DDL之前是要拿MDL写锁的，这样还能叫Online DDL吗？</p><p>确实，图4的流程中，alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</p><p>alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</p><p>什么要退化呢？为了实现Online，MDL读锁不会阻塞增删改操作。</p><p>那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。</p><p>而对于一个大表来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说，就可以认为是Online的。</p><p>上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗IO和CPU资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的<strong>gh-ost</strong>来做。</p><h4 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h4><p>我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临时表，是在server层创建的。</p><p>根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p><p>所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？</p><p>答案是不能。因为，tmp_file也是要占用临时空间的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=inplace;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=copy;</span><br></pre></td></tr></table></figure><p>当你使用ALGORITHM&#x3D;copy的时候，表示的是强制拷贝表，对应的流程就是图3的操作过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add FULLTEXT(field_name);</span><br></pre></td></tr></table></figure><p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。</p><ol><li>DDL过程如果是Online的，就一定是inplace的；</li><li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li></ol><ul><li>从MySQL 5.6版本开始，<strong>alter table t</strong> engine &#x3D; InnoDB（也就是recreate）默认的就是上面图4的流程了；</li><li><strong>analyze table t</strong> 其实不是重建表，只是对<strong>表的索引信息做重新统计</strong>，没有修改数据，这个过程中加了MDL读锁；</li><li><strong>optimize table t 等于recreate+analyze。</strong></li></ul><h4 id="什么时候使用alter-table-t-engine-InnoDB会让一个表占用的空间反而变大。"><a href="#什么时候使用alter-table-t-engine-InnoDB会让一个表占用的空间反而变大。" class="headerlink" title="什么时候使用alter table t engine&#x3D;InnoDB会让一个表占用的空间反而变大。"></a>什么时候使用alter table t engine&#x3D;InnoDB会让一个表占用的空间反而变大。</h4><ol><li>就是这个表，本身就已经没有空洞的了，比如说刚刚做过一次重建表操作。<ol><li>将表t重建一次；</li><li>插入一部分数据，但是插入的这些数据，用掉了一部分的预留空间；</li><li>这种情况下，再重建一次表t，就可能会出现问题中的现象。</li></ol></li></ol><h2 id="count-这么慢，我该怎么办？"><a href="#count-这么慢，我该怎么办？" class="headerlink" title="count(*)这么慢，我该怎么办？"></a>count(*)这么慢，我该怎么办？</h2><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)的实现方式"></a>count(*)的实现方式</h3><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把<strong>数据一行一行地从引擎里面读出来，然后累积计数</strong>。</li></ul><p>这里是没有加where条件的，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p><h4 id="为什么InnoDB不跟MyISAM一样，也把数字存起来呢？"><a href="#为什么InnoDB不跟MyISAM一样，也把数字存起来呢？" class="headerlink" title="为什么InnoDB不跟MyISAM一样，也把数字存起来呢？"></a><strong>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</strong></h4><p>这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。这里，我用一个算count(*)的例子来为你解释一下。</p><p><img src="/../images/5e716ba1d464c8224c1c1f36135d0e97.png" alt="img"></p><p>三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同。</p><p>这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是<strong>MVCC来实现的</strong>。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p><p>你知道的，InnoDB是索引组织表，主键索引树的叶子节点是数据，而<strong>普通索引树的叶子节点是主键值</strong>。所以，普通索引树比主键索引树小很多。对于count(<em>)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，<strong>MySQL优化器会找到最小的那棵树来遍历</strong>。*<em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</em></em></p><h4 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h4><p>你可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？</p><p>没错，缓存系统可能会丢失更新。</p><p>Redis的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后你要从存储redis数据的地方把这个值读回来，而<strong>刚刚加1的这个计数操作却丢失了</strong>。</p><p>比如，Redis异常重启以后，到<strong>数据库里面单独执行一次count(*)获取真实的行数</strong>，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，<strong>这一次全表扫描的成本，还是可以接受的。</strong></p><p>但是还是会有不一致的情况</p><p><img src="/../images/39898af053695dad37227d71ae288e33.png" alt="img"></p><p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p><h4 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h4><p><img src="/../images/9e4170e2dfca3524eb5e92adb8647de3.png" alt="img"></p><p>我们来看下现在的执行结果。虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p><p>因此，会话B看到的结果里， <strong>查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</strong></p><h4 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h4><p>这里，首先你要弄清楚count()的语义。<strong>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加</strong>。最后返回累计值</p><p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于count(字段)来说</strong>：</p><ol><li>如果这个<strong>“字段”是定义为not null的话</strong>，<strong>一行行地从记录里面读出这个字段，判断不能为null，按行累加</strong>；</li><li>如果这个“字段”<strong>定义允许为null</strong>，那么执行的时候，<strong>判断到有可能是null</strong>，还要把值取出来再判断一下，<strong>不是null才累加</strong>。</li></ol><p><strong>count(*)是例外</strong></p><p>并不会把全部字段取出来，而是专门做了优化，不取值。<strong>count(*)肯定不是null的字段</strong>，按行累加。</p><p>按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(*)，所以我建议你，尽量使用count(*)。</p><h2 id="日志和索引相关问题"><a href="#日志和索引相关问题" class="headerlink" title="日志和索引相关问题"></a>日志和索引相关问题</h2><h4 id="日志相关问题"><a href="#日志相关问题" class="headerlink" title="日志相关问题"></a>日志相关问题</h4><p>binlog（归档日志）和redo log（重做日志）配合崩溃恢复的时候，用的是反证法，说明了<strong>如果没有两阶段提交</strong>，会导致MySQL出现主备数据不一致等问题。</p><h4 id="在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？"><a href="#在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？" class="headerlink" title="在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？"></a>在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？</h4><p><img src="/../images/ee9af616e05e4b853eba27048351f62a.jpg" alt="img"></p><p><strong>两个“commit”的概念</strong></p><ul><li>他说的“commit语句”，是指MySQL语法中，用于提交一个事务的命令。一般跟begin&#x2F;start transaction 配对使用。</li><li>而我们图中用到的这个“commit步骤”，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了。</li><li>“commit语句”执行的时候，会包含“commit 步骤”。</li></ul><h4 id="在两阶段提交的不同时刻，MySQL异常重启会出现什么现象"><a href="#在两阶段提交的不同时刻，MySQL异常重启会出现什么现象" class="headerlink" title="在两阶段提交的不同时刻，MySQL异常重启会出现什么现象"></a><strong>在两阶段提交的不同时刻，MySQL异常重启会出现什么现象</strong></h4><p>如果在图中时刻A的地方，也就是<strong>写入redo log 处于prepare阶段</strong>之后、<strong>写binlog之前，发生了崩溃（crash）</strong>，由于<strong>此时binlog还没写，redo log也还没提交</strong>，所以<strong>崩溃恢复的时候，这个事务会回滚</strong>。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。</p><p>主要集中在时刻B，也就是<strong>binlog写完，redo log还没commit前发生crash</strong>，那崩溃恢复的时候MySQL会怎么处理？</p><h5 id="我们先来看一下崩溃恢复时的判断规则"><a href="#我们先来看一下崩溃恢复时的判断规则" class="headerlink" title="我们先来看一下崩溃恢复时的判断规则"></a>我们先来看一下崩溃恢复时的判断规则</h5><ol><li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li><li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li></ol><h4 id="MySQL怎么知道binlog是完整的"><a href="#MySQL怎么知道binlog是完整的" class="headerlink" title="MySQL怎么知道binlog是完整的?"></a>MySQL怎么知道binlog是完整的?</h4><p>一个事务的binlog是有完整格式的：</p><ul><li><p>s<strong>tatement格式</strong>的binlog，<strong>最后会有COMMIT</strong>；</p></li><li><p><strong>row格式的binlog</strong>，最后会有一个<strong>XID event</strong>。</p></li><li><p>在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。</p><h2 id="redo-log-和-binlog是怎么关联起来的"><a href="#redo-log-和-binlog是怎么关联起来的" class="headerlink" title="redo log 和 binlog是怎么关联起来的?"></a>redo log 和 binlog是怎么关联起来的?</h2><p>它们有一个<strong>共同的数据字段，叫XID</strong>。崩溃恢复的时候，会按顺序扫描redo log：</p></li><li><p>如果碰到既有prepare、又有commit的redo log，就直接提交；</p></li><li><p>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。有事务则提交，没有则会滚</p></li></ul><h2 id="处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计"><a href="#处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计" class="headerlink" title="处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?"></a>处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?</h2><p>在时刻B，也就是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个binlog恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><h4 id="如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h4><p>其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。</p><p>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。</p><p>对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回滚不了，数据和binlog日志又不一致了。</p><p>两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。</p><h4 id="不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"></a>不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？</h4><p>这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？</p><p>不可以</p><p>InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log好了。</p><p><img src="/../images/eb838b87e9c20fa00aca50ef154f2a63.jpg" alt="img"></p><p>og还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢复“数据页”。</p><p>引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经认为提交完成了，不会再应用一次binlog1。</p><p>InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要<strong>依赖于日志</strong>来恢复数据页。</p><h3 id="那能不能反过来，只用redo-log，不要binlog？"><a href="#那能不能反过来，只用redo-log，不要binlog？" class="headerlink" title="那能不能反过来，只用redo log，不要binlog？"></a>那能不能反过来，只用redo log，不要binlog？</h3><p>如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。</p><p>redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。</p><p>MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。</p><h4 id="redo-log一般设置多大？"><a href="#redo-log一般设置多大？" class="headerlink" title="redo log一般设置多大？"></a>redo log一般设置多大？</h4><p>如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文件、每个文件1GB吧</p><h4 id="正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？"><a href="#正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？" class="headerlink" title="正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？"></a>正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？</h4><p>redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由redo log更新过去”的情况。</p><ol><li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。</li><li>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li></ol><h4 id="redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？"><a href="#redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？" class="headerlink" title="redo log buffer是什么？是先修改内存，还是先写redo log文件？"></a>redo log buffer是什么？是先修改内存，还是先写redo log文件？</h4><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into t1 ...</span><br><span class="line">insert into t2 ...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。</p><p>所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时候，数据的内存被修改了，redo log buffer也写入了日志。</p><p>但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。</p><h3 id="order-by”是怎么工作的？"><a href="#order-by”是怎么工作的？" class="headerlink" title="order by”是怎么工作的？"></a>order by”是怎么工作的？</h3><h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。</p><p><img src="/../images/826579b63225def812330ef6c344a303.png" alt="img"></p><p>Extra这个字段中的“U<strong>sing filesort”表示的就是需要排序</strong>，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p><p><img src="/../images/5334cca9118be14bde95ec94b02f0a3e.png" alt="img"></p><p>图2 city字段的索引示意图</p><ol><li>满足city&#x3D;’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。</li><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li><li>对<strong>sort_buffe</strong>r中的数据按照字段name做快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p><img src="/../images/6c821828cddf46670f9d56e126e3e772.jpg" alt="img"></p><p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数<strong>sort_buffer_size</strong>。</p><p><strong>sort_buffer_size</strong>，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但<strong>如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序</strong>。</p><h4 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h4><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><h5 id="如果MySQL认为排序的单行长度太大会怎么做呢？"><a href="#如果MySQL认为排序的单行长度太大会怎么做呢？" class="headerlink" title="如果MySQL认为排序的单行长度太大会怎么做呢？"></a><strong>如果MySQL认为排序的单行长度太大会怎么做呢？</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET max_length_for_sort_data = 16;</span><br></pre></td></tr></table></figure><p>max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。</p><p>city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我们再来看看计算过程有什么改变。</p><p>新的算法放入sort_buffer的字段，<strong>只有要排序的列（即name字段）和主键id。</strong></p><ol><li>初始化sort_buffer，确定放入两个字段，即name和id；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name进行排序；</li><li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li></ol><p>这个执行流程的示意图如下，我把它称为rowid排序。</p><p><img src="/../images/dc92b67721171206a302eb679c83e86d.jpg" alt="img"></p><p>对比图3的全字段排序流程图你会发现，rowid排序多访问了一次表t的主键索引，就是步骤7。</p><p>最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><h4 id="全字段排序-VS-rowid排序"><a href="#全字段排序-VS-rowid排序" class="headerlink" title="全字段排序 VS rowid排序"></a>全字段排序 VS rowid排序</h4><p>如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><p><strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p><p>rowid排序会要求回表多造成磁盘读，因此不会被优先选择。</p><p>并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的。</strong></p><p><img src="/../images/f980201372b676893647fb17fac4e2bf.png" alt="img"></p><p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city&#x3D;’杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。</p><ol><li>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name)取下一个记录主键id；</li><li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li><li><img src="/../images/3f590c3a14f9236f2d8e1e2cb9686692.jpg" alt="img"></li></ol><p><img src="/../images/fc53de303811ba3c46d344595743358a.png" alt="img"></p><p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一下。</p><h3 id="如何正确地显示随机消息？"><a href="#如何正确地显示随机消息？" class="headerlink" title="如何正确地显示随机消息？"></a>如何正确地显示随机消息？</h3><h4 id="从一个单词表中随机选出三个单词"><a href="#从一个单词表中随机选出三个单词" class="headerlink" title="从一个单词表中随机选出三个单词"></a>从一个单词表中随机选出三个单词</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><p>这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点复杂的。</p><p><img src="/../images/59a4fb0165b7ce1184e41f2d061ce350.png" alt="img"></p><p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。</p><p>Extra的意思就是，需要临时表，并且需要在临时表上排序。</p><p><strong>对于InnoDB表来说</strong>，执行全字段排序会减少磁盘访问，因此会被优先选择。</p><p><strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘</strong>。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL这时就会选择rowid排序。</p><h5 id="MySQL的表是用什么方法来定位“一行数据”的？"><a href="#MySQL的表是用什么方法来定位“一行数据”的？" class="headerlink" title="**MySQL的表是用什么方法来定位“一行数据”的？"></a>**MySQL的表是用什么方法来定位“一行数据”的？</h5><p>如果把一个InnoDB表的主键删掉，是不是就没有主键，就没办法回表了？</p><p>如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键。</p><p>这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的InnoDB表来说，这个rowid就是主键ID；</li><li>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</li><li>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个rowid其实就是数组的下标。</li></ul><p><strong>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p><h4 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h4><p>tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p>磁盘临时表使用的引擎默认是InnoDB，是由参数<strong>internal_tmp_disk_storage_engine</strong>控制的。</p><p>磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程</p><p>我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把 max_length_for_sort_data 设置成16。</p><h3 id="为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>为什么这些SQL语句逻辑相同，性能却差异巨大？</h3><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><p>如果对字段做了函数计算，就用不上索引了，这是MySQL的规定。</p><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><p>优化器并不是要放弃使用这个索引。</p><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表扫描。你可能也发现了，tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做类型转换。</p><h5 id="数据类型转换的规则是什么？"><a href="#数据类型转换的规则是什么？" class="headerlink" title="数据类型转换的规则是什么？"></a>数据类型转换的规则是什么？</h5><p>这里有一个简单的方法，看 select “10” &gt; 9的结果：</p><ol><li>如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1；</li><li>如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是0。</li></ol><p><img src="/../images/2b67fc38f1651e2622fe21d49950b214.png" alt="img"></p><p>在MySQL中，字符串和数字做比较的话，是将<strong>字符串转换成数字</strong>。</p><h4 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h4><p>这两个表的字符集不同，一个是utf8，一个是utf8mb4，所以做表连接查询的时候用不上关联字段的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail where tradeid=$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p> 在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成utf8mb4，再跟L2做比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; </span><br><span class="line">连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</span><br></pre></td></tr></table></figure><p>每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习惯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `table_a` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `b` varchar(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>有100万行数据，其中有10万行数据的b的值是’1234567890’， 假设现在执行语句是这么写的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_a where b=&#x27;1234567890abcd&#x27;;</span><br></pre></td></tr></table></figure><p>最理想的情况是，MySQL看到字段b定义的是varchar(10)，那肯定返回空呀。可惜，MySQL并没有这么做。</p><p>那要不，就是把’1234567890abcd’拿到索引里面去做匹配，肯定也没能够快速判断出索引树b上并没有这个值，也很快就能返回空结果。</p><p>但实际上，MySQL也不是这么做的。</p><p>这条SQL语句的执行很慢，流程是这样的：</p><ol><li>在传给引擎执行的时候，做了字符截断。因为引擎里面这个行只定义了长度是10，所以只截了前10个字节，就是’1234567890’进去做匹配；</li><li>这样满足条件的数据有10万行；</li><li>因为是select *， 所以要做10万次回表；</li><li>但是每次回表以后查出整行，到server层一判断，b的值都不是’1234567890abcd’;</li><li>返回结果是空。</li></ol><h3 id="为什么我只查一行的语句，也执行这么慢？"><a href="#为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="为什么我只查一行的语句，也执行这么慢？"></a>为什么我只查一行的语句，也执行这么慢？</h3><h4 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id=1;</span><br></pre></td></tr></table></figure><p>一般碰到这种情况的话，大概率是表t被锁住了。接下来分析原因的时候，一般都是首先执行一下命</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br></pre></td></tr></table></figure><p>令，看看当前语句处于什么状态。</p><h4 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h4><p>就是使用show processlist命令查看Waiting for table metadata lock的示意图。</p><p><img src="/../images/5008d7e9e22be88a9c80916df4f4b328.png" alt="img"></p><p><strong>这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了</strong></p><p><strong>session A 通过lock table命令持有表t的MDL写锁，而session B的查询需要获取MDL读锁。所以，session B进入等待状态。</strong></p><p>但是，由于<strong>在show processlist</strong>的结果里面，session A的Command列是“Sleep”，导致查找起来很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需要设置performance_schema&#x3D;on，相比于设置为off会有10%左右的性能损失)</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p><p><img src="/../images/74fb24ba3826e3831eeeff1670990c01.png" alt="img"></p><h4 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h4><p>现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用法，一般有以下两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables t with read lock;</span><br><span class="line"></span><br><span class="line">flush tables with read lock;</span><br></pre></td></tr></table></figure><p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。</p><p>在session A中，我故意每行都调用一次sleep(1)，这样这个语句默认要执行10万秒，在这期间表t一直是被session A“打开”着。然后，session B的flush tables t命令再要去关闭表t，就需要等session A的查询结束。这样，session C要再次查询的话，就会被flush 命令堵住了。</p><p>图7是这个复现步骤的show processlist结果。这个例子的排查也很简单，你看到这个show processlist的结果，肯定就知道应该怎么做了。</p><p><img src="/../images/398407014180be4146c2d088fc07357e.png" alt="img"></p><h4 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id=1 lock in share mode; </span><br></pre></td></tr></table></figure><p><img src="/../images/3e68326b967701c59770612183277475.png" alt="img"></p><p>由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的select语句就会被堵住。</p><p><img src="/../images/3c266e23fc307283aa94923ecbbc738f.png" alt="img"></p><p>显然，session A启动了事务，占有写锁，还不提交，是导致session B被堵住的原因。</p><p>这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是MySQL 5.7版本，可以通过sys.innodb_lock_waits 表查到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t sys.innodb_lock_waits where locked_table=`&#x27;test&#x27;.&#x27;t&#x27;`\G</span><br></pre></td></tr></table></figure><h4 id="查询慢"><a href="#查询慢" class="headerlink" title="查询慢"></a>查询慢</h4><p>经过了重重封“锁”，我们再来看看一些查询慢的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c=50000 limit 1;</span><br></pre></td></tr></table></figure><p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。</p><p>你可以看一下慢查询日志。注意，这里为了把所有语句记录到slow log里，我在连接后先执行了 set long_query_time&#x3D;0，将慢查询日志的时间阈值设置为0。</p><p>：<strong>坏查询不一定是慢查询</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id=1；</span><br></pre></td></tr></table></figure><p><img src="/../images/66f26bb885401e8e460451ff6b0c0746.png" alt="img"></p><p>虽然扫描行数是1，但执行时间却长达800毫秒。</p><p><img src="https://static001.geekbang.org/resource/image/bd/d2/bde83e269d9fa185b27900c8aa8137d2.png" alt="img"></p><p>如果我把这个slow log的截图再往下拉一点，你可以看到下一个语句，select * from t where id&#x3D;1 lock in share mode，执行时扫描行数也是1行，执行时间是0.2毫秒。</p><p>看上去是不是更奇怪了？按理说lock in share mode还要加锁，时间应该更长才对啊。</p><p>你看到了，session A先用start transaction with consistent snapshot命令启动了一个事务，之后session B才开始执行update 语句。</p><p>session B执行完100万次update语句后，id&#x3D;1这一行处于什么状态呢？你可以从图16中找到答案。<img src="/../images/84667a3449dc846e393142600ee7a2ff.png" alt="img"></p><p><img src="/../images/46bb9f5e27854678bfcaeaf0c3b8a98c.png" alt="img"></p><p>session B更新完100万次<strong>，生成了100万个回滚日志(undo log)。</strong></p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p><p>undo log里记录的其实是“把2改成1”，“把3改成2”这样的操作逻辑，画成减1的目的是方便你看</p><h3 id="幻读是什么，幻读有什么问题？"><a href="#幻读是什么，幻读有什么问题？" class="headerlink" title="幻读是什么，幻读有什么问题？"></a>幻读是什么，幻读有什么问题？</h3><p><img src="/../images/5bc506e5884d21844126d26bbe6fa68b.png" alt="img"></p><p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</p><p>面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。</p><p>因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。并且，session B和sessionC的两条语句，执行后就会提交，所以Q2和Q3就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。</p><h4 id="幻读有什么问题？"><a href="#幻读有什么问题？" class="headerlink" title="幻读有什么问题？"></a>幻读有什么问题？</h4><p>session A在T1时刻就声明了，“我要把所有d&#x3D;5的行锁住，不准别的事务进行读写操作”。而实际上，这个语义被破坏了。</p><p><img src="/../images/7a9ffa90ac3cc78db6a51ff9b9075607.png" alt="img"></p><p>session B的第二条语句update t set c&#x3D;5 where id&#x3D;0，语义是“我把id&#x3D;0、d&#x3D;5这一行的c值，改成了5”。</p><p>由于在T1时刻，session A 还只是给id&#x3D;5这一行加了行锁， 并没有给id&#x3D;0这行加上锁。因此，session B在T2时刻，是可以执行这两条update语句的。这样，就破坏了 session A 里Q1语句要锁住所有d&#x3D;5的行的加锁声明。</p><p>session C也是一样的道理，对id&#x3D;1这一行的修改，也是破坏了Q1的加锁声明。</p><p><strong>其次，是数据一致性的问题。</strong></p><p>锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p><p><img src="/../images/dcea7845ff0bdbee2622bf3c67d31d92.png" alt="img"></p><ol><li>经过T1时刻，id&#x3D;5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的;</li><li>经过T2时刻，id&#x3D;0这一行变成(0,5,5);</li><li>经过T4时刻，表里面多了一行(1,5,5);</li><li>其他行跟这个执行序列无关，保持不变。</li></ol><p>这些数据也没啥问题，但是我们再来看看这时候binlog里面的内容。</p><ol><li>T2时刻，session B事务提交，写入了两条语句；</li><li>T4时刻，session C事务提交，写入了两条语句；</li><li>T6时刻，session A事务提交，写入了update t set d&#x3D;100 where d&#x3D;5 这条语句。</li></ol><p>我统一放到一起的话，就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update t set d=5 where id=0; /*(0,0,5)*/</span><br><span class="line">update t set c=5 where id=0; /*(0,5,5)*/</span><br><span class="line"></span><br><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c=5 where id=1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">update t set d=100 where d=5;/*所有d=5的行，d改成100*/</span><br></pre></td></tr></table></figure><p>好，你应该看出问题了。这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。</p><p>也就是说，id&#x3D;0和id&#x3D;1这两行，发生了数据不一致。这个问题很严重，是不行的。</p><h5 id="这个数据不一致到底是怎么引入的？"><a href="#这个数据不一致到底是怎么引入的？" class="headerlink" title="这个数据不一致到底是怎么引入的？"></a><strong>这个数据不一致到底是怎么引入的？</strong></h5><p>select * from t where d&#x3D;5 for update这条语句只给d&#x3D;5这一行，也就是id&#x3D;5的这一行加锁”导致的。</p><p><img src="/../images/34ad6478281709da833856084a1e3447.png" alt="img"></p><p>由于session A把所有的行都加了写锁，所以session B在执行第一个update语句的时候就被锁住了。需要等到T6时刻session A提交以后，session B才能继续执行。</p><p>这样对于id&#x3D;0这一行，在数据库里的最终结果还是 (0,5,5)。在binlog里面，执行序列是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c=5 where id=1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">update t set d=100 where d=5;/*所有d=5的行，d改成100*/</span><br><span class="line"></span><br><span class="line">update t set d=5 where id=0; /*(0,0,5)*/</span><br><span class="line">update t set c=5 where id=0; /*(0,5,5)*/</span><br></pre></td></tr></table></figure><p>但同时你也可以看到，id&#x3D;1这一行，在数据库里面的结果是(1,5,5)，而根据binlog的执行结果是(1,5,100)，也就是说幻读的问题还是没有解决。为什么我们已经这么“凶残”地，把所有的记录都上了锁，还是阻止不了id&#x3D;1这一行的插入和更新呢？</p><p>原因很简单。在T3时刻，我们给所有行加锁的时候，id&#x3D;1这一行还不存在，不存在也就加不上锁。</p><p><strong>也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，</strong>这也是为什么“幻读”会被单独拿出来解决的原因。</p><p>到这里，其实我们刚说明完文章的标题 ：幻读的定义和幻读有什么问题。</p><p>接下来，我们再看看InnoDB怎么解决幻读的问题。</p><h4 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h4><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是**间隙锁(Gap Lock)**。</p><p>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，这就产生了7个间隙。</p><p>在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</p><p>数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。</p><p>比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。</p><p><img src="/../images/c435c765556c0f3735a6eda0779ff151.png" alt="img"></p><p>但是间隙锁不一样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>间隙锁之间都不存在冲突关系。</p><p><img src="/../images/7c37732d936650f1cda7dbf27daf7498.png" alt="img"></p><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p><p><strong>间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。</strong></p><p><img src="/../images/df37bf0bb9f85ea59f0540e24eb6bcbe.png" alt="img"></p><ol><li>session A 执行select … for update语句，由于id&#x3D;9这一行并不存在，因此会加上间隙锁(5,10);</li><li>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</li><li>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</li></ol><p>两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。</p><p><strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong></p><p>今天和你分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这，也是现在不少公司使用的配置组合。</p><p>他们公司就使用的是读提交隔离级别加binlog_format&#x3D;row的组合。他曾问他们公司的DBA说，你为什么要这么配置。DBA直接答复说，因为大家都这么用呀。</p><h3 id="为什么我只改一行的语句，锁这么多？"><a href="#为什么我只改一行的语句，锁这么多？" class="headerlink" title="为什么我只改一行的语句，锁这么多？"></a>为什么我只改一行的语句，锁这么多？</h3><p><strong>我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><h4 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h4><p>由于表t中没有id&#x3D;7的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ol><li>根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</li><li>同时根据优化2，这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</li></ol><p>所以，session B要往这个间隙里面插入id&#x3D;8的记录会被锁住，但是session C修改id&#x3D;10这行是可以的。</p><h4 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h4><p><img src="/../images/465990fe8f6b418ca3f9992bd1bb5465.png" alt="img"></p><ol><li>根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。</li><li>要注意c是普通索引，因此仅访问c&#x3D;5这一条记录是不能马上停下来的，需要向右遍历，查到c&#x3D;10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。</li><li>但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c&#x3D;5这个等值条件，因此退化成间隙锁(5,10)。</li><li>根据原则2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么session B的update语句可以执行完成。</li><li>锁是加在索引上的；同时，它给我们的指导是，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将session A的查询语句改成select d from t where c&#x3D;5 lock in share mode。你可以自己验证一下效果。</li></ol><h4 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=10 for update;</span><br><span class="line">mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure><p>id定义为int类型，这两个语句就是等价的吧？其实，它们并不完全等价。<img src="/../images/30b839bf941f109b04f1a36c302aea80.png" alt="img"></p><ol><li>开始执行的时候，要找到第一个id&#x3D;10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id&#x3D;10这一行的行锁。</li><li>范围查找就往后继续找，找到id&#x3D;15这一行停下来，因此需要加next-key lock(10,15]。</li></ol><p>所以，session A这时候锁的范围就是主键索引上，行锁id&#x3D;10和next-key lock(10,15]。这样，session B和session C的结果你就能理解了。</p><h4 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h4><p><img src="/../images/7381475e9e951628c9fc907f5a57697a.png" alt="img"></p><p>这次session A用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p><p>所以从结果上来看，sesson B要插入（8,8,8)的这个insert语句时就被堵住了。</p><p>这里需要扫描到c&#x3D;15才停止扫描，是合理的，因为InnoDB要扫到c&#x3D;15，才知道不需要继续往后找了</p><h4 id="唯一索引范围锁bug"><a href="#唯一索引范围锁bug" class="headerlink" title="唯一索引范围锁bug"></a>唯一索引范围锁bug</h4><p><img src="/../images/b105f8c4633e8d3a84e6422b1b1a316d.png" alt="img"></p><p>session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id&#x3D;15这一行就应该停止了。</p><p>但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id&#x3D;20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。</p><p>所以你看到了，session B要更新id&#x3D;20这一行，是会被锁住的。同样地，session C要插入id&#x3D;16的一行，也会被锁住。</p><p>照理说，这里锁住id&#x3D;20这一行的行为，其实是没有必要的。因为扫描到id&#x3D;15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个bug。</p><h4 id="非唯一索引上存在”等值”的例子"><a href="#非唯一索引上存在”等值”的例子" class="headerlink" title="非唯一索引上存在”等值”的例子"></a>非唯一索引上存在”等值”的例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(30,10,30);</span><br></pre></td></tr></table></figure><p><img src="/../images/c1fda36c1502606eb5be3908011ba159.png" alt="img"></p><p>可以看到，虽然有两个c&#x3D;10，但是它们的主键值id是不同的（分别是10和30），因此这两个c&#x3D;10的记录之间，也是有间隙的。</p><p>图中我画出了索引c上的主键id。为了跟间隙锁的开区间形式进行区别，我用(c&#x3D;10,id&#x3D;30)这样的形式，来表示索引上的一行。</p><p>现在，我们来看一下案例六。</p><p>这次我们用delete语句来验证。注意，delete语句加锁的逻辑，其实跟select … for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。</p><p><img src="/../images/b55fb0a1cac3500b60e1cf9779d2da78.png" alt="img"></p><p>这时，session A在遍历的时候，先访问第一个c&#x3D;10的记录。同样地，根据原则1，这里加的是(c&#x3D;5,id&#x3D;5)到(c&#x3D;10,id&#x3D;10)这个next-key lock。</p><p>然后，session A向右查找，直到碰到(c&#x3D;15,id&#x3D;15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c&#x3D;10,id&#x3D;10) 到 (c&#x3D;15,id&#x3D;15)的间隙锁。</p><p>也就是说，这个delete语句在索引c上的加锁范围，就是下图中蓝色区域覆盖的部分。</p><p><img src="/../images/bb0ad92483d71f0dcaeeef278f89cb24.png" alt="img"></p><p>这个蓝色区域左右两边都是虚线，表示开区间，即(c&#x3D;5,id&#x3D;5)和(c&#x3D;15,id&#x3D;15)这两行上都没有锁。</p><h4 id="limit-语句加锁"><a href="#limit-语句加锁" class="headerlink" title="limit 语句加锁"></a>limit 语句加锁</h4><p><img src="/../images/afc3a08ae7a254b3251e41b2a6dae02e.png" alt="img"></p><p>这个例子里，session A的delete语句加了 limit 2。你知道表t里c&#x3D;10的记录其实只有两条，因此加不加limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B的insert语句执行通过了，跟案例六的结果不同。</p><p>这是因为，案例七里的delete语句明确加了limit 2的限制，因此在遍历到(c&#x3D;10, id&#x3D;30)这一行之后，满足条件的语句已经有两条，循环就结束了。</p><p>因此，索引c上的加锁范围就变成了从（c&#x3D;5,id&#x3D;5)到（c&#x3D;10,id&#x3D;30)这个前开后闭区间</p><h4 id="一个死锁的例子"><a href="#一个死锁的例子" class="headerlink" title="一个死锁的例子"></a>一个死锁的例子</h4><p>是按照next-key lock的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock实际上是间隙锁和行锁加起来的结果。</p><p><img src="/../images/7b911a4c995706e8aa2dd96ff0f36506.png" alt="img"></p><ol><li><p>session A 启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10] 和间隙锁(10,15)；</p></li><li><p>session B 的update语句也要在索引c上加next-key lock(5,10] ，进入锁等待；</p></li><li><p>然后session A要再插入(8,8,8)这一行，被session B的间隙锁锁住。由于出现了死锁，InnoDB让session B回滚。</p></li><li><p>其实是这样的，session B的“加next-key lock(5,10] ”操作，实际上分成了两步，先是加(5,10)的间隙锁，加锁成功；然后加c&#x3D;10的行锁，这时候才被锁住的。</p><p>也就是说，我们在分析加锁规则的时候可以用next-key lock来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p><h3 id="MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>MySQL有哪些“饮鸩止渴”提高性能的方法？</h3><h4 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h4><p><strong>第一种方法：先处理掉那些占着连接但是不工作的线程。</strong></p><p>max_connections的计算，不是看谁在running，是只要连着就占用一个计数位置。对于那些不需要保持的连接，我们可以通过kill connection主动踢掉。这个行为跟事先设置wait_timeout的效果是一样的。设置wait_timeout参数表示的是，一个线程空闲wait_timeout这么多秒之后，就会被MySQL直接断开连接。</p><p><strong>第二种方法：减少连接过程的消耗。</strong></p><h4 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h4><ol><li>索引没有设计好；<ol><li>在备库B上执行 set sql_log_bin&#x3D;off，也就是不写binlog，然后执行alter table 语句加上索引；</li><li>执行主备切换；</li><li>这时候主库是B，备库是A。在A上执行 set sql_log_bin&#x3D;off，然后执行alter table 语句加上索引。</li></ol></li><li>SQL语句没写好；</li><li>MySQL选错了索引。<ol><li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把long_query_time设置成0，确保每个语句都会被记录入慢查询日志；</li><li>在测试表里插入模拟线上的数据，做一遍回归测试；</li><li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。（我们在前面文章中已经多次用到过Rows_examined方法了，相信你已经动手尝试过了。如果还有不明白的，欢迎给我留言，我们一起讨论）。</li></ol></li></ol><h4 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h4><ol><li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。</li></ol><h3 id="MySQL是怎么保证数据不丢的？"><a href="#MySQL是怎么保证数据不丢的？" class="headerlink" title="MySQL是怎么保证数据不丢的？"></a>MySQL是怎么保证数据不丢的？</h3><h4 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h4><p>binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。</p><p>系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态如图1所示。</p><p><img src="/../images/9ed86644d5f39efb0efec595abb92e3e.png" alt="img"></p><p>可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。</p><ul><li>图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li><li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</li></ul><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><p>因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。</p><p>但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p></li></ol><h4 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h4><p>redo log buffer里面的内容，是不是每次生成后都要直接持久化到磁盘呢？</p><p>​如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</p><p>另外一个问题是，事务还没提交的时候，redo log buffer中的部分日志有没有可能被持久化到磁盘呢？</p><p>答案是，确实会有。</p><p><img src="/../images/9d057f61d3962407f413deebc80526d4.png" alt="img"></p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢多了。</p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><h2 id="MySQL有哪些“饮鸩止渴”提高性能的方法？-1"><a href="#MySQL有哪些“饮鸩止渴”提高性能的方法？-1" class="headerlink" title="MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><h3 id="短连接风暴-1"><a href="#短连接风暴-1" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>max_connections</p><p><strong>先处理掉那些占着连接但是不工作的线程。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br><span class="line">kill connection + id</span><br></pre></td></tr></table></figure><p><strong>第二种方法：减少连接过程的消耗。</strong></p><h4 id="慢查询性能问题-1"><a href="#慢查询性能问题-1" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h4><ol><li>索引没有设计好；</li><li>SQL语句没写好；</li><li>MySQL选错了索引。</li></ol><h4 id="QPS突增问题-1"><a href="#QPS突增问题-1" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h4><h2 id="MySQL是怎么保证数据不丢的？-1"><a href="#MySQL是怎么保证数据不丢的？-1" class="headerlink" title="MySQL是怎么保证数据不丢的？"></a>MySQL是怎么保证数据不丢的？</h2><h4 id="binlog的写入机制-1"><a href="#binlog的写入机制-1" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h4><p>binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态如图1所示。</p><p><img src="/../images/9ed86644d5f39efb0efec595abb92e3e-8725160.png" alt="img"></p><p>可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。</p><ul><li>图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li><li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</li></ul><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><p>将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p><h4 id="redo-log的写入机制-1"><a href="#redo-log的写入机制-1" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h4><p><img src="/../images/9d057f61d3962407f413deebc80526d4-8725289.png" alt="img"></p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢多了。</p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><h3 id="MySQL是怎么保证主备一致的？"><a href="#MySQL是怎么保证主备一致的？" class="headerlink" title="MySQL是怎么保证主备一致的？"></a>MySQL是怎么保证主备一致的？</h3><p><img src="/../images/fd75a2b37ae6ca709b7f16fe060c2c10.png" alt="img"></p><p>客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。这样可以保持节点B和A的数据是相同的。</p><p><img src="/../images/a66c154c1bc51e071dd2cc8c1d6ca6a3.png" alt="img"></p><ol><li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li><li>防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；</li><li>可以用readonly状态，来判断节点的角色。</li><li>因为readonly设置对超级(super)权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</li></ol><h2 id="Mysql是如何保证高可用"><a href="#Mysql是如何保证高可用" class="headerlink" title="Mysql是如何保证高可用"></a>Mysql是如何保证高可用</h2><p><img src="/../images/89290bbcf454ff9a3dc5de42a85a69cc.png" alt="img"></p><p>图 1 MySQL主备切换流程–双M结构</p><ol><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li><li>备库B执行完成这个事务，我们把这个时刻记为T3。</li></ol><p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。</p><p>你可以在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p><p>seconds_behind_master的计算方法是这样的：</p><ol><li>每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li><li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master。</li></ol><p>可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。</p><h4 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h4><p><strong>首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</strong></p><p><strong>第二种常见的可能了，即备库的压力大</strong>。一般的想法是，主库既然提供了写能力，那么备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。</p><p>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力</p><ol><li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li></ol><p>其中，一主多从的方式大都会被采用。因为作为数据库系统，还必须保证有定期全量备份的能力。而从库，就很适合用来做备份。</p><p><strong>这就是第三种可能了，即大事务。</strong></p><p>*另一种典型的大事务场景，就是大表DDL。**这个场景，我在前面的文章中介绍过。处理方案就是，计划内的DDL，建议使用gh-ost方案</p><h4 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h4><p>在图1的双M结构下，从状态1到状态2切换的详细过程是这样的：</p><ol><li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li><li>把主库A改成只读状态，即把readonly设置为true；</li><li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li><li>把备库B改成可读写状态，也就是把readonly 设置为false；</li><li>把业务请求切到备库B。</li></ol><p>这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。</p><p><img src="/../images/54f4c7c31e6f0f807c2ab77f78c8844a.png" alt="img"></p><p>图中的SBM，是seconds_behind_master参数的简写。</p><p>这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于readonly状态，也就是说这时系统处于不可写状态，直到步骤5完成后才能恢复。</p><p>在这个不可用状态中，比较耗费时间的是步骤3，可能需要耗费好几秒的时间。这也是为什么需要在步骤1先做判断，确保seconds_behind_master的值足够小。</p><h2 id="备库为什么会延迟好几个小时？"><a href="#备库为什么会延迟好几个小时？" class="headerlink" title="备库为什么会延迟好几个小时？"></a>备库为什么会延迟好几个小时？</h2><p><img src="/../images/1a85a3bac30a32438bfd8862e5a34eef.png" alt="img"></p><p>图1 主备流程图</p><p>我们要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主库，另一箭头代表的是备库上sql_thread执行中转日志（relay log）。如果用箭头的粗细来代表并行度的话，那么真实情况就如图1所示，第一个箭头要明显粗于第二个箭头。</p><p>在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。</p><p>而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。</p><p><img src="/../images/bcf75aa3b0f496699fd7885426bc6245.png" alt="img"></p><p>coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。而work线程的个数，就是由参数slave_parallel_workers决定的。根据我的经验，把这个值设置为8~16之间最好（32核物理机的情况），毕竟备库还有可能要提供读查询，不能把CPU都吃光了。</p><p>你需要先思考一个问题：事务能不能按照轮询的方式分发给各个worker，也就是第一个事务分给worker_1，第二个事务发给worker_2呢？</p><p>其实是不行的。因为，事务被分发给worker以后，不同的worker就独立执行了。但是，由于CPU的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。</p><p>同一个事务的多个更新语句，能不能分给不同的worker来执行呢？</p><p>答案是，也不行。举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。</p><p>coordinator在分发的时候，需要满足以下这两个基本要求：</p><ol><li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</li><li>同一个事务不能被拆开，必须放到同一个worker中。</li></ol><h1 id="MySQL-5-5版本的并行复制策略"><a href="#MySQL-5-5版本的并行复制策略" class="headerlink" title="MySQL 5.5版本的并行复制策略"></a>MySQL 5.5版本的并行复制策略</h1><h3 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。</p><p><img src="/../images/8b6976fedd6e644022d4026581fb8d76.png" alt="img"></p><p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。</p><p>有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。</p><p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。</p><h2 id="主库出问题了，从库怎么办？"><a href="#主库出问题了，从库怎么办？" class="headerlink" title="主库出问题了，从库怎么办？"></a>主库出问题了，从库怎么办？</h2><p><img src="/../images/aadb3b956d1ffc13ac46515a7d619e79.png" alt="img"></p><p>图1 一主多从基本结构</p><p>图中，虚线箭头表示的是主备关系，也就是A和A’互为主备， 从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p><p><img src="/../images/0014f97423bd75235a9187f492fb2453.png" alt="img"></p><p>图2 一主多从基本结构–主备切换</p><p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也要改接到A’。正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
