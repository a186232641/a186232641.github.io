<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>操作系统的特征：并发，共享，虚拟和异步</strong> </p><p>   *<em>并发*</em>:****<strong>计算机中存在多个运行的程序，需要OS管理和调度。</strong>  </p><p>   多个应用程序交替执行，需要知道所有运行的程序当前的执行的位置，当前正在执行的是哪一个应用，如果应用之间有切换的时候，切换到下一个应用的时候，它上次执行到什么位置，这次就从什么时候开始。当时的状态是什么样子，都需要操作系统来维护。  </p><p>   <strong>共享: “同时”共享 和 互斥共享</strong>  </p><p>   多个应用并发执行的时候，宏观上要体现出它们在同时访问资源的情况，而微观上要实现它们的互斥访问。比如说我们说到的内存，两个应用同时访问内存，那这个时候，每个应用需要知道它访问的是哪一个，另一个应用访问的是哪一个，他们俩之间不能访问出错，其中一个需要保护的内存资源，不能让另外一个应用去访问。在微观上需要对它们做很好的隔离，因为在数据总线上任何时刻只有一个应用去访问存储单元，这就是所说的微观上的互斥。  </p><p>   <strong>虚拟:利用多道程序设计技术(程序的交替运行)，让每个用户都觉得有一个计算机专门为他服务。</strong>  </p><p>   操作系统在每个应用执行的时候，这种交替执行的交替频率特别高，让用户在应用的时候感觉不太出来这台机器还有其他用户在用，当然负载大到一定程度，用户是可以感觉到的。  </p><p>   <strong>异步:1.程序的执行不是一贯到底的，而是走走停停，向前推进的速度不可预知。2.只要运行的环境相同，OS需要保证程序运行的结果也要相同。</strong>  </p><p>   如果说某个应用就是需要知道跟时间相关的这种走走停停的信息，也是可以在操作系统的支持之下，发现这种时间上的差异的。  </p><p>响应时间&#x3D;进程运行结束的时间—进程到达的时间  </p><p>周转时间：从一个批处理作业提交时刻开始直到该作业完成所经过的时间间隔（包括作业进入内存前的等待时间、在后备队列中的等待时间、占用CPU后的运行时间以及完成各种IO操作的时间）</p><p>磁盘访问总时间&#x3D;寻道时间+旋转时间+传输时间。其中，寻道时间最长</p><p><strong>静态重定位</strong>在逻辑地址转换为物理地址的过程中，<strong>地址变换在进程装入时一次完成，以后不再改变。</strong>程序的存储空间只能是连续的一片区域，而且**在重定位之后就不能再移动。这不利于内存空间的有效使用。  </p><p>动态重定位<strong>是在程序执行期间每次访问内存之前进行重定位。</strong>可变分区容易产生外部碎片。由于进程的位置发生了变化，所以要对进程在内存中的地址进行修改。<strong>修改的过程就是重定位的过程，所以这种做法也叫动态重定位</strong>。</p><p><strong>对换</strong>是指<strong>将内存中的暂时还不能被运行的进程或者暂时用不到的程序和数据，调到外存上</strong>，以便腾出足够的内存供在外存中等待的作业使用</p><p><strong>分页</strong>是一种操作系统里存储器管理的一种技术，<strong>可以使电脑的主存使用存储在辅助存储器中的数据。</strong>操作系统会将辅助存储器（通常是磁盘）中的数据分区成固定大小的区块，称为“页”。<strong>当不需要时，将分页由主存（通常是内存）移到辅助存储器；当需要时，再将数据取回，加载主存中</strong></p><p>首次适应算法：地址递增，找到第一个能满足的空闲区；  </p><p>最佳适应算法：空闲分区容量递增，找到最接近条件的最符合的空闲区； </p><p>最坏适应算法：空闲分区容量递减，挑选出容量最大的符合的空闲区； </p><p>邻近适应算法：由首次适应算法演变而来，从上一次结束的位置开始查找。</p><p>共有3个进程，5个资源，进程数小于资源数，则不会发生死锁的公式为<br> ①最多申请资源数&#x3D;资源总数&#x2F;进程数（可以整除的条件下）<br> ②最多申请资源数&#x3D;（资源总数&#x2F;进程数）+1（不可以整除的条件下）<br> 所以本题用②的计算方式，得出结果为5&#x2F;3+1&#x3D;2  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h1><h1 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h1><p>1.数据：所有能被输入到计算机中，且能被计算机处理的<strong>符号的集合</strong>。而数据结构中主要讨论结构化</p><p>数据。</p><p>2.数据元素：是数据（集合）中的一个“个体”，数据结构中的基本单位。表中的一行</p><p>3.数据项：一个<strong>数据元素可由若数据项组成</strong>，数据项是构成数据元素不可分割的单位。表中的一列</p><p>4.数据对象：数据对象是具有相同性质的<strong>数据元素的集合</strong>，是数据的一个子集。一张表或者是这张表的子表</p><p>5.关键码：也叫关键字（Key〉，是数据元素中能起标识作用的数据项</p><p>6.关系：数据元素之间的关系。<strong>数据结构中讨论的元素关系主要是指相邻关系或邻接关系</strong>。</p><p>7.数据类型是<strong>一个值的集合</strong>和定义在此集合上一<strong>组操作的总称</strong>。</p><p>（1）原子类型：其值不可再分的数据类型。</p><p>（2） 结构类型，其值可以再分解为考干成分（分量）的类型类型。</p><p>（3） 抽象数据类型：抽象数据组织和与之相关的操作。</p><p>8.数据类型：是一个值的集合和定义在此集合上的一组操作的总称。数据类型和数据结构的关系：数</p><p>据类型就是已经实现了的数据结构。</p><h2 id="数据结构相关定义"><a href="#数据结构相关定义" class="headerlink" title="数据结构相关定义"></a>数据结构相关定义</h2><p>数据结构包括：逻辑结构、存储结构(物理结构)和数据运算(数据操作)</p><p>数据的逻辑结构：数据元素之间的逻辑关系(线性和非线性结构)。</p><p>存储结构：顺序存储、链式存储、素引存储和散列存储。</p><p>数据操作：对数据要进行的运算。<strong>运算的定义</strong>是针对<strong>逻辑结构</strong>的，指出运算的功能。<strong>运算的实现</strong>是针对<strong>存储结构</strong>的，指出<strong>运算的具体操作步骤</strong>。</p><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><ol><li><p>ADT 是指一个数学模型以及定义在该模型上的一组操作。</p></li><li><p>ADT 的定义仅是一组逻辑特性描述，与其在计算机内的表示和实现开关。因此，不论ADT 的内部结构如何变化，只要其数学特性不变，都不影响其外部使用.</p></li><li><p>ADT 的形式化定义是三元组：ADT&#x3D;(D,S,P) D其中口是数据对象，S是D上的<strong>关系集</strong>，P是对D的<strong>基本操作集。</strong></p></li><li><pre><code>ADT Stack &#123;    数据对象:        一个有限线性表        操作集合:        push(x)    // 将元素x压入栈顶        pop()      // 删除并返回栈顶元素        peek()     // 返回栈顶元素但不删除        isEmpty()  // 判断栈是否为空        size()     // 返回栈中元素个数&#125;</code></pre></li></ol><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>数据元素之间的关系成为逻辑关系，相应的结构称为逻辑结构</p><p>逻辑结构元素决定输入、存储、发送、处理和信息传递的基本操作功能。</p><p>逻辑结构的类型：集合：没有关系。线性结构：一对一的关系，树型结构：一对多的关系。图状结构：多对多的关系</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411240954080.png" alt="image-20241124095413926"></p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>数据结构在计算机内存中的存储包括<strong>数据元素的存储和元素之间的关系的表示</strong>。数据的逻辑结构和物理结构是密不可分的两个方面，一个<strong>算法的设计取决于所选定的逻辑结构</strong>，而<strong>算法的实现依赖于所采用的存储结构</strong>。数据的存储结构有：顺序存储、链式存储、索引存储、散列存储。</p><ol><li>顺序存储<ol><li>用数据元素在存储器中的相对位置来表示数据元素之间的逻辑结构（关系）。</li><li>数据元素存放的地址是连续的。</li><li>优点是可以实现<strong>随机存取</strong>，每个元素占有最少的存储空间。</li><li>只能用相邻的一整块存储单元，可能产生外部碎片</li></ol></li><li>链式存储<ol><li>每个数据元素增加指针指向另一元素</li><li>地址可以不连续</li><li>优点：不会出现碎片，充分利用存储单元</li><li>缺点：需要额外的指针空间，只能顺序存取</li></ol></li><li>索引存储<ol><li>建立附加的索引表，格式为(关键字,地址)</li><li>优点：检索速度快</li><li>缺点：需要额外的索引表空间，增删数据时需要修改索引表</li></ol></li><li>散列存储<ol><li>散列存储</li><li>根据关键字直接计算存储地址（哈希存储）</li><li>优点：<strong>检索、增加和删除</strong>操作都很快</li><li>可能出现冲突，解决冲突需要额外开销</li></ol></li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法定义：是对特定问题求解方法的一种描述，指令的有限序列，每条指令表示一个或多个操作</p><h4 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h4><p>有穷性：算法必须在有限步骤后结束，且每步都在有限时间内完成。</p><p>确定性：每条指令必须有明确含义，不存在二义性，<strong>算法只有一个入口和一个出口</strong>。</p><p>可行性：算法必须能执行，所有操作都可通过基本运算执行。</p><p>输入与输出：输入：可以有零个或多个输入，来自特定对象集合。输出：有一个或多个输出，与输入有特定关系</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>可用多种方法描述：自然语言描述，形式语言描述，计算机程序设计语言描述。</p><p>算法和程序的区别：程序是算法用特定程序设计语言的具体实现，<strong>不是所有程序都是算法</strong>。</p><h4 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h4><ol><li>正确性：满足具体问题需求</li><li>可读性：易于理解和交流</li><li>健壮性：能适当处理非法或错误输入</li><li>通用性：处理结果适用于一般数据集合</li></ol><h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><h4 id="影响算法效率的因素"><a href="#影响算法效率的因素" class="headerlink" title="影响算法效率的因素"></a>影响算法效率的因素</h4><ul><li>算法策略选择</li><li>问题规模</li><li>程序设计语言</li><li>编译程序产生的机器代码质量</li><li>指令执行速度</li></ul><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>常见的时间复杂度（从快到慢）：</p><ol><li>O(1)：常量时间阶，执行次数固定</li><li>O(log n)：对数时间阶</li><li>O(n)：线性时间阶</li><li>O(n log n)：线性对数时间阶</li><li>O(n^k)：k≥2，k次方时间阶，执行次数是k次多项式</li></ol><ul><li>复杂度大小关系：O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(n³)</li><li>指数与多项式关系：O(2ⁿ) &lt; O(n!) &lt; O(nⁿ)</li></ul><h4 id="时间复杂度类型"><a href="#时间复杂度类型" class="headerlink" title="时间复杂度类型"></a>时间复杂度类型</h4><ol><li>最坏时间复杂度：最坏情况下的时间复杂度</li><li>平均时间复杂度：所有可能输入等概率出现时的期望运行时间</li><li>最好时间复杂度：最好情况下算法的时间复杂度</li></ol><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ol><li><p>基本概念：指算法运行所需存储空间的度量，表示为S(n) &#x3D; O(f(n))，n为问题规模</p></li><li><p>存储空间包括三个方面：指令常数变量所占空间，输入数据所占空间，辅助存储空间（主要考察这部分）。</p></li><li><p>常见的空间复杂度：一维数组a[n]：O(n)，二维数组a[n][m]：O(n*m)，算法原地工作：O(1)</p></li></ol><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411251017555.png" alt="image-20241125101729158"></p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><ul><li>平衡二叉树，或是一棵空树，或符合以下特性：</li></ul><p>​     <strong>【平衡特性1】</strong>：左子树的深度和右子树的深度相差不能超过1，可以是0（代表左右子树深度一样）、-1（代表左子树比右子树少一层）、1（代表左子树比右子树多一层） </p><p>​    <strong>【平衡特性2】它的左右子树也要是平衡二叉树</strong> </p><p>查找树，<strong>或是一棵空树</strong>，或满足符合以下特性：     </p><p>​    <strong>【查找特性1】</strong>：若左子树不为空，左子树节点<strong>所有的值</strong>均要小于根节点； </p><p>​    <strong>【查找特性2】：</strong> 若右子树不为空，右子树节点<strong>所有的值</strong>均要大于根节点； </p><p>  <strong>【查找特性3】它的左右子树也要是查找树</strong></p><p>如果是<strong>二叉树</strong>，那么必须要<strong>先序+中序</strong>，或者<strong>中序+后序</strong>，但是题目中说的是<strong>树</strong>，<strong>树的先序（根）&#x3D;&#x3D; 二叉树的先序</strong>，<strong>树的后序（根）&#x3D;&#x3D; 二叉树的中序</strong>，所以是一定<strong>可以构造出来</strong>的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2024/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2024/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/222fe425475cf2e344f09d4985d0947a.png" alt="在这里插入图片描述"></p><h3 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h3><h3 id="1-1-1-计算机硬件的发展"><a href="#1-1-1-计算机硬件的发展" class="headerlink" title="1.1.1 计算机硬件的发展"></a>1.1.1 计算机硬件的发展</h3><p>计算机系统&#x3D;<strong>硬件+软件</strong></p><p>摩尔定律，<strong>集成电路上的晶体管数量每18月就会翻一翻</strong>，所以每18月计算机的处理效率就会提高一倍。</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241323638.png" alt="image-20241124132336492"></p><h2 id="1-2-计算机系统层次结构"><a href="#1-2-计算机系统层次结构" class="headerlink" title="1.2 计算机系统层次结构"></a>1.2 计算机系统层次结构</h2><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241323360.png" alt="image-20241124132317759"></p><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><ul><li>冯诺曼体系结构特点:<ul><li>计算机硬件系统由五大部件组成(<strong>存储器、运算器、控制器、输出设备、输入设备</strong>)</li><li><strong>指令和数据以同等地位存于存储器</strong>，可按地址寻访</li><li><strong>指令和数据用二进制表示</strong></li><li><strong>指令由操作码和地址码组成</strong></li><li>存储程序</li><li>以<strong>运算器</strong>为中心</li></ul></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c1e19b556dfdb19218953d62f26064fd.png" alt="在这里插入图片描述"></p><ul><li><h5 id="现代计算机的组织结构"><a href="#现代计算机的组织结构" class="headerlink" title="现代计算机的组织结构"></a>现代计算机的组织结构</h5></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c26b5953b18fb5ad6035c76b44073080.png" alt="在这里插入图片描述"></p><ul><li><p>&lt;1&gt; 输入设备，是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等</p></li><li><p>&lt;2&gt; 输出设备，就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机。</p></li><li><p>&lt;3&gt; 存储器，存储器分为 主存储器(内存储器，CPU能直接访问)和 辅助存储器(外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才可以被CPU访问)。</p><p><strong>主存储器</strong>的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式(<strong>相联存储器</strong>既可以既可以按照<strong>地址寻址</strong>，又可以按照<strong>内容寻址</strong>，为了与传统存储器区别，又称为<strong>内容寻址的存储器</strong>！)</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/309a748b65828c9af3944a37602e37a3.png" alt="在这里插入图片描述"></p><p>&lt;4&gt; 运算器，是计算机的运算单元，用于算术运算和逻辑运算，运算器的核心单元是算术逻辑单元(ALU)</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/59370b5b078eef087414167b20a06ca6.png" alt="在这里插入图片描述"></p></li></ul><p>&lt;5&gt; 控制器，控制器是计算机的指挥中心，有其指挥各部件自动协调第进行工作，现代计算机将<strong>运算器和控制器</strong>集成到一个芯片上，合成为中央处理器，简称CPU。有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/41438ab8fcd23f311c5b1013a4abe6bf.png" alt="在这里插入图片描述"></p><p>按照指令和数据流可以分为：</p><ul><li>单指令流和单数据流系统（SISD），即传统的冯·诺依曼体系结构。</li><li>单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统。</li><li>多指令流和单数据流系统（MISD），这种计算机实际上不存在。</li><li>多指令流和多数据流系统（MIMD），包括多处理器和计算机系统。</li></ul><h4 id="1-2-3-计算机软件的分类"><a href="#1-2-3-计算机软件的分类" class="headerlink" title="1.2.3 计算机软件的分类"></a>1.2.3 计算机软件的分类</h4><h5 id="系统软件和应用软件"><a href="#系统软件和应用软件" class="headerlink" title="系统软件和应用软件"></a>系统软件和应用软件</h5><ol><li>计算机软件，一般分为系统软件和应用软件<ul><li>系统软件包括 <strong>操作系统，数据库管理系统，语言处理系统(比如编译器)，分布式软件系统，网络软件系统，标准库系统，服务性系统</strong>(比如连接程序)。</li><li>应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序。</li></ul></li></ol><h5 id="三个级别的语言"><a href="#三个级别的语言" class="headerlink" title="三个级别的语言"></a>三个级别的语言</h5><ul><li>1)<strong>机器语言</strong>。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。</li><li>2)<strong>汇编语言</strong>。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li><li>3)<strong>高级语言</strong>。高级语言(如C、C++、Java等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</li></ul><p>由<strong>高级语言转换到汇编语言</strong>的过程叫做<strong>编译</strong>，由<strong>汇编语言转换到机器语言</strong>的过程叫做<strong>汇编</strong>，边翻译边执行的叫做解析。</p><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d82f6c97ea5a51a3346a3a42b85df158.png" alt="在这里插入图片描述"></p><p>IR存放当下<strong>欲执行的指令</strong>；PC存放<strong>下一条指令的地址</strong>；</p><p>MAR存放<strong>欲访问的存储单元地址</strong>；MDR存放<strong>从存储单元取来的数据</strong>！</p><p>地址译码器是<strong>主存的构成部分，不属于CPU</strong>；地址寄存器虽然一般属于主存，但是现代计算机中绝大多数CPU内集成了地址寄存器！</p><p>关于CPU存取速度的比较：寄存器（CPU内部）&gt; Cache(高速的SRAM) &gt; 内存 （SDRAM）</p><h3 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ee87767dc4377de8c9b2d8ede73410d4.png" alt="在这里插入图片描述"></p><ol><li>机器字长<br>计算机的位数（机器字长），表示<strong>计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数</strong>。计算机字长通常选定为字节(8位)的整数倍，通常是2,4,8倍。不同的计算机，字节可能不同</li></ol><blockquote><p>机器字长、指令字长、存储字长的区别和联系是什么？</p><ul><li><p><strong>机器字长</strong>：计算机能直接处理的二进制数据的位数，机器字长<strong>一般等于内部寄存器的大小</strong>，它决定了<strong>计算机的运算精度</strong>。</p></li><li><p>指令字长：一个<strong>指令</strong>字中包含的二进制代码的位数。</p></li><li><p>存储字长：一个存储单元存储的二进制代码的长度。<strong>等于MDR的位数</strong>， 它们都必须是字节的整数倍。</p></li><li><p>数据字长：<strong>数据总线一次能传送信息的位数</strong>，它可以不等于MDR的位数。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。。</p></li></ul></blockquote><ol start="2"><li><p>数据通路带宽:数据总线一次所能传送信息的位数.</p></li><li><p>主存容量MAR的位数反映存储单元的个数，如MAR为16位，表示存储单元为2^16 &#x3D; 64K;若MDR为32位，则存储容量为2^16x32.</p></li><li><p>运算速度</p><ol><li><p>吞吐量，指系统在单位时间内处理请求的数量 ；从用户观点看，它是评价计算机系统性能的综合参数！</p><p>响应时间，指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结构的等待时间。</p></li><li><p>CPU时钟周期。通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，每个动作至少需要1个时钟周期。1&#x2F;f</p><p>主频(CPU时钟频率)。机器内部主时钟的频率，是衡量机器速度的重要参数。</p><ul><li>CPU周期又称为机器周期，由多个时钟周期组成！</li><li>指令周期&gt;CPU周期&gt;时钟周期</li></ul></li><li><p>CPI（Clock cycle Per Instruction），即执行<strong>一条指令所需的时钟周期数</strong>。</p><ol><li>CPU执行时间，指运行一个程序所花费的时间。<br><strong>CPU执行时间</strong> &#x3D; CPU时钟周期数&#x2F;主频 &#x3D; (指令条数xCPI)&#x2F;主频<br>CPU的性能取决于三个要素:<strong>主频、CPI 、指令条数</strong></li></ol></li><li><p>IPS(Instructions Per Second) &#x3D;主频&#x2F;平均CPI，每秒执行多少指令</p><p>MIPS(Million Instructions Per Second)&#x3D;即每秒执行多少百万条指令。<br>MFLOPS(Mega Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x106),即每秒执行多少百万次浮点运算。<br>GFLOPS(Giga Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x109)，即每秒执行多少十亿次浮点运算。</p><p>TFLOPS(Tera Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x1012)，即每秒执行多少万亿次浮点运算。</p></li></ol></li></ol><p>同一个功能既可以由软件实现又可以由硬件实现吗？</p><pre><code>软件和硬件是两种完全不同的形态，硬件是实体，是物质基础；软件是一种信息，看不见、摸不到。但在逻辑功能上，软件和硬件是等效的。因此，在计算机系统中，许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。一个最大的区别就是，硬件实现比软件实现的速度快很多，但是成本也高！所以，芯片在流片之后，如果发现bug可以用软件修复就用软件修复！</code></pre><h4 id="机器字长、指令字长、存储字长的区别和联系是什么？"><a href="#机器字长、指令字长、存储字长的区别和联系是什么？" class="headerlink" title="机器字长、指令字长、存储字长的区别和联系是什么？"></a>机器字长、指令字长、存储字长的区别和联系是什么？</h4><ul><li><p>4.机器字长、指令字长、存储字长的区别和联系是什么？</p></li><li><p><strong>机器字长</strong>：计算机能直接处理的二进制数据的位数，机器字长<strong>一般等于内部寄存器的大小</strong>，它决定了<strong>计算机的运算精度</strong>。<br>指令字长：一个指令字中包含的二进制代码的位数。<br>存储字长：一个存储单元存储的二进制代码的长度。等于MDR的位数， 它们都必须是字节的整数倍。<br>数据字长：数据总线一次能传送信息的位数，它可以不等于MDR的位数。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和<strong>机器的指令字长与数据字长</strong>相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p></li></ul><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><h3 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h3><h4 id="总线：概念与分类"><a href="#总线：概念与分类" class="headerlink" title="总线：概念与分类"></a>总线：概念与分类</h4><ol><li>什么是总线<ol><li>定义：构成计算机系统的互联机构，是多个<strong>系统功能部件之间进行数据传送</strong>的公共通路</li><li>功能：计算机在各系统功能部件之间实现<strong>地址、数据和控制信息的交换</strong></li><li>特征：在争用资源的基础上进行工作</li></ol></li><li>特点<ol><li>分时：同一时刻只允许有一个部件向总线发送信息，如有多个部件，则分时地向总线发送信息。</li><li>共享：总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享，<strong>某一时刻只允许一个部件向总线发送信息</strong>，但<strong>多个部件可以同时从总线上接收相同信息</strong></li><li>总线设备<ol><li>主设备：获得<strong>总线控制权</strong>的设备 </li><li>从设备：被主设备访问的设备，只能响应从主设备发来的各种总线命令</li></ol></li><li>总线的分类<ol><li><strong>片内总线</strong>：CPU芯片内部的总线，在<strong>芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线</strong>。</li><li><strong>系统总线</strong>：<strong>计算机系统内各功能部件</strong>（CPU、主存、IO接口）之间相互连接的总线 按系统总线传输信息内容分为3类<ol><li>数据总线：双向，与机器字长、存储字长有关</li><li>地址总线：单向，与存储地址、I&#x2F;O地址有关</li><li>控制总线：每根线都是单向的，有出、有入</li></ol></li><li><strong>通信总线</strong>：用于<strong>计算机系统之间，或计算机系统与其他系统之间的通信</strong><ol><li>按时序控制方式，分为<strong>同步总线和异步总线</strong></li><li>按数据传输方式，分为<strong>并行总线和串行总线</strong></li></ol></li></ol></li></ol></li></ol><h4 id="总线：组成与特性"><a href="#总线：组成与特性" class="headerlink" title="总线：组成与特性"></a>总线：组成与特性</h4><ol><li><p>总线的内部结构：地址线、数据线、控制线组成，数据线常常和地址线采用分时复用方式</p><ol><li>仲裁总线：包括总线请求线和总线授权线。</li><li>中断和同步总线：用于处理带优先级的中断操作。</li><li>公用线：时钟信号线，电源线，地线，系统复位线。</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241349599.png" alt="image-20241124134917407"></p></li><li><p>总线特性</p><ol><li>物理特性：总线的物理连接方式</li><li>功能特性：每根线的功能</li><li>电气特性：每根线上信号的传递方向及有效电平范围 </li><li>时间特性：规定了每根总线在什么时间有效</li></ol></li></ol><h4 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h4><ol><li>总线的传输周期：指一次总线操作所需的时间（申请阶段、寻址阶段、传输阶段、结束阶段）总线传输周期通常由<strong>若干个总线时钟周期</strong>构成</li><li>总线时钟周期：机器的时钟周期</li><li><strong>总线的工作频率</strong>：总线周期&#x3D;N 个时钟周期，则总线的工作频率&#x3D;时钟频率&#x2F; N。</li><li>总线的时钟频率：机器的时钟频率</li><li><strong>总线宽度</strong>：又称为总线位宽，是指总线上同时能够传输的数据位数，通常是指数据总线的根数</li><li><strong>总线带宽</strong>：单位时间内总线上传输的最大字节数（MB&#x2F;s）。计算公式：总线带宽 &#x3D; 总线宽度 * 总线频率</li><li>总线复用：指一种信号线在不同时间传输不同的信息，可以使用较少的线传输更多的信息</li><li>信号线数：地址线、数据线和控制线的总和</li></ol><h4 id="总线的传输方式"><a href="#总线的传输方式" class="headerlink" title="总线的传输方式"></a>总线的传输方式</h4><ol><li><p>串行传送：使用一条传输线，采用脉冲传送</p><ol><li>主要优点：<ul><li>只需要一条传输线</li><li>对长距离传输特别重要</li><li>成本比较低廉</li></ul></li><li>缺点：速度慢</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241405955.png" alt="image-20241124140543760"></p></li><li><p>并行传送</p><ol><li>特点：同时传送多个数据位</li><li>系统总线上传送的信息必须采用并行传送方式（出于速度和效率上的考虑）</li></ol></li><li><p>分时传送：分时传送即总线的分时复用，共享总线的部件分时使用总线</p></li></ol><h4 id="总线接口"><a href="#总线接口" class="headerlink" title="总线接口"></a>总线接口</h4><p>接口是CPU和主存、外设之间通过总线进行连接的逻辑部件</p><p>接口的典型功能：<strong>控制、缓冲、转换、整理、程序中断</strong>等。</p><p>一个适配器（即接口）的两个接口：一个同系统总线相连，采用并行方式，另外</p><p>一个同设备相连，可能采用并行方式或是串行方式。</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241408550.png" alt="image-20241124140808869"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241409654.png" alt="image-20241124140954175"></p><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><ol><li><p>单总线结构</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241411187.png" alt="image-20241124141137769"></p><ol><li><p>CPU、主存、I&#x2F;O设备（通过I&#x2F;O接口）都挂在一组总线上</p><p>2.运行I&#x2F;O设备之间、I&#x2F;O设备与主存之间直接交换信息</p></li><li><p>直接通信能力：CPU与主存可直接进行信息交换，CPU与外设可直接进行信息交换，无需经过中间设备的干预。</p></li><li><p>优点：结构简单，成本低，易于接入新的设备</p></li><li><p>缺点：带宽低，负载重，多个部件只能争用唯一的总线，不支持并发传送操作</p></li><li><p>使用要求：连接到总线上的逻辑部件必须高速运行，需要使用总线时，能迅速获得总线控制权；而当不再使用总线时，能迅速放弃总线控制权。否则，由于一条总线由多种功能部件共用，可能导致很大的时间延迟。</p></li></ol></li></ol><h1 id="数据的表示与运算"><a href="#数据的表示与运算" class="headerlink" title="数据的表示与运算"></a>数据的表示与运算</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fbfd556035d1515cb69fb9497f34cbe6.png" alt="在这里插入图片描述"></p><h2 id="2-1-数制与编码"><a href="#2-1-数制与编码" class="headerlink" title="2.1 数制与编码"></a>2.1 数制与编码</h2><h3 id="2-1-1-进位计数制及其相互转化"><a href="#2-1-1-进位计数制及其相互转化" class="headerlink" title="2.1.1 进位计数制及其相互转化"></a>2.1.1 进位计数制及其相互转化</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5586a24cc9076b70895dc628ea9be86a.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/61ec3b0ee1a4f9fc13d97168eab59bcd.png" alt="在这里插入图片描述"></p><h4 id="2-1-2-BCD码（Binary-Code-Decimal码）"><a href="#2-1-2-BCD码（Binary-Code-Decimal码）" class="headerlink" title="2.1.2 BCD码（Binary-Code Decimal码）"></a>2.1.2 BCD码（Binary-Code Decimal码）</h4><p>每一个十进制数看成4位2进制数</p><p>8421 每一位代表权重</p><p>5421</p><p>2421</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e45a2f6305f8d3f8e66d0aa3a77d2d9.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e29dab138174435e7cee71aca4e0a668.png" alt="在这里插入图片描述"></p><h5 id="字符编码ASCII码"><a href="#字符编码ASCII码" class="headerlink" title="字符编码ASCII码"></a>字符编码ASCII码</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/49b74cc4a0c0cfd36da3c125f6dcc9ac.png" alt="在这里插入图片描述"></p><h3 id="2-1-5-校验码"><a href="#2-1-5-校验码" class="headerlink" title="2.1.5 校验码"></a>2.1.5 校验码</h3><p>任意两个码字之间最少变化的二进制位数称为<strong>码距</strong>，码距大于等于2的数据校验码开始具有检错的能力。码距越大，检错、纠错能力越强。奇偶校验码的码距等于2,可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能检测出偶数位错误；海明码的码距大于2,因此不仅可以发现错误，还能指出错误的位置。仅靠增加奇偶校验位的位数不能提高正确性，还要考虑码距。</p><p>具有检、纠错能力的数据校验码的实现原理：在编码中，除合法码字外，再加入一些非法码字，当某个合法码字出现错误时，就变为非法码字。合理安排非法码字的数量和编码规则就能达到纠错的目的。</p><h5 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h5><p>奇校验码 加上校验位 1的个数为奇数个</p><p>偶校验码加上校验位 1的个数为偶数个</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a970ee36dbd145e24b24ae7465936371.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ecdbffc1c4bc3b60fe4c6f4aa8d2e7d2.png" alt="在这里插入图片描述"></p><h3 id="2-海明（汉明）校验码"><a href="#2-海明（汉明）校验码" class="headerlink" title="2.海明（汉明）校验码"></a>2.海明（汉明）校验码</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ef82d56a4c9123c1ac62b4960087b3d7.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c261e94fd65b5e3f3a031df84dca8759.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/23f22c043b055368a835173b17bab7c2.png" alt="在这里插入图片描述"></p><p>​<img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221040495.png" alt="image-20241122104000839"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221040873.png" alt="image-20241122104048405"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bbf970905e8ede6037ca72b5f87057f6.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd84a82040f97c80c743bc10bbbb46c0.png" alt="在这里插入图片描述"></p><h3 id="3-循环冗余校验（CRC）码"><a href="#3-循环冗余校验（CRC）码" class="headerlink" title="3. 循环冗余校验（CRC）码"></a>3. 循环冗余校验（CRC）码</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/249fbfb07d9f25b2bc8e40b54a57f41b.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/34535ed57e695cee662b0f6b33f8443f.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e79227259e72d22c83804c3b8f836e6e.png" alt="在这里插入图片描述"></p><p>这里可以进行异或运算</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1d91dfb26bed6bbac415fbb90f0ed223.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ede6ae9725ae977d507bee0a6bfc6763.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e9b7a972b8da33d2fcfa1b66226eaf1.png" alt="在这里插入图片描述"></p><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>1.无符号数和有符号数<br>计算机中参与运算的有两大类，<strong>有符号数和无符号数</strong><br>无符号数：机器字长全部二进制位均为数值位，没有符号位。<img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221138060.png" alt="image-20241122113841651"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221139350.png" alt="image-20241122113904133"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221141885.png" alt="image-20241122114151170">有符号数：</p><p>机器数：保存在计算机当中（原码表示法）</p><p>真值：带有正负号 0正1负 </p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221250451.png" alt="image-20241122124949269"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221254592.png" alt="image-20241122125419570"><br>$$<br>2^4 &#x3D; 10000<br>$$</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221406362.png" alt="image-20241122140626126"></p><p>补码：解决加减法归一化问题把减法转换成加法</p><p>正数：原码&#x3D;反码&#x3D;补码</p><p>负数  反码&#x3D;原码符号为不变，其余位取反，补码 &#x3D; 反码+1</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221419814.png" alt="image-20241122141924369"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221424665.png" alt="image-20241122142432006"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221435983.png" alt="image-20241122143524432"></p><h5 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h5><p>补码表示很难直接判断其真值大小</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221439906.png" alt="image-20241122143942325"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221442870.png" alt="image-20241122144209847"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221444032.png" alt="image-20241122144427209"></p><h3 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h3><h4 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h4><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221449852.png" alt="image-20241122144925594"></p><h4 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h4><ul><li>为什么要引入浮点数表示<ul><li>编程困难，程序员要调节小数点的位置；</li><li>数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长；</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221451336.png" alt="image-20241122145130956"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221453337.png" alt="image-20241122145327344"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221456126.png" alt="image-20241122145629928"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221459156.png" alt="image-20241122145914061"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221506255.png" alt="image-20241122150611964"></p><h3 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h3><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221510086.png" alt="image-20241122151003646"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221511254.png" alt="image-20241122151151182"></p><h3 id="算法移位"><a href="#算法移位" class="headerlink" title="算法移位"></a>算法移位</h3><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221522353.png" alt="image-20241122152228956"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221523789.png" alt="image-20241122152306490"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221524389.png" alt="image-20241122152435292"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221525063.png" alt="image-20241122152524774"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411221526890.png" alt="image-20241122152605732"></p><p>溢出判断</p><p><img src="/../images/image-20241122152748295.png" alt="image-20241122152748295"></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h4 id="在计算机中，为什么要采用二进制来表示数据？"><a href="#在计算机中，为什么要采用二进制来表示数据？" class="headerlink" title="在计算机中，为什么要采用二进制来表示数据？"></a>在计算机中，为什么要采用二进制来表示数据？</h4><ul><li><p>1)在计算机中，为什么要采用二进制来表示数据？</p><p>从可行性来说，采用二进制，只有0和1两个状态，能够表示0、1两种状态的电子器件很多，如开关的接通和断开、晶体管的导通和截止、磁元件的正负剩磁、电位电平的高与低等，都可表示0、1两个数码。使用二进制，电子器件具有实现的可行性。<br>从运算的简易性来说，二进制数的运算法则少，运算简单，使计算机运算器的硬件结构大大简化(十进制的乘法九九口诀表有55条公式，而二进制乘法只有4条规则)从逻辑上来说，由于二进制0和1正好和逻辑代数的假( false)和真(true)相对应，有逻辑代数的理论基础，用二进制表示二值逻辑很自然。</p></li></ul><h4 id="2-计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。"><a href="#2-计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。" class="headerlink" title="2)计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。"></a>2)计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。</h4><ul><li><p>2)计算机在字长足够的情况下能够精确地表示每个数吗？若不能，请举例说明。</p><p>计算机采用二进制来表示数据，在字长足够时，可以表示任何一个整数。而二进制表示小数时只能够用1(2)的和的任意组合表示，即使字长很长，也不可能精确表示出所有小数，只能无限逼近。例如0.1就无法用二进制精确地表示。</p></li></ul><h4 id="3-字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？"><a href="#3-字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？" class="headerlink" title="3)字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？"></a>3)字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？</h4><ul><li><p>3)字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别？</p><p>字长相同时，浮点数取字长的一部分作为阶码，所以表示范围比定点数要大，而取一部分作为阶码也就代表着尾数部位的有效位数减少，而定点数字长的全部位都用来表示数值本身，精度要比同字长的浮点数更大。</p></li></ul><h4 id="4-用移码表示浮点数的阶码有什么好处？"><a href="#4-用移码表示浮点数的阶码有什么好处？" class="headerlink" title="4)用移码表示浮点数的阶码有什么好处？"></a>4)用移码表示浮点数的阶码有什么好处？</h4><ul><li><p>4)用移码表示浮点数的阶码有什么好处？</p><p>移码的两个好处<br>①浮点数进行加减运算时，时常要比较阶码的大小，相对于原码和补码，移码比较大小更方便。<br>②检验移码的特殊值(0和max)时比较容易。阶码以移码编码时的特殊值如下。<strong>0</strong>:表示指数为负无穷大，相当于分数分母无穷大，整个数无穷接近0,在尾数也为0时可用来表示0:尾数不为零表示未正规化的数。<strong>max</strong>:表示指数正无穷大，若尾数为0,则表示浮点数超出表示范围（正负无穷大）；尾数不为0,则表示浮点数运算错误</p></li></ul><h4 id="在高级语言编程中所定义的-unsigned-short-int-long-float-double型数据是怎么表示的？什么称为无符号整数的“溢出”？"><a href="#在高级语言编程中所定义的-unsigned-short-int-long-float-double型数据是怎么表示的？什么称为无符号整数的“溢出”？" class="headerlink" title=".在高级语言编程中所定义的 unsigned&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double型数据是怎么表示的？什么称为无符号整数的“溢出”？"></a>.在高级语言编程中所定义的 unsigned&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double型数据是怎么表示的？什么称为无符号整数的“溢出”？</h4><ul><li><p>2.在高级语言编程中所定义的 unsigned&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double型数据是怎么表示的？什么称为无符号整数的“溢出”？</p><p>unsigned型数据就是无符号整数，不考虑符号位。直接用全部二进制位对数值进行编码得到的就是无符号数，一般都用补码表示。</p><p>int型数据就是定点整数，一般用补码表示。int型数据的位数与运行平台和编译器有关，一般是32位或16位。例如，真值是-12的int型整数，在机器内存储的机器数（假定用32位寄存器寄存）是1111-1111-1111-1111-1111-1111-1111-0100.</p><p>long型数据和short型数据也都是定点整数，只是位数不同，分别是长整型和短整型数，通常用补码表示。</p><p>float型数据是用来表示实数的浮点数。现代计算机用IEEE754标准表示浮点数，其中32位单精度浮点数就是float型，64位双精度浮点数就是 double型。</p><p>需要注意的是，C语言中的int型和 unsigned型变量的存储方式没有区别，都按照补码的形式存储，在不溢出范围内的加减法运算也是相同的，只是int型变量的最高位代表符号位，而unsigned型中的最高位表示数值位，两者在C语言中的区别体现在输出时到底是采用%d还是采用%u。</p><p>对于无符号定点整数来说，若寄存器位数不够，则计算机运算过程中一般保留低n位，舍弃高位。这样，会产生以下两种结果。<br>①保留的低n位数不能正确表示运算结果。在这种情况下，意味着运算的结果超出了计算机所能表达的范围，有效数值进到了第n+1位，称此时发生了“溢出”现象<br>②保留的低n位数能正确表达计算结果，即高位的舍去并不影响其运算结果。</p></li></ul><h4 id="对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？"><a href="#对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？" class="headerlink" title="对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？"></a>对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？</h4><ul><li><p>4.对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？</p><p>不是，可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数就是一定的。m位编码只能表示2m个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多(有时可能由于一个值有两个或多个编码对应，编码个数会有少量差异)。</p></li></ul><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/66b98e81fc90bfc3506c9467633e2ee8.png" alt="在这里插入图片描述"></p><h2 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h2><h4 id="3-1-1-存储器的分类"><a href="#3-1-1-存储器的分类" class="headerlink" title="3.1.1 存储器的分类"></a>3.1.1 存储器的分类</h4><p>相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项）去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。所以它是 按内容或地址进行寻址的，价格较为昂贵。 一般用<strong>来制作TLB、相联 Cache</strong>等。</p><p>按在计算机中的作用对存储器分类：</p><ul><li>主存储器,简称主存。CPU可以直接随机地对其进行访问，也可以和高速缓存器及辅助存储器交换数据。</li><li>辅助存储器,简称辅存，不能与CPU直接相连，用来存放当前暂时不用的程序和数据</li><li>高速缓冲存储器,位于主存和CPU之间，用来存放正在执行的程序段和数据</li></ul><p>按存储介质分类：</p><ul><li>磁表面存储器（磁盘，磁带），磁心存储器半导体存储器（MOS型存储器，双极存储器）和光存储器（光盘）。</li></ul><p>按存取方式分类：</p><ul><li>随机存储器（RAM）。存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存取单元的物理位置无关，主要用作主存或高速缓冲存储器。</li><li>只读存储器（ROM）。存储器的内容只能随机读出而不能写入。。即使断电，内容也不会丢失。</li><li>串行访问存储器。对存储单元进行读&#x2F;写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如<strong>磁带</strong>）与直接存取存储器（如<strong>磁盘</strong>）。</li></ul><p>按信息的可保存性分类：</p><p>断电后，存储信息即消失的存储器，称为<strong>易失性存储</strong>器，如RAM。断电后信息仍然保持的存储器，称为<strong>非易失性存储器</strong>，如ROM，磁表面存储器和光存储器。<strong>若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出；若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。</strong>具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0ad326410974404693b1611fa29a8899.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b69d4cba3caa693102dcbd1ceaa46b2b.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f543b20ba92e2b0f7b36027241668f37.png" alt="在这里插入图片描述"></p><h4 id="3-1-2-存储器的性能指标"><a href="#3-1-2-存储器的性能指标" class="headerlink" title="3.1.2 存储器的性能指标"></a>3.1.2 存储器的性能指标</h4><ol><li>存储容量：存储字数*字长</li><li>单位成本：每位价格&#x3D;总成本&#x2F;总容量</li><li>存储速度：数据传输率&#x3D;数据的宽度&#x2F;存储周期</li></ol><h3 id="3-2-存储器的层次结构"><a href="#3-2-存储器的层次结构" class="headerlink" title="3.2 存储器的层次结构"></a>3.2 存储器的层次结构</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d679ff8ea252bd55dc150e7192e63007.png" alt="在这里插入图片描述"></p><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c0da5ba7f02869ddb4946d76a475bbd1.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ba662c9ed01b6ed33ccaafaf9cceb1af.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/01a402cd59466ba8d78a84dc85e7b3c9.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/75311fdb93ed457c1a4d815dedc0d0a7.png" alt="在这里插入图片描述"></p><h3 id="3-3-半导体随机存储器"><a href="#3-3-半导体随机存储器" class="headerlink" title="3.3 半导体随机存储器"></a>3.3 半导体随机存储器</h3><h4 id="3-3-1-SRAM和DRAM"><a href="#3-3-1-SRAM和DRAM" class="headerlink" title="3.3.1 SRAM和DRAM"></a>3.3.1 SRAM和DRAM</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e5460ab4f1bfd43e2553d29986523916.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bafd8beffd2da2f327ae25594d8bce54.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0952215dccce3a125a3d23f46d66ba12.png" alt="在这里插入图片描述"></p><p>译码码驱动：线选法，重合法</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a94e96d6fbd602f22ce5009b593b4159.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8196643f948aba6fbcb84d2096abd038.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b80ae8ca6e1989312e1b56d9babc9574.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/67d9a67b5fb662c9539d9d98b61c46ee.png" alt="在这里插入图片描述"></p><h4 id="3-3-2-只读存储器"><a href="#3-3-2-只读存储器" class="headerlink" title="3.3.2 只读存储器"></a>3.3.2 只读存储器</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/64d34d40cce418724674050e12f718f1.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b441dc3a74080edd97b6c3d929ecdc64.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b441dc3a74080edd97b6c3d929ecdc64.png" alt="在这里插入图片描述"></p><h3 id="3-4-主存储器与CPU的连接"><a href="#3-4-主存储器与CPU的连接" class="headerlink" title="3.4 主存储器与CPU的连接"></a>3.4 主存储器与CPU的连接</h3><h4 id="3-4-2-主存容量的扩展"><a href="#3-4-2-主存容量的扩展" class="headerlink" title="3.4.2 主存容量的扩展"></a>3.4.2 主存容量的扩展</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/27cc715d7f1edaef7eefe834728a9f91.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fe0e728489330c379894f4c1846d7818.png" alt="在这里插入图片描述"></p><h5 id="2-字扩展"><a href="#2-字扩展" class="headerlink" title="2.字扩展"></a>2.字扩展</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ff121420aaeef4bb67dd9faa3e88c43.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c6c2896bdadcb8b76a967953713f894.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/84817bb7cbb74e127e7658b66fc7ef8b.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e1cf638a2a58f440c4c8916bddd317c8.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3d5e06ae818437e8c5d219eb22d63846.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6303cfeb16aee98b1f0356c9ba859846.png" alt="在这里插入图片描述"></p><h3 id="3-5-双端口RAM和多模块存储器"><a href="#3-5-双端口RAM和多模块存储器" class="headerlink" title="3.5 双端口RAM和多模块存储器"></a>3.5 双端口RAM和多模块存储器</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca200997a2c7b8316e60fa50e2348b5.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4b2bdf4b79975daefb6e0d3cf924a74e.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/692ea89e2fb1b8835b8814fd58d1bf86.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a4841cc3dfbb384cb7837adea1b56c6.png" alt="在这里插入图片描述"></p><h4 id="3-6-1-程序访问的局部性原理"><a href="#3-6-1-程序访问的局部性原理" class="headerlink" title="3.6.1 程序访问的局部性原理"></a>3.6.1 程序访问的局部性原理</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e832742d19e68be59b1e8cd21538c604.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b0118ba3bf0e00d9127d520f3bb7b4a7.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f6b83fb5fb8220f48d3285d78b8d5956.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f04787838a813b4eb48d401c242240cd.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f043f952cca03789fb4384d347038a03.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/806fcd43467a1e23af7492d6828b5a52.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f5bb151f88c68bf3e3f1615881ae6efa.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a5cd63d9f8053955cfa333d16b63f5d7.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b9eda1e34499c1a9a237fceae2f00365.png" alt="在这里插入图片描述"></p><p>SCI总线—-SCI（serial communication interface）由Motorola公司推出。是一种通用异步通信接口UART，与MCS-51的异步通信功能基本相同。</p><p> PCI总线—-PCI（peripheral component interconnect）<strong>总线是当前最流行的总线之一，</strong>它是由Intel公司推出的一种局部总线。它定义了32位数据总线，且可扩展为64位。是基于奔腾等新一代微处理器而发展的总线。</p><p> ISA总线—-ISA（industrial standard architecture）<strong>总线标准是IBM 公司1984年为推出PC&#x2F;AT机而建立的系统总线标准</strong>，所以也叫AT总线。它是对XT总线的扩展，以适应8&#x2F;16位数据总线要求。它在80286至80486时代应用非常广泛，以至于奔腾机中还保留有ISA总线插槽。ISA总线有98只引脚。 </p><p>VESA总线—-VESA（video electronics standard association）<strong>总线是 1992年由60家附件卡制造商联合推出的一种局部总线，简称为VL(VESA local bus)总线</strong>。它的推出为微机系统总线体系结构的革新奠定了基础。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><ol><li>计算机网络的基本概念从三个角度定义：</li></ol><ul><li>应用角度：强调资源共享和独立功能</li><li>物理角度：强调网络协议和硬件设备的组成</li><li>功能角度：强调通信手段和互联互通能力</li></ul><ol start="2"><li><p>计算机网络的发展经历了三个阶段：</p><ul><li><p>以主机为中心的终端系统</p></li><li><p>以通信子网为中心的计算机互连</p></li><li><p>标准化的网络体系结构</p></li></ul></li></ol><h3 id="计算机网络的术语包括："><a href="#计算机网络的术语包括：" class="headerlink" title="计算机网络的术语包括："></a>计算机网络的术语包括：</h3><ul><li>通信子网：传输网络，提供信息传输服务。</li><li>资源子网：主机集合，提供计算资源</li><li>边缘部分：由<strong>所有连接在因特网上的主机</strong>组成。这部分用户直接使用，用来进行通信（传送数据、音频或视频）和资源共享</li><li>核心部分：由<strong>大量网络和连接这些网络的路由器</strong>组成。这部分为边缘部分提供服务（提供连通性和交换）</li></ul><ol start="4"><li>结点、网络、主机</li></ol><ul><li>网络：由若干结点和连接这些结点的链路组成</li><li>互联网：互联网是”网络的网络”</li><li>主机：连接在网上的计算机都称为主机</li></ul><h3 id="计算机网络主要由三大组成部分：硬件、软件、协议"><a href="#计算机网络主要由三大组成部分：硬件、软件、协议" class="headerlink" title="计算机网络主要由三大组成部分：硬件、软件、协议"></a>计算机网络主要由三大组成部分：硬件、软件、协议</h3><ol><li>硬件<ul><li>网络节点：包括端节点（计算机）和中间节点（交换机、集中器、复用器、路由器、中继器）</li><li>通信链路：信息传输的通道，包括物理链路（传输介质）、逻辑链路（信道）</li></ul></li><li>软件<ul><li>包括各种实现<strong>资源共享</strong>的软件、为用户使用的各种工具软件</li><li>主要有<strong>通信软件</strong>（网络协议软件）、<strong>网络操作系统</strong>、网络管理&#x2F;安全控制软件、网络应用软件</li></ul></li><li>协议<ul><li>是<strong>计算机网络的核心</strong></li><li>协议规定了网络<strong>传输数据时所遵循的规则</strong></li></ul></li></ol><h3 id="计算机网络：功能"><a href="#计算机网络：功能" class="headerlink" title="计算机网络：功能"></a>计算机网络：功能</h3><ol><li><strong>数据通信</strong><ul><li>是计算机网络<strong>最基本和最重要的功能</strong></li><li>用来实现联网计算机之间的各种信息传输</li><li>实现将分散在不同地理位置的计算机联系起来</li><li>进行统一的调配、控制和管理</li><li>应用示例：文件传输、IP电话、email、视频会议、信息发布、交互式媒体、音乐</li></ul></li><li>资源共享<ul><li>包括软件共享、硬件共享、数据共享</li><li>使计算机网络中的资源互通有无、分工协作</li><li>从而极大地提高硬件资源、软件资源和数据资源的利用率</li></ul></li><li>提供高可靠性服务<ul><li>利用可替代的资源，提供连续的高可靠服务</li></ul></li><li>节省资金<ul><li>替代昂贵的大中型机系统</li></ul></li><li>分布式处理<ul><li>当计算机网络中的某个计算机系统负荷过重时</li><li>可以将其处理的某个复杂任务分配给网络中其他计算机系统</li><li>从而利用空闲计算机资源以提高整个系统的利用率</li></ul></li><li>其它功能<ul><li>实现电子化办公与服务</li><li>远程教育</li><li>娱乐等功能</li><li>满足了社会的需求，方便了人们学习、工作和生活</li><li>具有巨大的经济效益</li></ul></li></ol><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><h3 id="按地理范围划分"><a href="#按地理范围划分" class="headerlink" title="按地理范围划分"></a>按地理范围划分</h3><ol><li><p>广域网(WAN)</p><ul><li><p>范围：大、大于100KM</p></li><li><p>传输技术：宽带</p></li><li><p>通信质量：延迟大，出错率高</p></li><li><p>拓扑结构：不规则，<strong>点到点</strong>类型</p></li><li><p>是<strong>互联网的核心部分</strong>，任务是通过长距离运送主机所发送的数据</p></li></ul></li><li><p>城域网(MAN)</p><ul><li><p>范围：中等、小于100KM，<strong>一般是一个城市</strong>，可跨越几个街区甚至整个城市</p></li><li><p>传输技术：宽带、基带</p></li><li><p>拓扑结构：<strong>总线类型</strong></p></li></ul></li><li><p>局域网(LAN)</p><ul><li><p>范围：小、小于20KM</p></li><li><p>传输技术：基带，10-1000Mbps</p></li><li><p>通信质量：延迟低，出错率低（最低可达10⁻¹¹）</p></li><li><p><strong>拓扑结构：总线、环</strong></p></li><li><p>一般用微型计算机或工作站通过高速通信线路相连，地理上局限在较小的范围</p></li></ul></li><li><p>个域网(PAN)</p><ul><li><p>在个人工作的地方范围内的电子设备用无线技术连接起来，也称为<strong>无线个人区域网</strong>(WPAN)</p></li><li><p>范围很小，大约在10m左右</p></li><li><p>是一个<strong>低功率、小范围、低速率、低价格</strong>的电缆替代技术</p></li></ul></li></ol><h3 id="按通信传播方式划分"><a href="#按通信传播方式划分" class="headerlink" title="按通信传播方式划分"></a>按通信传播方式划分</h3><ol><li>点对点传输方式的网络<ol><li>每条物理线路连接一对计算机，由一对对机器间的多条传输线路构成</li><li>如果通信的两台主机之间没有直接连接的线路，那他们之间的分组传输就要通过中间节点的接收、存储和转发，直到目的节点。</li><li>拓扑结构为网状、环形、树形、星形等</li></ol></li><li>广播方式网络<ol><li>一台计算机发送的信息可被网络上所有的计算机接收</li><li>拓扑结构为总线形</li></ol></li></ol><h3 id="按拓扑结构划分"><a href="#按拓扑结构划分" class="headerlink" title="按拓扑结构划分"></a>按拓扑结构划分</h3><ol><li>星形结构<ol><li>网络有一个中心节点，其它节点与其构成点到点连接</li><li>特点：容易实现：传输介质一般都是采用双绞线，节点扩展、移动方便：扩展只需从集线器或交换机等集中设备中拔除一条线即可，维护容易：一个节点出现故障不会影响其它节点的连接，可任意拆走故障节点。网络传输数据快：例如1000Mbps、甚至10G以太网。</li></ol></li><li>树形结构<ol><li>网络由一个根结点、多个中间分支节点和叶子节点构成</li><li>信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换</li><li>特点：连结简单，维护方便，适用于汇集信息的应用要求。资源共享能力较低，可靠性不高，任何一个工作站或链路的故障都会影响整个网络的运行</li></ol></li><li>总线结构<ol><li>网络所有节点挂接到一条总线上，各节点共用总线带宽，采用广播式信道，需要有介质访问控制规程以防止冲突。</li><li>特点：组网费用低：不需要另外的互联设备，直接通过一条总线进行连接，扩展较灵活：需要扩展用户时只需要添加一个接线器即可，但所能连接的用户数量有限，维护容易：单个节点失效不影响整个网络的正常通信，但是如果总线一断，则整个网络或者相应主干网段就断了，一次仅能一个端用户发送数据，其他端用户必须等待到获得发送权。</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241048890.png" alt="image-20241124104823398"></p><ol start="4"><li><p>环形结构</p><ol><li>所有节点连接成一个闭合的环，<strong>结点之间为点到点连接</strong></li><li>一般仅适用于令牌网，<strong>传输介质一般是同轴电缆</strong></li><li>实现简单，投资小，功能简单，仅能当作一般的文件服务模式</li><li>环中数据只能单向传输，信息在每台设备上的延迟时间是固定的，特别适合实时控制的局域网系统</li><li>维护困难，扩展性能差：添加或移动节点时必须中断整个网络，在环的两端作好连接器才能连接</li></ol></li><li><p>全连接结构：<strong>点到点全连接</strong>，可靠性最高，建造成本也高，只适用于节点数很少的广域网中。</p></li><li><p>网状结构</p><ol><li>点到点部分连接</li><li>多用于广域网，由于连接的不完全性，需要有交换节点</li><li>系统可靠性高，比较容易扩展</li><li>结构复杂，每一结点都与多点进行连结</li><li>因此必须采用路由算法和流量控制方法</li><li>目前<strong>广域网基本上采用网状结构</strong></li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241053576.png" alt="image-20241124105305001"></p></li></ol><h1 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h1><h3 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h3><ol><li><p>分层</p><ol><li>结构清晰，简化设计与实现，便于更新与维护</li><li>使独立性和适应性增强，每层通过自己内部的功能实现一种特定的服务，并且只依赖自己的下层提供的服务</li></ol></li><li><p>分层原则</p><ol><li>各个层之间有清晰的边界，便于理解</li><li>每个层实现特定的功能，功能尽可能独立。当某一层具体实现方法更新时，只要保持上下层的接口不变，便不会对相邻层产生影响</li><li>层次的划分有利于国际标准协议的制定</li><li>层的数目应该适中：层数太少，每层协议太复杂，层数太多，则体系结构太复杂。</li></ol></li><li><p>计算机网络体系结构</p><ol><li>计算机网络中，<strong>层、协议和层间接口的集合被称为计算机网络体系结构</strong></li><li>分层结构与每层的功能</li><li>服务与层间接口</li><li>协议</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241059255.png" alt="image-20241124105938454"></p></li></ol><h3 id="协议、接口、服务"><a href="#协议、接口、服务" class="headerlink" title="协议、接口、服务"></a>协议、接口、服务</h3><ol><li>实体(Entity)<ol><li>定义：<strong>任何可以发送或接收信息的硬件或软件进程</strong>。这可以是具体的硬件设备，也可以是软件程序</li></ol></li><li>对等层(Peer Layer)<ol><li>两个不同系统的同级层次</li></ol></li><li>对等实体(Peer Entity)<ol><li>分别位于<strong>不同系统对等层中的两个实体</strong></li><li>对等实体之间可以进行通信和信息交换</li></ol></li><li>接口：相邻两层之间交互的界面，定义<strong>相邻两层之间的操作及下层对上层的服务</strong>。</li><li>服务：<strong>某一层及其以下各层的一种能力</strong>，通过<strong>接口提供给其相邻上层</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241101573.png" alt="image-20241124110152941"></p><h4 id="协议的三个要素"><a href="#协议的三个要素" class="headerlink" title="协议的三个要素"></a>协议的三个要素</h4><ol><li>语义：解释控制信息<strong>每个部分的意义</strong>，规定了需要发出<strong>何种控制信息</strong>以及完成的动作与响应</li><li>语法：是用户数据与控制信息的<strong>结构与格式</strong></li><li><strong>时序</strong>：是对事件发生顺序的详细说明（也可称为”<strong>同步</strong>“）</li></ol><h3 id="协议数据单元"><a href="#协议数据单元" class="headerlink" title="协议数据单元"></a>协议数据单元</h3><ol><li>概念:网络体系结构中，<strong><em>对等层</em>之间交换的信息报文</strong>统称为协议数据单元（PDU）</li><li>组成:PDU由<strong>协议控制信息</strong>（协议头）和<em><strong>数据</strong></em>（SDU）组成</li><li>协议控制信息:地址,序号,长度,分段标志,差错控制信息等.</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241106401.png" alt="image-20241124110621993"></p><ol start="4"><li>各层协议数据单元的名称<ol><li>传输层以上：报文（Message）</li><li>传输层：段（Segment）</li><li>网络层：分组或包（Packet）</li><li>数据链路层：帧（Frame）</li><li>物理层：比特（Bit）</li></ol></li></ol><h3 id="协议数据传送过程"><a href="#协议数据传送过程" class="headerlink" title="协议数据传送过程"></a>协议数据传送过程</h3><ol><li><p>PDU的封装过程</p><ol><li>下层把上层的PDU作为本层的数据(SDU)加以封装</li><li>然后加入本层的协议头部（和尾部）</li><li>形成本层的PDU</li></ol></li><li><p>数据的封装与拆封过程</p><ol><li>数据在源站<strong>自上而下递交的过程实际上就是不断封装的过程</strong></li><li>到达目的地后<strong>自下而上递交的过程就是不断拆封的过程</strong></li></ol></li><li><p>每一层只处理本层的协议头部</p></li><li><p>通信过程的关键特点</p><ol><li><strong>通信只在对等层间进行</strong>，非对等层之间不能互相”通信”</li><li>对等层实体之间实现的是<strong>虚拟的逻辑通信</strong>（间接的、逻辑的、虚拟的）</li><li><em><strong>下层向上层提供服务</strong></em></li><li><em><strong>上层依赖下层提供的服务</strong></em>来与其它主机上的对等层通信</li><li>实际通信在最底层完成</li></ol><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241113585.png" alt="image-20241124111309361"></p></li></ol><h3 id="两种体系结构"><a href="#两种体系结构" class="headerlink" title="两种体系结构"></a>两种体系结构</h3><h4 id="ISO-OSI标准体系结构"><a href="#ISO-OSI标准体系结构" class="headerlink" title="ISO&#x2F;OSI标准体系结构"></a>ISO&#x2F;OSI标准体系结构</h4><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241115239.png" alt="image-20241124111458942"></p><ol><li><p>物理层</p><ol><li><p>在物理媒体上正确地、透明地传送比特流</p></li><li><p>主要定义两种设备：</p><ol><li>数据终端设备(DTE)</li><li>数据通信设备(DCE)的物理和逻辑连接方法</li></ol></li><li><p>机械特性，电气特性，功能特性，过程特性</p></li></ol></li><li><p>数据链路层</p><ol><li>在两个相邻节点间传输数据，使之对网络层呈现为一条无错的链路</li><li>主要功能与服务：<ol><li>建立与拆除数据链路连接</li><li>组帧（帧封装，按顺序传送，处理返回的确认帧）</li><li>定界与同步（产生&#x2F;识别帧边界）</li><li><strong>差错检测&#x2F;恢复</strong></li><li><strong>流量控制</strong></li></ol></li></ol></li><li><p>网络层</p><ol><li>定义了能<strong>够标识所有结点的逻辑地址、路由实现的方式和学习的方式</strong></li><li>选择合适的路由，<strong>把分组从源端传送到目的端</strong></li><li>主要功能：<ul><li>流量控制：协调A的<strong>发送速度和B的接收速度</strong></li><li>差错控制：通信两结点之间约定特定的检错规则</li><li>拥塞控制：<strong>当网络处于拥塞状态时，采取措施缓解拥塞</strong></li><li>异构网络的连接：<strong>大量的异构网络通****过路由器相互连接起来</strong></li></ul></li></ol></li><li><p>传输层</p><ol><li>在源端与目的端之间提供可靠的透明数据传输</li><li>使上层服务用户不必关系通信子网的细节</li><li>主要功能：</li><li>地址映射：源端进程地址映射到网络地址</li><li>多路复用与分用：<ol><li>多个传输连接共用一条网络连接</li><li>一条传输连接使用多个网络连接</li><li>进行数据分段并在目的端重新组装 </li><li>传输连接的建立与释放：提供”面向连接”和”无连接”两种服务 </li><li>传输差错校验与恢复 </li><li>流量控制：防止数据传输过载</li></ol></li></ol></li><li><p>会话层</p><ol><li><p>允许不同主机上各进程之间的会话</p></li><li><p>利用传输层提供的端到端服务，向表示层提供增值服务</p></li><li><p>主要功能：</p><ul><li><p>建立同步：向表示层或用户进程提供建立连接并在连接上有序地传输数据</p></li><li><p>负责<strong>管理主机间的会话进程</strong></p></li><li><p>包括<strong>建立、管理以及终止进程间的会话</strong></p></li><li><p>使用校验点可使通信会话在通信失效时从校验点恢复通信，实现数据同步</p></li></ul></li></ol></li><li><p>表示层</p><ol><li>主要用于处理两个通信系统中<strong>交换信息的表示方式</strong></li><li>处理不同机器采用的编码和表示方法不同的问题</li><li>主要功能：</li></ol><ul><li><p>采用抽象的标准方法定义数据结构</p></li><li><p>采用标准的编码形式</p></li><li><p>提供数据压缩、加密和解密服务</p></li><li><p>关心面向应用的信息的语法和语义</p></li></ul></li><li><p>应用层</p></li></ol><h3 id="TCP-IP体系结构"><a href="#TCP-IP体系结构" class="headerlink" title="TCP&#x2F;IP体系结构"></a>TCP&#x2F;IP体系结构</h3><p>TCP&#x2F;IP协议采用4层体系结构，由下向上依次是：网络接口层，网际层，传输层，应用层，网络接口层</p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202411241308473.png" alt="image-20241124130838141"></p><ol><li>网络接口层<ol><li>是TCP&#x2F;IP模型的最底层，负责从主机或结点接收IP分组并将它们发送到指定物理网路上</li><li>相当于OSI参考模型的物理层和数据链路层</li><li>TCP&#x2F;IP标准并没有定义具体的网络接口协议，旨在提供灵活性</li><li>各物理网络可以使用自己的数据链路层协议和物理层协议</li><li>典型的物理网络类型：<ul><li>局域网：以太网、令环网、令牌总线网等</li><li>公共数据网络：电话网、SDH、X.25、帧中继和ATM等</li></ul></li><li>典型协议包括<ol><li>HDLC协议（高级数据链路控制协议）</li><li>PPP协议（点到点协议）</li><li>STP生成树协议</li><li>FR（帧中继协议）</li></ol></li></ol></li><li>网际层<ol><li>主要功能是消息寻址及把逻辑地址和名称转换成物理地址</li><li>通过判定从源计算机到目标计算机的路由</li><li>控制通信子网的操作</li><li>常用协议<ol><li>网络协议（IP）</li><li>网络控制报文协议ICMP</li><li>地址转换协议ARP</li><li>反向地址转换协议RARP</li><li>路由协议OSPF等</li></ol></li></ol></li><li>传输层<ol><li>主要功能是提供从一个应用程序（进程）到另一个应用程序（进程）的通信称为<strong>端对端的通信</strong></li><li><strong>端到端的通信</strong>实际是指从源进程发送数据到目标进程的通信过程</li></ol></li><li>传输层<ol><li>UDP协议（用户数据报协议）<ol><li>为应用程序提供一种无需建立连接就可以发送封装的IP数据报的方法</li><li>特点：无连接、不可靠</li></ol></li><li>TCP协议（传输控制协议）<ol><li>是一种面向连接的、可靠的、基于字节流的传输层通信协议</li><li>特点：面向连接、可靠传输、字节流传输</li></ol></li></ol></li><li>应用层<ol><li>FTP（文件传输协议）</li><li>Telnet（远程登录协议）</li><li>DNS（域名服务）</li><li>SMTP（简单邮件传输协议）</li><li>HTTP（超文件传输协议）</li></ol></li></ol><h3 id="TCP-IP与OSI模型比较"><a href="#TCP-IP与OSI模型比较" class="headerlink" title="TCP&#x2F;IP与OSI模型比较"></a>TCP&#x2F;IP与OSI模型比较</h3><ol><li>二者都采取分层的体系结构<ul><li>将庞大且复杂的问题划分为若干个较容易处理的、范围较小的问题</li><li>各层的功能也大体相似</li></ul></li><li>二者都是基于独立的协议的概念</li><li>二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信</li></ol><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>将两台 PC 机通过网卡用网线直接连接，应该采用哪种类型的双绞线？</p><p>以太网双绞连接线有两种：一种是广泛使用的直连接线，另一种是特殊情况下使用的交叉线，如果是pc连接交换机或其他网络接口等，或是其它连接的双方地位不对等的情况下都使用<strong>直连接线</strong>，而如果连接的两台设备是对等的，例如都是两台pc机，笔记本等，就要使用<strong>交叉线</strong>了，两者的差别是线序不一致，接口是一样的。 </p><p> 标准568A：绿白-1，绿-2，橙白-3，蓝-4，蓝白-5，橙-6，棕白-7，棕-8。 </p><p>  标准568B：橙白-1，橙-2，绿白-3，蓝-4，蓝白-5，绿-6，棕白-7，棕-8。 </p><p>  两端都是568A或者568B的双绞线是直通线；一端是568A，一端是568B的双绞线是交叉线。</p><p><strong>快速以太网</strong>是指100Mbps速率以上的<br>  单模光纤传输适合距离远，不会色散，传输可靠，但仅一个模式； </p><p>  多模光纤传输适合短距离，可以多个模式传输，但会发生色散，不够可靠；</p><p>串行通信：串行通信是指 使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度。其只需要少数几条线就可以在系统间交换信息，特别适用于计算机与计算机、计算机与外设之间的<strong>远距离通信</strong>。   </p><p>​    并行是指多比特数据同时通过并行线进行传送，这样数据传送<strong>速度大大提高</strong>，但并行传送的线路长度受到限制，因为长度增加，干扰就会增加，数据也就容易出错。   </p><p>路由器、网桥（交换机）和集线器分别工作于网络层、数据链路层和物理层</p><p>路由器可以隔绝广播域，也可以隔绝冲突域，交换机只能隔绝冲突域，不能隔绝广播域。集线器只起信号发达和转发的作用。  </p><p>交换机下不同的端口处于不同的冲突域中，但所有的端口都处于同一个广播域 </p><p>  1、骨干网：它由所有用户共享，负责传输骨干数据流。 </p><p>   2、接入网：提供通常说的最后一公里的连接——即用户和骨干网络之间的连接。 </p><p>T1载波的数据速率是1.544Mbps</p><p> E1载波的数据速率是2.048Mbps，<br> E2载波数据速率为8.448Mbps，<br> E3载波数据速率为34.368Mbps，<br> E4载波数据速率为139.24Mbps，<br> E5载波数据速率为565.148Mbps</p><p>  电路交换具有以下优缺点： </p><p>​    <strong>优点</strong>： （1）由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。 （2）通信双方之间的屋里通路一旦建立，双方可以随时通信，实时性强。（3）双方通信时按发送顺序传送数据，不存在失序问题。（4）电路交换既适用于传输模拟信号，也适用于传输数字信号。（5）电路交换的交换设备及控制均比较简单。 </p><p>​    分组交换具有以下优缺点。  </p><p>​     <strong>优点</strong>：（1）分组交换不需要为通信双反预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送分组。（2）由于采用存储转发方式，加之交换节点具有路径选择，当某条传输线路故障时可选择其他传输线路，提高了传输的可靠性。（3）通信双反不是固定的战友一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。（4）加速了数据在网络中的传输。因而分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了传输时间。（5）分组长度固定，相应的缓冲区的大小也固定，所以简化了交换节点中存储器的管理。（6）分组较短，出错几率减少，每次重发的数据量也减少，不仅提高了可靠性，也减少了时延。  </p><p>同轴电缆 只能数字信号。</p><p>  双绞线（twisted pair，TP） 双绞线，模拟信号，数字信号。传输距离最多100m，与同轴电缆相比，双绞线易受外部电磁波的干扰，线路本身也产生噪声，误码率较高</p><p>  屏蔽双绞线（英语：Shielded Twisted Pair，STP）,是一种广泛用于数据传输的铜质双绞线可以抗电磁干扰。 </p><p>  非屏蔽双绞线(UTP：Unshilded Twisted Pair) </p><p>光纤比屏蔽双绞线要好抗电磁干扰</p><p>Cisco路由器用于查看路由表信息的命令是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show run//看运行状况</span><br><span class="line">show ip route//看路由表 show int//看断口*</span><br><span class="line">show ip int br//看端口ip地址 show cdp nei//察看cdp邻居</span><br><span class="line">show ip pro//察看ip协议</span><br></pre></td></tr></table></figure><p>曼彻斯特编码的核心特点：</p><ol><li>编码规则：</li></ol><ul><li>1：高到低电平跳变</li><li>0：低到高电平跳变</li><li>每个码元中间必有跳变</li></ul><ol><li>技术特点：</li></ol><ul><li>自同步(信号跳变提供时钟)</li><li>无直流分量</li><li>便于检错(每位必有跳变)</li></ul><ol><li>缺点：</li></ol><ul><li>带宽占用大(是基带的2倍)</li><li>传输距离受限</li></ul><ol><li>改进版本： 差分曼彻斯特编码：用跳变的有无表示数据，抗干扰能力更强</li></ol><p>主要应用于以太网802.3标准和令牌环网络。</p><p>10BASE-T采用的物理拓扑结构是星型，逻辑拓扑结构是总线型 </p><p>100BASE-T 是逻辑物理都是星型结构 </p><p>450MHz系统：误差不得超过5×10^-6 (即20ppm) 900MHz系统：误差不得超过3×10^-6 (即4ppm)</p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>以太网的协议结构包括理层、数据链路层   数据链路层分层为逻辑链路控制子层（LLC）和媒体访问控制子层(MAC)。不同的物理层对应不同的MAC子层，LLC子层则完全独立。</p><p>ADSL(非对称数字用户线)是一种利用现有电话线路进行数据传输的宽带技术。其特点是:</p><ol><li>非对称传输:下行速率(最高24Mbps)远大于上行速率(最高1Mbps)</li><li>**频分复用:**：异步传输</li></ol><ul><li>低频段(0-4KHz):传输语音</li><li>中频段:上行数据</li><li>高频段:下行数据</li></ul><ol><li>通过电话线传输,无需重新布线,适合家庭宽带使用</li></ol><p>主要优点是可复用现有电话线路,成本低,但传输距离受限(通常不超过5.5公里)。</p><p>MAC地址也叫物理地址、硬件地址或链路地址，MAC地址则是48位的，IP地址才是32位的</p><p>MAC 地址是由 48 位二进制数组成，通常表示为 12 个十六进制数，每两个十六进制数为一组，中间用冒号或减号分隔。   </p><p><strong>网桥</strong>连接不同网段，是数据链路层设备，可以隔绝碰撞域    </p><p><img src="https://uploadfiles.nowcoder.com/images/20200217/969156946_1581908541437_131FA92C75D60B62AFCDCCF2872A039F" alt="img"></p><p>数据链路层一般都提供3种基本服务，即无确认的无连接服务、有确认的无连接服务、有确认 的面向连接的服务。 </p><p>  （1）无确认的无连接服务 无确认的无连接服务是源机器向目的机器发送独立的帧，而目的机器对收到的帧不作确认。 如果由于线路上的噪声而造成帧丢失，数据链路层不作努力去恢复它，恢复工作留给上层去完成。 这类服务适用于误码率很低的情况，也适用于像语音之类的实时传输，实时传输情况下有时数据延误比数据损坏影响更严重。 大多数局域网在数据链路层都使用无确认的无连接服务。 </p><p>  （2）有确认的无连接服务 这种服务仍然不建立连接，但是所发送的每一帧都进行单独确认。 以这种方式，发送方就会知道帧是否正确地到达。如果在某个确定的时间间隔内，帧没有到达，就必须重新发此帧。  </p><p>  （3）有确认的面向连接的服务 采用这种服务，源机器和目的机器在传递任何数据之前，先建立一条连接。 在这条连接上所发送的每一帧都被编上号，数据链路层保证所发送的每一帧都确实已收到。 而且，它保证每帧只收到一次，所有的帧都是按正确顺序收到的。面向连接的服务为网络进程间提供了可靠地传送比特流的服务。</p><p> IEEE 802.1—概述、体系结构和网络互连，以及网络管理和性能测量。</p><p> IEEE 802.2—逻辑链路控制LLC。最高层协议与任何一种局域网MAC子层的接口。</p><p> IEEE 802.3—CSMA&#x2F;CD网络，定义CSMA&#x2F;CD总线网的MAC子层和物理层的规范。</p><p> IEEE 802.4—令牌总线网。定义令牌传递总线网的MAC子层和物理层的规范。</p><p> IEEE 802.5—令牌环形网。定义令牌传递环形网的MAC子层和物理层的规范。</p><p> IEEE 802.6—城域网。</p><p> IEEE 802.7—宽带技术。</p><p> IEEE 802.8—光纤技术。</p><p> IEEE 802.9—综合话音数据局域网。</p><p> IEEE 802.10—可互操作的局域网的安全。</p><p> IEEE 802.11—无线局域网。</p><p> IEEE 802.12—优先高速局域网(100Mb&#x2F;s)。</p><p> IEEE 802.13—有线电视(Cable-TV)</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>逆地址解析协议（Reverse Address Resolution Protocol，RARP），是一种网络协议，互联网工程任务组（IETF）在RFC903中描述了RARP[1]。RARP使用与ARP相同的报头结构，作用与ARP相反。RARP用于将MAC地址转换为IP地址。其因为较限于IP地址的运用以及其他的一些缺点，因此渐为更新的BOOTP或DHCP所取代。<br>RARP的工作原理：</p><p>ARP和RARP属于网络层协议。但是工作内容属于数据链路层。 </p><ol><li>发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败</li></ol><p><img src="https://uploadfiles.nowcoder.com/files/20200802/963196997_1596363041239_20200802181023.png" alt="img"></p><p>IPv6首部的40字节包含以下字段：</p><ul><li>版本号：4位</li><li>通信量类：8位</li><li>流标签：20位</li><li>有效载荷长度：16位</li><li>下一个首部：8位</li><li>跳数限制：8位</li><li>源地址：128位（16字节）</li><li>目的地址：128位（16字节）</li></ul><p>网络中的三大表 MAC表 链路层交换机维护，记录着MAC地址与交换机接口的对应关系&hellip; ARP表 主机维护，ARP协议是网络层协议，负责ip地址与mac地址的映射 路由表，这个大家都懂，可以用netstat -r 或route查看</p><p>OSPF(Open Shortest Path First<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88">开放式最短路径优先</a>）是一个<a href="https://baike.baidu.com/item/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">内部网关协议</a>(Interior Gateway Protocol，简称IGP），用于在单一<a href="https://baike.baidu.com/item/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F">自治系统</a>（autonomous system,AS）内决策<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1">路由</a>。是对<a href="https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE">链路状态路由协议</a>的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。著名的迪克斯加算法(Dijkstra)被用来计算最短路径树。OSPF分为OSPFv2和OSPFv3两个版本,其中OSPFv2用在<a href="https://baike.baidu.com/item/IPv4">IPv4</a>网络，OSPFv3用在<a href="https://baike.baidu.com/item/IPv6">IPv6</a>网络。OSPFv2是由RFC 2328定义的，OSPFv3是由RFC 5340定义的。与<a href="https://baike.baidu.com/item/RIP">RIP</a>相比，OSPF是链路状态协议，而RIP是<a href="https://baike.baidu.com/item/%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E5%8D%8F%E8%AE%AE">距离矢量协议</a>。</p><p>OSPF（Open Shortest Path First打开最短路径）是内部网关协议。 BGP (Border Gateway Protocol边界网关协议)，是用于交换Internet路由信息的外部网关协议。 </p><p>因特网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。    </p><p>网络层提供的是一种无连接、不可靠但尽力而为的数据报传输服务，将数据报从原主机传送到目的主机。</p><p>A: 10.0.0.0~10.255.255.255 即10.0.0.0&#x2F;8 </p><p>B:172.16.0.0~172.31.255.255即172.16.0.0&#x2F;12 </p><p>C:192.168.0.0~192.168.255.255 即192.168.0.0&#x2F;16</p><p>静态路由是指由用户或网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。 直接路由是指路由器各网络接口所直连的网络之间进行通信所使用的路由。直接路由是在配置完路由器网络接口的IP地址后自动生成的，因此，如果没有对这些接口进行特殊的限制，这些接口所直连的网络之间就可以直接通信。</p><p>  局域网：以太网（Ethernet）、 令牌环网（Token Ring）、 光纤分布式接口网络（FDDI）环形拓扑、 异步传输模式网（ATM） 无线局域网（WLAN）。 </p><p>  广域网：QoS，公用电话交换网(PSTN)、分组交换网（X.25）、数字数据网（DDN）、帧中继（FR）、交换式多兆数据服务（SMDS）、异步传输模式（ATM）（主要用于广域网），ISDN，ADSL </p><p>  城域网：分布式队列双总线(DQDB) </p><p>帧中继网络使用 LMI(本地管理接口)协议监控 PVC 的状态。</p><p>LMI 协议主要功能：</p><ol><li>状态查询和通告</li><li>PVC可达性验证</li><li>拥塞通知</li><li>多播</li></ol><p>LMI 协议类型：</p><ul><li>Cisco</li><li>ANSI</li><li>ITU-T Q.933</li></ul><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><img src="https://uploadfiles.nowcoder.com/images/20170816/891535_1502864700025_4308DBEC28931D574B5E88B33BBCC75B" alt="img"></p><p>UDP报头只有四个域：源端口号，目的端口号，数据报长度，检验和。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>Telnet是位于OSI模型的第7层—应用层上的一种协议，是一个通过创建虚拟终端提供连接到远程主机终端仿真的TCP&#x2F;IP协议。这一协议需要通过用户名和口令进行认证，是Internet远程登陆服务的标准协议。应用Telnet协议能够把本地用户所使用的计算机变成远程主机系统的一个终端 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMTP：简单邮件传输协议，使用TCP连接，端口号为25，</span><br><span class="line">SNMP：简单网络管理协议，使用UDP 161端口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SNMP:(Simple Network Management Protocol)简单网络管理协议, 是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，它是一种应用层协议。 SNMP 使网络管理员能够管理网络效能，发现并解决网络问题以及规划网络增长。通过 SNMP 接收随机消息（及事件报告）网络管理系统获知网络出现问题。</span><br><span class="line">SNMP是一系列协议组和规范，它们提供了一种从网络上的设备中收集网络管理信息的方法，也为设备向网络管理工作站报告问题和错误提供了一种方法。</span><br></pre></td></tr></table></figure><p><strong>SNMP基于传输层UDP用户数据报协议</strong>，在管理者和被管理设备（确切的说是agent）之前传递信息。<br>SNMP管理包括下面三个部分：<br>1.MIB管理信息库<br>2.SMI管理信息的结构和标识（也称管理信息接口SMI）<br>3.SNMP简单网络管理协议</p><p>DNS：</p><p>最少情况：当本机DNS高速缓存中有该域名的DNS信息时，则不需要查询任何域名服务器，最少发出0次DNS查询。最多情况：因为均采用迭代查询方式，在最坏情况下，本地域名服务器需要依次迭代地向根域名服务器、顶级域名服务器（.com）、权限域名服务器（xyz.com）、权限域名服务器（abc.xyz.com）发出DNS查询请求，因此最多发出4次DNS查询。  </p><p>Socket通信中客户端和服务端的主要调用函数：</p><p>服务端：</p><ol><li>socket() - 创建套接字</li><li>bind() - 绑定地址</li><li>listen() - 监听连接</li><li>accept() - 接受连接</li><li>recv()&#x2F;send() - 接收&#x2F;发送数据</li><li>close() - 关闭连接</li></ol><p>客户端：</p><ol><li>socket() - 创建套接字</li><li>connect() - 连接服务器</li><li>send()&#x2F;recv() - 发送&#x2F;接收数据</li><li>close() - 关闭连接</li></ol><p>1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。</p><p> 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p><p> 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。</p><p>   2xx (成功)表示成功处理了请求的状态代码。</p><p> 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><p> 201 (已创建) 请求成功并且服务器创建了新的资源。</p><p> 202 (已接受) 服务器已接受请求，但尚未处理。</p><p> 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p><p> 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。</p><p> 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。</p><p> 206 (部分内容) 服务器成功处理了部分 GET 请求。</p><p>   3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p><p> 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p> 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</p><p> 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p> 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p><p> 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p><p> 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p><p> 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>   4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><p> 400 (错误请求) 服务器不理解请求的语法。</p><p> 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p> 403 (禁止) 服务器拒绝请求。</p><p> 404 (未找到) 服务器找不到请求的网页。</p><p> 405 (方法禁用) 禁用请求中指定的方法。</p><p> 406 (不接受) 无法使用请求的内容特性响应请求的网页。</p><p> 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。</p><p> 408 (请求超时) 服务器等候请求时发生超时。</p><p> 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p><p> 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。</p><p> 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。</p><p> 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。</p><p> 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p><p> 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。</p><p> 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。</p><p> 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。</p><p> 417 (未满足期望值) 服务器未满足”期望”请求标头字段的要求。</p><p>   5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p><p> 500 (服务器内部错误) 服务器遇到错误，无法完成请求。</p><p> 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p><p> 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。</p><p> 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。</p><p> 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p> 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DNS，Domain Name System或者Domain Name Service（域名系统或者余名服务）。域名系统为Internet上的主机分配域名地址和IP地址。用户使用域名地址，该系统就会自动把域名地址转为IP地址。 </span><br><span class="line">ADNS是硬件防火墙的意思. </span><br><span class="line">PDNS 本身是一个支持 mysql 数据库的 dns 服务器。</span><br><span class="line"></span><br><span class="line">TFTP 使用UDP</span><br><span class="line">FTP 使用TCP</span><br><span class="line">在给FTP服务器设计ACL时，在控制方面，端口号为21，一般用于登录认证，在数据传输方面，若为主动模式，则端口号为20；若为被动模式，则由服务端和客户端协商而定</span><br></pre></td></tr></table></figure><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><p>**MITM:**通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。 </p><p>  <strong>钓鱼攻击：</strong>一种企图从电子通讯中，<strong>通过伪装成信誉卓著的法人媒体以获得如用户名、密码和信用卡明细等个人敏感信息的犯罪诈骗过程。</strong>这些通信都声称（自己）来自社交网站拍卖网站\网络银行、电子支付网站\或网络管理者，以此来诱骗受害人的轻信。网钓通常是通过e-mail或者即时通讯进行。它常常导引用户到URL与界面外观与真正网站几无二致的假冒网站输入个人数据。就算使用强式加密的SSL服务器认证，要侦测网站是否仿冒实际上仍很困难。 </p><p>  <strong>水坑攻击</strong>：在受害者必经之路设置了一个“**水坑(陷阱)**”。最常见的做法是，黑客分析攻击目标的上网活动规律，寻找攻击目标经常访问的网站的弱点，先将此网站“攻破”并植入攻击代码，一旦攻击目标访问该网站就会“中招”。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库理论</title>
      <link href="/2024/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
      <url>/2024/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP</title>
      <link href="/2024/07/09/SpringAOP/"/>
      <url>/2024/07/09/SpringAOP/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202407092138687.png" alt="image-20240709213854654"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202407092139201.png" alt="image-20240709213910559"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202407092140582.png" alt="image-20240709213959285"></p><p><img src="https://raw.githubusercontent.com/a186232641/images/master/img/202407092141662.png" alt="image-20240709214103517"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql实战45讲读书笔记</title>
      <link href="/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一条SQL查询语句是如何执行的？"><a href="#一条SQL查询语句是如何执行的？" class="headerlink" title="一条SQL查询语句是如何执行的？"></a>一条SQL查询语句是如何执行的？</h2><p><img src="/../images/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p><ol><li><p>Server 层</p><ol><li>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等）</li></ol></li><li><p>存储引擎层</p><ol><li>存储引擎层负责数据的存储和提取</li><li>架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</li><li>执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB</li><li>你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表</li></ol></li></ol><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist #查看全部连接</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait_timeout #控制客户端无动静后最长的连接时间</span><br><span class="line">SHOW VARIABLES LIKE &#x27;wait_timeout&#x27;;</span><br><span class="line">SET GLOBAL wait_timeout = &lt;desired_timeout_in_seconds&gt;;</span><br></pre></td></tr></table></figure><p>连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><ol><li>长连接<ol><li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接</li></ol></li><li>短连接<ol><li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li></ol></li></ol><p>使用长连接后存在的问题</p><ol><li>内存占用太大被系统杀掉，mysql表现异常重启</li></ol><p>如何解决</p><ol><li>定期断开长连接。</li><li>MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>缓存以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p><strong>缓存失效非常快</strong></p><h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h3><ol><li><p>词法分析</p><ol><li>你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么</li><li>如识别”select”这个关键字</li></ol></li><li><p>语法分析</p><p>词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法</p></li></ol><h3 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h3><p>选择走哪个索引</p><h3 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h3><ol><li>检查执行权限<ol><li>无<ol><li>返回没有权限错误</li></ol></li><li>有<ol><li>调用存储引擎层接口</li></ol></li></ol></li></ol><h2 id="日志系统：一条SQL更新语句是如何执行的？"><a href="#日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="日志系统：一条SQL更新语句是如何执行的？"></a>日志系统：一条SQL更新语句是如何执行的？</h2><ol><li>更新语句会把表T上所有缓存结果都清空</li><li>分析器会通过词法和语法解析知道这是一条更新语句</li><li>优化器决定要使用ID这个索引。</li><li>执行器负责具体执行，找到这一行，然后更新</li></ol><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><p>redo log是<strong>InnoDB引擎特有的日志</strong></p><p>Redo log 比作粉板 mysql比作账本</p><p>粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体流程：</p><p>InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。</p><p>循环写</p><p>write pos是当前记录的位置一边写一边后移、checkpoint是当前要擦除的位置也是往后推移并且循环的，擦除记录前要把记录更新到数据文件</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong></p><p><img src="/../images/16a7950217b3f0f4ed02db5db59562a7.png" alt="img"></p><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog(归档日志)"></a>binlog(归档日志)</h4><ol><li><p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</p></li><li><p><strong>redo log</strong>是物理日志，记录的是“<strong>在某个数据页上做了什么修改</strong>”；<strong>binlog</strong>是逻辑日志，记录的是这个语句的原始逻辑，<strong>比如“给ID&#x3D;2这一行的c字段加1</strong> ”。</p></li><li><p>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ol><p>update语句的内部流程</p><p><img src="/../images/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img"></p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p> Redo Log 进入 Prepared 状态时，表示该事务的 Redo Log 已经被<strong>持久化到磁盘</strong>，但还没有提交。</p><p>通过将 binlog 持久化到磁盘</p><p>为什么需要两阶段提交？</p><p>redo log和binlog是两个<strong>独立的逻辑</strong>，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><ol><li><p><strong>先写redo log后写binlog</strong></p><p>假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的<strong>binlog里面就没有这条语句</strong>。</p><p>如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</p></li><li><p><strong>先写binlog后写redo log</strong></p></li></ol><p>​如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my.cnf</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line">sync_binlog = 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事务隔离：为什么你改了我还看不见？"><a href="#事务隔离：为什么你改了我还看不见？" class="headerlink" title="事务隔离：为什么你改了我还看不见？"></a>事务隔离：为什么你改了我还看不见？</h2><h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p><ol><li>脏读（dirty read）</li><li>不可重复读（non-repeatable read）</li><li>幻读（phantom read）</li></ol><p>SQL标准的事务隔离级别包括：</p><ol><li><p>读未提交（read uncommitted）</p><p>一个事务还没提交时，它做的变更就能被别的事务看到</p></li><li><p>读提交（read committed）</p><p>一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>可重复读（repeatable read）</p><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</p></li><li><p>串行化（serializable ）</p><p>对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure></li></ol><p><img src="/../images/7dea45932a6b722eb069d2264d0066f8.png" alt="img"></p><ol><li><p>读未提交</p><p>V1、V2、V3 都是2</p></li><li><p>读提交</p><p>V1&#x3D;1、V2、V3 都是2</p></li><li><p>可重复读</p><p>V1 v2都是1、 v3是2</p></li><li><p>串行化</p><p>事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。</p><p> V1、V2值是1，V3的值是2。</p></li></ol><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p><img src="/../images/d9c313809e5ac148fc39feff532f0fee.png" alt="img"></p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><p>这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><h4 id="什么时候删除回滚日志"><a href="#什么时候删除回滚日志" class="headerlink" title="什么时候删除回滚日志"></a>什么时候删除回滚日志</h4><p>在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p><h4 id="为什么建议你尽量不要使用长事务"><a href="#为什么建议你尽量不要使用长事务" class="headerlink" title="为什么建议你尽量不要使用长事务"></a>为什么建议你尽量不要使用长事务</h4><p>这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><h4 id="如何避免长事务"><a href="#如何避免长事务" class="headerlink" title="如何避免长事务"></a>如何避免长事务</h4><ol><li>确认是否使用了set autocommit&#x3D;0。确认是否使用了set autocommit&#x3D;0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</li><li>只读事务可以去掉</li><li>业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li><li>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警&#x2F;或者kill；</li><li>把innodb_undo_tablespaces设置成2（或更大的值）。</li></ol><h4 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h4><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li><li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit work and chain #提交事务并自动启动下一个事务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60#查找持续时间超过60s的事务</span><br></pre></td></tr></table></figure><h2 id="深入浅出索引（上）"><a href="#深入浅出索引（上）" class="headerlink" title="深入浅出索引（上）"></a>深入浅出索引（上）</h2><p>给表添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_username ON users (username);</span><br><span class="line">CREATE INDEX idx_username_email ON users (username, email);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建时添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">列定义后面使用 INDEX 或 KEY 关键字来实现。</span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    username VARCHAR(255),</span><br><span class="line">    email VARCHAR(255),</span><br><span class="line">    INDEX idx_username (username),</span><br><span class="line">    INDEX idx_email (email)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    username VARCHAR(255),</span><br><span class="line">    email VARCHAR(255),</span><br><span class="line">    KEY idx_username (username),</span><br><span class="line">    KEY idx_email (email)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何删除索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_username ON users;</span><br><span class="line">想删除 users 表上的 PRIMARY KEY 索引</span><br><span class="line">ALTER TABLE users DROP PRIMARY KEY;</span><br><span class="line">如果要删除的索引是唯一索引</span><br><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><p><img src="/../images/dcda101051f28502bd5c4402b292e38d.png" alt="img"></p><p>索引类型</p><ol><li><p>主键索引 ｜ 聚簇索引</p><p>主键索引的叶子节点存的是整行数据</p></li><li><p>非主键索引 ｜ 二级索引</p><p>非主键索引的叶子节点内容是主键的值</p></li></ol><p>查询非主键索引会查到主键id 然后从主键树中查找 id并返回数据，叫做回表</p><h4 id="基于主键索引和普通索引的查询有什么区别？"><a href="#基于主键索引和普通索引的查询有什么区别？" class="headerlink" title="基于主键索引和普通索引的查询有什么区别？"></a>基于主键索引和普通索引的查询有什么区别？</h4><ul><li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为<strong>回表</strong>。</li></ul><h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>如果插入id为400 但R5所在的页满，会导致页分裂</p><p>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>解决办法</p><ol><li>使用自增主键</li></ol><p>​自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p><p><strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><h2 id="深入浅出索引（下）"><a href="#深入浅出索引（下）" class="headerlink" title="深入浅出索引（下）"></a>深入浅出索引（下）</h2><p><img src="/../images/dcda101051f28502bd5c4402b292e38d-20240525220555522.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where k between 3 and 5</span><br></pre></td></tr></table></figure><ol><li>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</li><li>再到ID索引树查到ID&#x3D;300对应的R3；</li><li>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</li><li>再回到ID索引树查到ID&#x3D;500对应的R4；</li><li>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。</li></ol><p><strong>回到主键索引树搜索的过程，我们称为回表</strong></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>select ID from T where k between 3 and 5，这时只需要<strong>查ID的值</strong>，而<strong>ID的值已经在k索引树</strong>上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p><strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p><img src="/../images/89f74c631110cfbc83298ef27dcd6370.jpg" alt="img"></p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p><p>你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p><p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><h4 id="在建立联合索引的时候，如何安排索引内的字段顺序"><a href="#在建立联合索引的时候，如何安排索引内的字段顺序" class="headerlink" title="在建立联合索引的时候，如何安排索引内的字段顺序"></a><strong>在建立联合索引的时候，如何安排索引内的字段顺序</strong></h4><p>当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>在索引遍历过程中，对索引中包含的字段先做判断</p><p><img src="/../images/b32aa8b1f75611e0759e52f5915539ac.jpg" alt="img"></p><p>索引下推的执行流程</p><p><img src="/../images/76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="img"></p><h2 id="全局锁和表锁-：给表加个字段怎么有这么多阻碍？"><a href="#全局锁和表锁-：给表加个字段怎么有这么多阻碍？" class="headerlink" title="全局锁和表锁 ：给表加个字段怎么有这么多阻碍？"></a>全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h2><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><figure class="highlight plaintext"><figcaption><span>tables with read lock (FTWRL)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</span><br></pre></td></tr></table></figure><p>使用场景</p><p>全局锁的典型使用场景是，做全库逻辑备份</p><p>缺点</p><p>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</p><p>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</p><p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p>single-transaction方法只适用于所有的表使用事务引擎的库。**如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一</p><p><strong>既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢</strong>？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：</p><ul><li>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</li><li>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ol><li><p>表锁</p><ol><li>表锁的语法是 lock tables … read&#x2F;write、unlock tables主动释放锁也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li><li></li></ol></li><li><p>元数据锁(meta data lock，MDL)</p><p>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，<strong>保证读写的正确性</strong>。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<strong>表结构做变更</strong>，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>在MySQL 5.5版本中引入了MDL，当对一个表做<strong>增删改查操作的时候，加MDL读锁</strong>；当要对<strong>表做结构变更操作</strong>的时候，<strong>加MDL写锁</strong>。</p></li></ol><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p><img src="/../images/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg" alt="img"></p><ol><li>session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。</li><li>session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。</li><li>有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。</li><li>，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</li></ol><h4 id="如何安全地给小表加字段？"><a href="#如何安全地给小表加字段？" class="headerlink" title="如何安全地给小表加字段？"></a><strong>如何安全地给小表加字段？</strong></h4><ol><li><p>解决长事务</p></li><li><p>MySQL的information_schema 库的 innodb_trx 表你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p><ol><li><pre><code>use information_schemaselect * from innodb_trx<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">3. 你要变更的表是一个热点表，上面的请求很频繁，而你不得不加个字段，你该怎么做呢，alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好</span><br><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">   ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h2 id="事务到底是隔离的还是不隔离的？"><a href="#事务到底是隔离的还是不隔离的？" class="headerlink" title="事务到底是隔离的还是不隔离的？"></a>事务到底是隔离的还是不隔离的？</h2><p>一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</p><p><img src="/../images/823acf76e53c0bdba7beab45e72e90d6.png" alt="img"></p><p>begin&#x2F;start transaction 命令<strong>并不是一个事务的起点</strong>，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。如果你想要<strong>马上启动一个事务</strong>，可以使用start transaction with consistent snapshot 这个命令。</p><p>这里设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = 1;  -- 开启自动提交</span><br><span class="line">SET autocommit = 0;  -- 关闭自动提交</span><br></pre></td></tr></table></figure><p>在MySQL里，有两个“视图”的概念：</p><ul><li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。</li><li>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li></ul><h4 id="“快照”在MVCC里是怎么工作的？"><a href="#“快照”在MVCC里是怎么工作的？" class="headerlink" title="“快照”在MVCC里是怎么工作的？"></a>“快照”在MVCC里是怎么工作的？</h4><p>InnoDB里面每个事务有一个唯一的事务ID，叫作<strong>transaction id</strong>。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p><p>每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id</p><p>数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。</p><p><img src="/../images/68d08d277a6f7926a41cc5541d3dfced.png" alt="img"></p><p>虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。</p><p>语句更新会生成undo log（回滚日志）吗？那么，<strong>undo log在哪呢？</strong></p><p>图2中的三个虚线箭头，就是<strong>undo log；而V1、V2、V3并不是物理上真实存在的</strong>，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p><p> InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</p><p><img src="/../images/882114aaf55861832b4270d44507695e.png" alt="img"></p><p>对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p><ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol><p><strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p><p><img src="/../images/9416c310e406519b7460437cb0c5c149.png" alt="img"></p><p>从图中可以看到，**第一个有效更新是事务C，把数据从(1,1)改成了(1,2)**。这时候，这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。</p><p>第二个有效更新是事务B**，把数据从(1,2)改成了(1,3)**。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。</p><p>你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。</p><p>好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p><ul><li>找到(1,3)的时候，<strong>判断出row trx_id&#x3D;101</strong>，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为<strong>一致性读</strong>。</p><h3 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h3><p><strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p><img src="/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/images/86ad7e8abe7bf16505b97718d8ac149f.png" alt="img" style="zoom:75%;"><p>如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事<strong>务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操</strong>作。</p><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p><p>当前读。其实，除了update语句外，<strong>select语句如果加锁</strong>，也是当前读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select k from t where id=1 lock in share mode;</span><br><span class="line">select k from t where id=1 for update;</span><br></pre></td></tr></table></figure><p><img src="/../images/cda2a0d7decb61e59dddc83ac51efb6e.png" alt="img"></p><p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p><p>事务C’没提交，也就是说**(1,2)这个版本上的写锁还没释放<strong>。而事务B是</strong>当前读<strong>，必须</strong>要读最新版本，而且必须加锁<strong>，因此就被锁住了，必须等到</strong>事务C’释放这个锁**，才能继续它的当前读。</p><p><img src="/../images/540967ea905e8b63630e496786d84c92.png" alt="img"></p><h4 id="事务的可重复读的能力是怎么实现的？"><a href="#事务的可重复读的能力是怎么实现的？" class="headerlink" title="事务的可重复读的能力是怎么实现的？"></a>事务的可重复读的能力是怎么实现的？</h4><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><p>设置数据库的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure><h2 id="普通索引和唯一索引，应该怎么选择？"><a href="#普通索引和唯一索引，应该怎么选择？" class="headerlink" title="普通索引和唯一索引，应该怎么选择？"></a>普通索引和唯一索引，应该怎么选择？</h2><p><img src="/../images/1ed9536031d6698570ea175a7b7f9a46.png" alt="img"></p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p><strong>InnoDB的数据是按数据页为单位来读写的</strong>。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p><p>查找到索引所在的数据页，然后一条条比对</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><h5 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h5><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个<strong>数据页还没有在内存中的话</strong>，在不影响数据一致性的前提下，InooDB会将这些<strong>更新操作缓存在change buffer</strong>中，这样就不需要从磁盘中读入这个数据页了。</p><p>在下次查询需要访问这个数据页的时候，将数据页读入内存，然后<strong>执行change buffer中与这个页有关的操作</strong>。通过这种方式就能保证这个数据逻辑的正确性。</p><p>虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，<strong>change buffer在内存中有拷贝，也会被写入到磁盘上。</strong></p><p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为<strong>merge</strong>。</p><h5 id="什么条件下可以使用change-buffer呢？"><a href="#什么条件下可以使用change-buffer呢？" class="headerlink" title="什么条件下可以使用change buffer呢？"></a>什么条件下可以使用change buffer呢？</h5><p>对于<strong>唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束</strong>。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要将数据页读入内存才能判断。如果<strong>都已经读入到内存</strong>了，那<strong>直接更新内存会更快，就没必要使用change buffer</strong>了。</p><p>因此，唯一索引的更新就不能使用change buffer，实际上也只有<strong>普通索引可以使用</strong>。</p><p>change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数<strong>innodb_change_buffer_max_size</strong>来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><h4 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h4><p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将<strong>更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程</strong>。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，<strong>change buffer反而起到了副作用</strong>。</p><h4 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h4><p>普通索引和唯一索引应该怎么选择。其实，这两类索引在<strong>查询能力上是没差别的</strong>，主要考虑的是对<strong>更新性能的影响</strong>。所以，我建议你尽量选择普通索引。</p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p><p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p><h4 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h4><p><img src="/../images/980a2b786f0ea7adabef2e64fb4c4ca3.png" alt="img"></p><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1在内存中，直接更新内存；</li><li>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息</li><li>将上述两个动作记入redo log中（图中3和4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p><p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p><p><strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。</strong></p><h2 id="MySQL为什么有时候会选错索引？"><a href="#MySQL为什么有时候会选错索引？" class="headerlink" title="MySQL为什么有时候会选错索引？"></a>MySQL为什么有时候会选错索引？</h2><h4 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h4><p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。</p><p>当然，扫<strong>描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素</strong>进行综合判断。</p><p>我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在<strong>判断扫描行数</strong>的时候出问题了。</p><h4 id="扫描行数是怎么判断的？"><a href="#扫描行数是怎么判断的？" class="headerlink" title="扫描行数是怎么判断的？"></a><strong>扫描行数是怎么判断的？</strong></h4><p>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“<strong>基数</strong>”（cardinality）。</p><h5 id="MySQL是怎样得到索引的基数的呢？"><a href="#MySQL是怎样得到索引的基数的呢？" class="headerlink" title="MySQL是怎样得到索引的基数的呢？"></a>MySQL是怎样得到索引的基数的呢？</h5><p>nnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p><img src="/../images/e2bc5f120858391d4accff05573e1289.png" alt="img"></p><p>Q1的结果还是符合预期的，rows的值是104620；但是Q2的rows值是37116，偏差就大了。而图1中我们用explain命令看到的rows是只有10001行，是这个偏差误导了优化器的判断。</p><p>到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划不用，却选择了扫描行数是100000的执行计划呢？</p><p>这是因为，如果使用<strong>索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的</strong>。</p><p>优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t 可以用来重新统计索引信息</span><br></pre></td></tr></table></figure><h4 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h4><p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢？</p><p>一种方法是，像我们第一个例子一样，<strong>采用force index强行选择一个索引</strong>。**MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p><p><img src="/../images/9582401a6bed6cb8fd803c9555750b54.png" alt="img"></p><p>既然优化器放弃了使用索引a，说明a还不够合适，所以<strong>第二种方法就是，我们可以考虑修改语句，引导MySQL使用我们期望的索引。</strong>比如，在这个例子里，显然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。</p><p><img src="/../images/14cd598e52a2b72dd334a42603e5b894.png" alt="img"></p><p><strong>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</strong></p><h2 id="怎么给字符串字段加索"><a href="#怎么给字符串字段加索" class="headerlink" title="怎么给字符串字段加索"></a>怎么给字符串字段加索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table SUser add index index1(email);</span><br><span class="line">alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure><img src="/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/images/d31da662bee595991862c439a5567eb7.jpg" alt="img" style="zoom:50%;"><img src="/2024/05/24/mysql%E5%AE%9E%E6%88%9845%E8%AE%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/images/134583875561de914991fc2e192cf842.jpg" alt="img" style="zoom:50%;"><p>使用第一种查询到直接返回</p><p>第二种查询到需要再查ID 然后才返回</p><p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct email) as L from SUser;</span><br></pre></td></tr></table></figure><ol><li>直接创建完整索引，这样可能比较占用空间；</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li><li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li></ol><h2 id="为什么我的MySQL会“抖”一下？"><a href="#为什么我的MySQL会“抖”一下？" class="headerlink" title="为什么我的MySQL会“抖”一下？"></a>为什么我的MySQL会“抖”一下？</h2><p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p><p><img src="/../images/349cfab9e4f5d2a75e07b2132a301fda.jpeg" alt="img"></p><p>掌柜在什么情况下会把粉板上的赊账记录改到账本上？</p><ul><li><p>第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确的账目记录到账本中才行。这个场景，对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。我在第二讲画了一个redo log的示意图，这里我改成环形，便于大家理解。</p><p><img src="/../images/a25bdbbfc2cfc5d5e20690547fe7f2e5-20240601171530918.jpg" alt="img"></p></li><li><p>第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去。</p><ul><li>“内存不够用了，要先将脏页写到磁盘”，<strong>InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong><ul><li>第一种是，还没有使用的；</li><li>第二种是，使用了并且是干净页；</li><li>第三种是，使用了并且是脏页。</li><li>当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</li><li>这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。<br>你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：</li></ul></li></ul></li><li><p>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</p></li><li><p>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。<br>这样的效率最高。</p></li><li><p>第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。</p></li><li><p>第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。<br>这种场景，对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p></li></ul><h4 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h4><p>首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。</p><p>这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设置成磁盘的IOPS。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</p><h5 id="如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？"><a href="#如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？" class="headerlink" title="如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？"></a><strong>如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？</strong></h5><p>一个是脏页比例，一个是redo log写盘速度。数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%</p><p>InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      return 100;</span><br><span class="line">  return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。</p><p><strong>根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong></p><p><img src="https://static001.geekbang.org/resource/image/cc/74/cc44c1d080141aa50df6a91067475374.png" alt="img"></p><p>你就要合理地设置innodb_io_capacity的值，并且**平时要多关注脏页比例，不要让它经常接近75%**。</p><p>一旦一个查询请求需要在执行过程中<strong>先flush掉一个脏页时</strong>，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在<strong>准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</strong></p><p>在InnoDB中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p><p>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</p><h2 id="为什么表数据删掉一半，表文件大小不变"><a href="#为什么表数据删掉一半，表文件大小不变" class="headerlink" title="为什么表数据删掉一半，表文件大小不变?"></a>为什么表数据删掉一半，表文件大小不变?</h2><h4 id="参数innodb-file-per-table"><a href="#参数innodb-file-per-table" class="headerlink" title="参数innodb_file_per_table"></a>参数innodb_file_per_table</h4><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：</p><p>​这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</p><p>​这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。</p><p><strong>将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</strong></p><p>我们在删除整个表的时候，可以使用<strong>drop table命令回收表空间</strong>。但是，我们遇到的更多的删除<strong>数据的场景是删除某些行</strong>，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</p><h4 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h4><p><img src="/../images/f0b1e4ac610bcb5c5922d0b18563f3c8.png" alt="img"></p><p>们要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，<strong>可能会复用这个位置</strong>。但是，磁盘文件的大小并不会缩小。</p><p>现在，你已经知道了InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，会怎么样？</p><p>答案是，整个数据页就可以被复用了。</p><p><strong>数据页的复用跟记录的复用是不同的。</strong></p><p>记录的复用，只限于符合范围条件的数据。</p><p>R4这条记录被删除后，如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</p><p>而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID&#x3D;50的记录需要使用新页的时候，page A是可以被复用的。</p><p>如果<strong>相邻的两个数据页利用率都很小</strong>，系统就会把这两个页上的数据合到其中一个页上，<strong>另外一个数据页就被标记为可复用</strong>。</p><p>delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p><p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果<strong>数据是随机插入的</strong>，就可能造成索引的数据页分裂。</p><p><img src="/../images/8083f05a4a4c0372833a6e01d5a8e6ea.png" alt="img"></p><p>可以看到，由于page A满了，再插入一个ID是550的数据时，就不得不再申请一个新的页面page B来保存数据了。页分裂完成后，page A的末尾就留下了空洞（注意：实际上，可能不止1个记录的位置是空洞）。</p><p>更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</p><p>经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。</p><p><strong>重建表，就可以达到这样的目的。</strong></p><h4 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h4><p>你可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。</p><p>于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。显然地，表B的主键索引更紧凑，数据页的利用率也更高。如果我们把表B作为临时表，数据从表A导入表B的操作完成后，用表B替换A，从效果上看，就起到了收缩表A空间的作用。</p><p>你可以使用alter table A engine&#x3D;InnoDB命令来重建表。在MySQL 5.5版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自动完成转存数据、交换表名、删除旧表的操作。</p><p><img src="/../images/02e083adaec6e1191f54992f7bc13dcd.png" alt="img"></p><p>图3</p><p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个DDL不是Online的。</p><p><strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</li><li>用临时文件替换表A的数据文件。</li></ol><p><img src="/../images/2d1cfbbeb013b851a56390d38b5321f0.png" alt="img"></p><p>图4</p><p>DDL之前是要拿MDL写锁的，这样还能叫Online DDL吗？</p><p>确实，图4的流程中，alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</p><p>alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</p><p>什么要退化呢？为了实现Online，MDL读锁不会阻塞增删改操作。</p><p>那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。</p><p>而对于一个大表来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说，就可以认为是Online的。</p><p>上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗IO和CPU资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的<strong>gh-ost</strong>来做。</p><h4 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h4><p>我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临时表，是在server层创建的。</p><p>根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p><p>所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？</p><p>答案是不能。因为，tmp_file也是要占用临时空间的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=inplace;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t engine=innodb,ALGORITHM=copy;</span><br></pre></td></tr></table></figure><p>当你使用ALGORITHM&#x3D;copy的时候，表示的是强制拷贝表，对应的流程就是图3的操作过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add FULLTEXT(field_name);</span><br></pre></td></tr></table></figure><p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。</p><ol><li>DDL过程如果是Online的，就一定是inplace的；</li><li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li></ol><ul><li>从MySQL 5.6版本开始，<strong>alter table t</strong> engine &#x3D; InnoDB（也就是recreate）默认的就是上面图4的流程了；</li><li><strong>analyze table t</strong> 其实不是重建表，只是对<strong>表的索引信息做重新统计</strong>，没有修改数据，这个过程中加了MDL读锁；</li><li><strong>optimize table t 等于recreate+analyze。</strong></li></ul><h4 id="什么时候使用alter-table-t-engine-InnoDB会让一个表占用的空间反而变大。"><a href="#什么时候使用alter-table-t-engine-InnoDB会让一个表占用的空间反而变大。" class="headerlink" title="什么时候使用alter table t engine&#x3D;InnoDB会让一个表占用的空间反而变大。"></a>什么时候使用alter table t engine&#x3D;InnoDB会让一个表占用的空间反而变大。</h4><ol><li>就是这个表，本身就已经没有空洞的了，比如说刚刚做过一次重建表操作。<ol><li>将表t重建一次；</li><li>插入一部分数据，但是插入的这些数据，用掉了一部分的预留空间；</li><li>这种情况下，再重建一次表t，就可能会出现问题中的现象。</li></ol></li></ol><h2 id="count-这么慢，我该怎么办？"><a href="#count-这么慢，我该怎么办？" class="headerlink" title="count(*)这么慢，我该怎么办？"></a>count(*)这么慢，我该怎么办？</h2><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)的实现方式"></a>count(*)的实现方式</h3><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把<strong>数据一行一行地从引擎里面读出来，然后累积计数</strong>。</li></ul><p>这里是没有加where条件的，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p><h4 id="为什么InnoDB不跟MyISAM一样，也把数字存起来呢？"><a href="#为什么InnoDB不跟MyISAM一样，也把数字存起来呢？" class="headerlink" title="为什么InnoDB不跟MyISAM一样，也把数字存起来呢？"></a><strong>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</strong></h4><p>这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。这里，我用一个算count(*)的例子来为你解释一下。</p><p><img src="/../images/5e716ba1d464c8224c1c1f36135d0e97.png" alt="img"></p><p>三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同。</p><p>这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是<strong>MVCC来实现的</strong>。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p><p>你知道的，InnoDB是索引组织表，主键索引树的叶子节点是数据，而<strong>普通索引树的叶子节点是主键值</strong>。所以，普通索引树比主键索引树小很多。对于count(<em>)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，<strong>MySQL优化器会找到最小的那棵树来遍历</strong>。*<em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</em></em></p><h4 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h4><p>你可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？</p><p>没错，缓存系统可能会丢失更新。</p><p>Redis的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后你要从存储redis数据的地方把这个值读回来，而<strong>刚刚加1的这个计数操作却丢失了</strong>。</p><p>比如，Redis异常重启以后，到<strong>数据库里面单独执行一次count(*)获取真实的行数</strong>，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，<strong>这一次全表扫描的成本，还是可以接受的。</strong></p><p>但是还是会有不一致的情况</p><p><img src="/../images/39898af053695dad37227d71ae288e33.png" alt="img"></p><p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p><h4 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h4><p><img src="/../images/9e4170e2dfca3524eb5e92adb8647de3.png" alt="img"></p><p>我们来看下现在的执行结果。虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p><p>因此，会话B看到的结果里， <strong>查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</strong></p><h4 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h4><p>这里，首先你要弄清楚count()的语义。<strong>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加</strong>。最后返回累计值</p><p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于count(字段)来说</strong>：</p><ol><li>如果这个<strong>“字段”是定义为not null的话</strong>，<strong>一行行地从记录里面读出这个字段，判断不能为null，按行累加</strong>；</li><li>如果这个“字段”<strong>定义允许为null</strong>，那么执行的时候，<strong>判断到有可能是null</strong>，还要把值取出来再判断一下，<strong>不是null才累加</strong>。</li></ol><p><strong>count(*)是例外</strong></p><p>并不会把全部字段取出来，而是专门做了优化，不取值。<strong>count(*)肯定不是null的字段</strong>，按行累加。</p><p>按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(*)，所以我建议你，尽量使用count(*)。</p><h2 id="日志和索引相关问题"><a href="#日志和索引相关问题" class="headerlink" title="日志和索引相关问题"></a>日志和索引相关问题</h2><h4 id="日志相关问题"><a href="#日志相关问题" class="headerlink" title="日志相关问题"></a>日志相关问题</h4><p>binlog（归档日志）和redo log（重做日志）配合崩溃恢复的时候，用的是反证法，说明了<strong>如果没有两阶段提交</strong>，会导致MySQL出现主备数据不一致等问题。</p><h4 id="在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？"><a href="#在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？" class="headerlink" title="在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？"></a>在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？</h4><p><img src="/../images/ee9af616e05e4b853eba27048351f62a.jpg" alt="img"></p><p><strong>两个“commit”的概念</strong></p><ul><li>他说的“commit语句”，是指MySQL语法中，用于提交一个事务的命令。一般跟begin&#x2F;start transaction 配对使用。</li><li>而我们图中用到的这个“commit步骤”，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了。</li><li>“commit语句”执行的时候，会包含“commit 步骤”。</li></ul><h4 id="在两阶段提交的不同时刻，MySQL异常重启会出现什么现象"><a href="#在两阶段提交的不同时刻，MySQL异常重启会出现什么现象" class="headerlink" title="在两阶段提交的不同时刻，MySQL异常重启会出现什么现象"></a><strong>在两阶段提交的不同时刻，MySQL异常重启会出现什么现象</strong></h4><p>如果在图中时刻A的地方，也就是<strong>写入redo log 处于prepare阶段</strong>之后、<strong>写binlog之前，发生了崩溃（crash）</strong>，由于<strong>此时binlog还没写，redo log也还没提交</strong>，所以<strong>崩溃恢复的时候，这个事务会回滚</strong>。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。</p><p>主要集中在时刻B，也就是<strong>binlog写完，redo log还没commit前发生crash</strong>，那崩溃恢复的时候MySQL会怎么处理？</p><h5 id="我们先来看一下崩溃恢复时的判断规则"><a href="#我们先来看一下崩溃恢复时的判断规则" class="headerlink" title="我们先来看一下崩溃恢复时的判断规则"></a>我们先来看一下崩溃恢复时的判断规则</h5><ol><li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li><li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li></ol><h4 id="MySQL怎么知道binlog是完整的"><a href="#MySQL怎么知道binlog是完整的" class="headerlink" title="MySQL怎么知道binlog是完整的?"></a>MySQL怎么知道binlog是完整的?</h4><p>一个事务的binlog是有完整格式的：</p><ul><li><p>s<strong>tatement格式</strong>的binlog，<strong>最后会有COMMIT</strong>；</p></li><li><p><strong>row格式的binlog</strong>，最后会有一个<strong>XID event</strong>。</p></li><li><p>在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。</p><h2 id="redo-log-和-binlog是怎么关联起来的"><a href="#redo-log-和-binlog是怎么关联起来的" class="headerlink" title="redo log 和 binlog是怎么关联起来的?"></a>redo log 和 binlog是怎么关联起来的?</h2><p>它们有一个<strong>共同的数据字段，叫XID</strong>。崩溃恢复的时候，会按顺序扫描redo log：</p></li><li><p>如果碰到既有prepare、又有commit的redo log，就直接提交；</p></li><li><p>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。有事务则提交，没有则会滚</p></li></ul><h2 id="处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计"><a href="#处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计" class="headerlink" title="处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?"></a>处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?</h2><p>在时刻B，也就是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个binlog恢复出来的库）使用。</p><p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p><h4 id="如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h4><p>其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。</p><p>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。</p><p>对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回滚不了，数据和binlog日志又不一致了。</p><p>两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。</p><h4 id="不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"></a>不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？</h4><p>这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？</p><p>不可以</p><p>InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log好了。</p><p><img src="/../images/eb838b87e9c20fa00aca50ef154f2a63.jpg" alt="img"></p><p>og还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢复“数据页”。</p><p>引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经认为提交完成了，不会再应用一次binlog1。</p><p>InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要<strong>依赖于日志</strong>来恢复数据页。</p><h3 id="那能不能反过来，只用redo-log，不要binlog？"><a href="#那能不能反过来，只用redo-log，不要binlog？" class="headerlink" title="那能不能反过来，只用redo log，不要binlog？"></a>那能不能反过来，只用redo log，不要binlog？</h3><p>如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。</p><p>redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。</p><p>MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。</p><h4 id="redo-log一般设置多大？"><a href="#redo-log一般设置多大？" class="headerlink" title="redo log一般设置多大？"></a>redo log一般设置多大？</h4><p>如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文件、每个文件1GB吧</p><h4 id="正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？"><a href="#正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？" class="headerlink" title="正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？"></a>正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？</h4><p>redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由redo log更新过去”的情况。</p><ol><li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。</li><li>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li></ol><h4 id="redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？"><a href="#redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？" class="headerlink" title="redo log buffer是什么？是先修改内存，还是先写redo log文件？"></a>redo log buffer是什么？是先修改内存，还是先写redo log文件？</h4><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into t1 ...</span><br><span class="line">insert into t2 ...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。</p><p>所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时候，数据的内存被修改了，redo log buffer也写入了日志。</p><p>但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。</p><h3 id="order-by”是怎么工作的？"><a href="#order-by”是怎么工作的？" class="headerlink" title="order by”是怎么工作的？"></a>order by”是怎么工作的？</h3><h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。</p><p><img src="/../images/826579b63225def812330ef6c344a303.png" alt="img"></p><p>Extra这个字段中的“U<strong>sing filesort”表示的就是需要排序</strong>，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p><p><img src="/../images/5334cca9118be14bde95ec94b02f0a3e.png" alt="img"></p><p>图2 city字段的索引示意图</p><ol><li>满足city&#x3D;’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。</li><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li><li>对<strong>sort_buffe</strong>r中的数据按照字段name做快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p><img src="/../images/6c821828cddf46670f9d56e126e3e772.jpg" alt="img"></p><p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数<strong>sort_buffer_size</strong>。</p><p><strong>sort_buffer_size</strong>，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但<strong>如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序</strong>。</p><h4 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h4><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><h5 id="如果MySQL认为排序的单行长度太大会怎么做呢？"><a href="#如果MySQL认为排序的单行长度太大会怎么做呢？" class="headerlink" title="如果MySQL认为排序的单行长度太大会怎么做呢？"></a><strong>如果MySQL认为排序的单行长度太大会怎么做呢？</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET max_length_for_sort_data = 16;</span><br></pre></td></tr></table></figure><p>max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。</p><p>city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我们再来看看计算过程有什么改变。</p><p>新的算法放入sort_buffer的字段，<strong>只有要排序的列（即name字段）和主键id。</strong></p><ol><li>初始化sort_buffer，确定放入两个字段，即name和id；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li><li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name进行排序；</li><li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li></ol><p>这个执行流程的示意图如下，我把它称为rowid排序。</p><p><img src="/../images/dc92b67721171206a302eb679c83e86d.jpg" alt="img"></p><p>对比图3的全字段排序流程图你会发现，rowid排序多访问了一次表t的主键索引，就是步骤7。</p><p>最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><h4 id="全字段排序-VS-rowid排序"><a href="#全字段排序-VS-rowid排序" class="headerlink" title="全字段排序 VS rowid排序"></a>全字段排序 VS rowid排序</h4><p>如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><p><strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p><p>rowid排序会要求回表多造成磁盘读，因此不会被优先选择。</p><p>并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的。</strong></p><p><img src="/../images/f980201372b676893647fb17fac4e2bf.png" alt="img"></p><p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city&#x3D;’杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。</p><ol><li>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name)取下一个记录主键id；</li><li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li><li><img src="/../images/3f590c3a14f9236f2d8e1e2cb9686692.jpg" alt="img"></li></ol><p><img src="/../images/fc53de303811ba3c46d344595743358a.png" alt="img"></p><p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一下。</p><h3 id="如何正确地显示随机消息？"><a href="#如何正确地显示随机消息？" class="headerlink" title="如何正确地显示随机消息？"></a>如何正确地显示随机消息？</h3><h4 id="从一个单词表中随机选出三个单词"><a href="#从一个单词表中随机选出三个单词" class="headerlink" title="从一个单词表中随机选出三个单词"></a>从一个单词表中随机选出三个单词</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><p>这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点复杂的。</p><p><img src="/../images/59a4fb0165b7ce1184e41f2d061ce350.png" alt="img"></p><p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。</p><p>Extra的意思就是，需要临时表，并且需要在临时表上排序。</p><p><strong>对于InnoDB表来说</strong>，执行全字段排序会减少磁盘访问，因此会被优先选择。</p><p><strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘</strong>。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL这时就会选择rowid排序。</p><h5 id="MySQL的表是用什么方法来定位“一行数据”的？"><a href="#MySQL的表是用什么方法来定位“一行数据”的？" class="headerlink" title="**MySQL的表是用什么方法来定位“一行数据”的？"></a>**MySQL的表是用什么方法来定位“一行数据”的？</h5><p>如果把一个InnoDB表的主键删掉，是不是就没有主键，就没办法回表了？</p><p>如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键。</p><p>这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的InnoDB表来说，这个rowid就是主键ID；</li><li>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</li><li>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个rowid其实就是数组的下标。</li></ul><p><strong>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p><h4 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h4><p>tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p>磁盘临时表使用的引擎默认是InnoDB，是由参数<strong>internal_tmp_disk_storage_engine</strong>控制的。</p><p>磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程</p><p>我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把 max_length_for_sort_data 设置成16。</p><h3 id="为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>为什么这些SQL语句逻辑相同，性能却差异巨大？</h3><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><p>如果对字段做了函数计算，就用不上索引了，这是MySQL的规定。</p><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><p>优化器并不是要放弃使用这个索引。</p><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表扫描。你可能也发现了，tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做类型转换。</p><h5 id="数据类型转换的规则是什么？"><a href="#数据类型转换的规则是什么？" class="headerlink" title="数据类型转换的规则是什么？"></a>数据类型转换的规则是什么？</h5><p>这里有一个简单的方法，看 select “10” &gt; 9的结果：</p><ol><li>如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1；</li><li>如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是0。</li></ol><p><img src="/../images/2b67fc38f1651e2622fe21d49950b214.png" alt="img"></p><p>在MySQL中，字符串和数字做比较的话，是将<strong>字符串转换成数字</strong>。</p><h4 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h4><p>这两个表的字符集不同，一个是utf8，一个是utf8mb4，所以做表连接查询的时候用不上关联字段的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail where tradeid=$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p> 在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成utf8mb4，再跟L2做比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; </span><br><span class="line">连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</span><br></pre></td></tr></table></figure><p>每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习惯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `table_a` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `b` varchar(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>有100万行数据，其中有10万行数据的b的值是’1234567890’， 假设现在执行语句是这么写的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_a where b=&#x27;1234567890abcd&#x27;;</span><br></pre></td></tr></table></figure><p>最理想的情况是，MySQL看到字段b定义的是varchar(10)，那肯定返回空呀。可惜，MySQL并没有这么做。</p><p>那要不，就是把’1234567890abcd’拿到索引里面去做匹配，肯定也没能够快速判断出索引树b上并没有这个值，也很快就能返回空结果。</p><p>但实际上，MySQL也不是这么做的。</p><p>这条SQL语句的执行很慢，流程是这样的：</p><ol><li>在传给引擎执行的时候，做了字符截断。因为引擎里面这个行只定义了长度是10，所以只截了前10个字节，就是’1234567890’进去做匹配；</li><li>这样满足条件的数据有10万行；</li><li>因为是select *， 所以要做10万次回表；</li><li>但是每次回表以后查出整行，到server层一判断，b的值都不是’1234567890abcd’;</li><li>返回结果是空。</li></ol><h3 id="为什么我只查一行的语句，也执行这么慢？"><a href="#为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="为什么我只查一行的语句，也执行这么慢？"></a>为什么我只查一行的语句，也执行这么慢？</h3><h4 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id=1;</span><br></pre></td></tr></table></figure><p>一般碰到这种情况的话，大概率是表t被锁住了。接下来分析原因的时候，一般都是首先执行一下命</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br></pre></td></tr></table></figure><p>令，看看当前语句处于什么状态。</p><h4 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h4><p>就是使用show processlist命令查看Waiting for table metadata lock的示意图。</p><p><img src="/../images/5008d7e9e22be88a9c80916df4f4b328.png" alt="img"></p><p><strong>这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了</strong></p><p><strong>session A 通过lock table命令持有表t的MDL写锁，而session B的查询需要获取MDL读锁。所以，session B进入等待状态。</strong></p><p>但是，由于<strong>在show processlist</strong>的结果里面，session A的Command列是“Sleep”，导致查找起来很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需要设置performance_schema&#x3D;on，相比于设置为off会有10%左右的性能损失)</p><p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p><p><img src="/../images/74fb24ba3826e3831eeeff1670990c01.png" alt="img"></p><h4 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h4><p>现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用法，一般有以下两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables t with read lock;</span><br><span class="line"></span><br><span class="line">flush tables with read lock;</span><br></pre></td></tr></table></figure><p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。</p><p>在session A中，我故意每行都调用一次sleep(1)，这样这个语句默认要执行10万秒，在这期间表t一直是被session A“打开”着。然后，session B的flush tables t命令再要去关闭表t，就需要等session A的查询结束。这样，session C要再次查询的话，就会被flush 命令堵住了。</p><p>图7是这个复现步骤的show processlist结果。这个例子的排查也很简单，你看到这个show processlist的结果，肯定就知道应该怎么做了。</p><p><img src="/../images/398407014180be4146c2d088fc07357e.png" alt="img"></p><h4 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id=1 lock in share mode; </span><br></pre></td></tr></table></figure><p><img src="/../images/3e68326b967701c59770612183277475.png" alt="img"></p><p>由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的select语句就会被堵住。</p><p><img src="/../images/3c266e23fc307283aa94923ecbbc738f.png" alt="img"></p><p>显然，session A启动了事务，占有写锁，还不提交，是导致session B被堵住的原因。</p><p>这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是MySQL 5.7版本，可以通过sys.innodb_lock_waits 表查到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t sys.innodb_lock_waits where locked_table=`&#x27;test&#x27;.&#x27;t&#x27;`\G</span><br></pre></td></tr></table></figure><h4 id="查询慢"><a href="#查询慢" class="headerlink" title="查询慢"></a>查询慢</h4><p>经过了重重封“锁”，我们再来看看一些查询慢的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c=50000 limit 1;</span><br></pre></td></tr></table></figure><p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。</p><p>你可以看一下慢查询日志。注意，这里为了把所有语句记录到slow log里，我在连接后先执行了 set long_query_time&#x3D;0，将慢查询日志的时间阈值设置为0。</p><p>：<strong>坏查询不一定是慢查询</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id=1；</span><br></pre></td></tr></table></figure><p><img src="/../images/66f26bb885401e8e460451ff6b0c0746.png" alt="img"></p><p>虽然扫描行数是1，但执行时间却长达800毫秒。</p><p><img src="https://static001.geekbang.org/resource/image/bd/d2/bde83e269d9fa185b27900c8aa8137d2.png" alt="img"></p><p>如果我把这个slow log的截图再往下拉一点，你可以看到下一个语句，select * from t where id&#x3D;1 lock in share mode，执行时扫描行数也是1行，执行时间是0.2毫秒。</p><p>看上去是不是更奇怪了？按理说lock in share mode还要加锁，时间应该更长才对啊。</p><p>你看到了，session A先用start transaction with consistent snapshot命令启动了一个事务，之后session B才开始执行update 语句。</p><p>session B执行完100万次update语句后，id&#x3D;1这一行处于什么状态呢？你可以从图16中找到答案。<img src="/../images/84667a3449dc846e393142600ee7a2ff.png" alt="img"></p><p><img src="/../images/46bb9f5e27854678bfcaeaf0c3b8a98c.png" alt="img"></p><p>session B更新完100万次<strong>，生成了100万个回滚日志(undo log)。</strong></p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p><p>undo log里记录的其实是“把2改成1”，“把3改成2”这样的操作逻辑，画成减1的目的是方便你看</p><h3 id="幻读是什么，幻读有什么问题？"><a href="#幻读是什么，幻读有什么问题？" class="headerlink" title="幻读是什么，幻读有什么问题？"></a>幻读是什么，幻读有什么问题？</h3><p><img src="/../images/5bc506e5884d21844126d26bbe6fa68b.png" alt="img"></p><p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</p><p>面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。</p><p>因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。并且，session B和sessionC的两条语句，执行后就会提交，所以Q2和Q3就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。</p><h4 id="幻读有什么问题？"><a href="#幻读有什么问题？" class="headerlink" title="幻读有什么问题？"></a>幻读有什么问题？</h4><p>session A在T1时刻就声明了，“我要把所有d&#x3D;5的行锁住，不准别的事务进行读写操作”。而实际上，这个语义被破坏了。</p><p><img src="/../images/7a9ffa90ac3cc78db6a51ff9b9075607.png" alt="img"></p><p>session B的第二条语句update t set c&#x3D;5 where id&#x3D;0，语义是“我把id&#x3D;0、d&#x3D;5这一行的c值，改成了5”。</p><p>由于在T1时刻，session A 还只是给id&#x3D;5这一行加了行锁， 并没有给id&#x3D;0这行加上锁。因此，session B在T2时刻，是可以执行这两条update语句的。这样，就破坏了 session A 里Q1语句要锁住所有d&#x3D;5的行的加锁声明。</p><p>session C也是一样的道理，对id&#x3D;1这一行的修改，也是破坏了Q1的加锁声明。</p><p><strong>其次，是数据一致性的问题。</strong></p><p>锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p><p><img src="/../images/dcea7845ff0bdbee2622bf3c67d31d92.png" alt="img"></p><ol><li>经过T1时刻，id&#x3D;5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的;</li><li>经过T2时刻，id&#x3D;0这一行变成(0,5,5);</li><li>经过T4时刻，表里面多了一行(1,5,5);</li><li>其他行跟这个执行序列无关，保持不变。</li></ol><p>这些数据也没啥问题，但是我们再来看看这时候binlog里面的内容。</p><ol><li>T2时刻，session B事务提交，写入了两条语句；</li><li>T4时刻，session C事务提交，写入了两条语句；</li><li>T6时刻，session A事务提交，写入了update t set d&#x3D;100 where d&#x3D;5 这条语句。</li></ol><p>我统一放到一起的话，就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update t set d=5 where id=0; /*(0,0,5)*/</span><br><span class="line">update t set c=5 where id=0; /*(0,5,5)*/</span><br><span class="line"></span><br><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c=5 where id=1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">update t set d=100 where d=5;/*所有d=5的行，d改成100*/</span><br></pre></td></tr></table></figure><p>好，你应该看出问题了。这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。</p><p>也就是说，id&#x3D;0和id&#x3D;1这两行，发生了数据不一致。这个问题很严重，是不行的。</p><h5 id="这个数据不一致到底是怎么引入的？"><a href="#这个数据不一致到底是怎么引入的？" class="headerlink" title="这个数据不一致到底是怎么引入的？"></a><strong>这个数据不一致到底是怎么引入的？</strong></h5><p>select * from t where d&#x3D;5 for update这条语句只给d&#x3D;5这一行，也就是id&#x3D;5的这一行加锁”导致的。</p><p><img src="/../images/34ad6478281709da833856084a1e3447.png" alt="img"></p><p>由于session A把所有的行都加了写锁，所以session B在执行第一个update语句的时候就被锁住了。需要等到T6时刻session A提交以后，session B才能继续执行。</p><p>这样对于id&#x3D;0这一行，在数据库里的最终结果还是 (0,5,5)。在binlog里面，执行序列是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c=5 where id=1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">update t set d=100 where d=5;/*所有d=5的行，d改成100*/</span><br><span class="line"></span><br><span class="line">update t set d=5 where id=0; /*(0,0,5)*/</span><br><span class="line">update t set c=5 where id=0; /*(0,5,5)*/</span><br></pre></td></tr></table></figure><p>但同时你也可以看到，id&#x3D;1这一行，在数据库里面的结果是(1,5,5)，而根据binlog的执行结果是(1,5,100)，也就是说幻读的问题还是没有解决。为什么我们已经这么“凶残”地，把所有的记录都上了锁，还是阻止不了id&#x3D;1这一行的插入和更新呢？</p><p>原因很简单。在T3时刻，我们给所有行加锁的时候，id&#x3D;1这一行还不存在，不存在也就加不上锁。</p><p><strong>也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，</strong>这也是为什么“幻读”会被单独拿出来解决的原因。</p><p>到这里，其实我们刚说明完文章的标题 ：幻读的定义和幻读有什么问题。</p><p>接下来，我们再看看InnoDB怎么解决幻读的问题。</p><h4 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h4><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是**间隙锁(Gap Lock)**。</p><p>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，这就产生了7个间隙。</p><p>在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</p><p>数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。</p><p>比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。</p><p><img src="/../images/c435c765556c0f3735a6eda0779ff151.png" alt="img"></p><p>但是间隙锁不一样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>间隙锁之间都不存在冲突关系。</p><p><img src="/../images/7c37732d936650f1cda7dbf27daf7498.png" alt="img"></p><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p><p><strong>间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。</strong></p><p><img src="/../images/df37bf0bb9f85ea59f0540e24eb6bcbe.png" alt="img"></p><ol><li>session A 执行select … for update语句，由于id&#x3D;9这一行并不存在，因此会加上间隙锁(5,10);</li><li>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</li><li>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</li></ol><p>两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。</p><p><strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong></p><p>今天和你分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这，也是现在不少公司使用的配置组合。</p><p>他们公司就使用的是读提交隔离级别加binlog_format&#x3D;row的组合。他曾问他们公司的DBA说，你为什么要这么配置。DBA直接答复说，因为大家都这么用呀。</p><h3 id="为什么我只改一行的语句，锁这么多？"><a href="#为什么我只改一行的语句，锁这么多？" class="headerlink" title="为什么我只改一行的语句，锁这么多？"></a>为什么我只改一行的语句，锁这么多？</h3><p><strong>我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><h4 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h4><p>由于表t中没有id&#x3D;7的记录，所以用我们上面提到的加锁规则判断一下的话：</p><ol><li>根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</li><li>同时根据优化2，这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</li></ol><p>所以，session B要往这个间隙里面插入id&#x3D;8的记录会被锁住，但是session C修改id&#x3D;10这行是可以的。</p><h4 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h4><p><img src="/../images/465990fe8f6b418ca3f9992bd1bb5465.png" alt="img"></p><ol><li>根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。</li><li>要注意c是普通索引，因此仅访问c&#x3D;5这一条记录是不能马上停下来的，需要向右遍历，查到c&#x3D;10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。</li><li>但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c&#x3D;5这个等值条件，因此退化成间隙锁(5,10)。</li><li>根据原则2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么session B的update语句可以执行完成。</li><li>锁是加在索引上的；同时，它给我们的指导是，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将session A的查询语句改成select d from t where c&#x3D;5 lock in share mode。你可以自己验证一下效果。</li></ol><h4 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=10 for update;</span><br><span class="line">mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure><p>id定义为int类型，这两个语句就是等价的吧？其实，它们并不完全等价。<img src="/../images/30b839bf941f109b04f1a36c302aea80.png" alt="img"></p><ol><li>开始执行的时候，要找到第一个id&#x3D;10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id&#x3D;10这一行的行锁。</li><li>范围查找就往后继续找，找到id&#x3D;15这一行停下来，因此需要加next-key lock(10,15]。</li></ol><p>所以，session A这时候锁的范围就是主键索引上，行锁id&#x3D;10和next-key lock(10,15]。这样，session B和session C的结果你就能理解了。</p><h4 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h4><p><img src="/../images/7381475e9e951628c9fc907f5a57697a.png" alt="img"></p><p>这次session A用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p><p>所以从结果上来看，sesson B要插入（8,8,8)的这个insert语句时就被堵住了。</p><p>这里需要扫描到c&#x3D;15才停止扫描，是合理的，因为InnoDB要扫到c&#x3D;15，才知道不需要继续往后找了</p><h4 id="唯一索引范围锁bug"><a href="#唯一索引范围锁bug" class="headerlink" title="唯一索引范围锁bug"></a>唯一索引范围锁bug</h4><p><img src="/../images/b105f8c4633e8d3a84e6422b1b1a316d.png" alt="img"></p><p>session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id&#x3D;15这一行就应该停止了。</p><p>但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id&#x3D;20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。</p><p>所以你看到了，session B要更新id&#x3D;20这一行，是会被锁住的。同样地，session C要插入id&#x3D;16的一行，也会被锁住。</p><p>照理说，这里锁住id&#x3D;20这一行的行为，其实是没有必要的。因为扫描到id&#x3D;15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个bug。</p><h4 id="非唯一索引上存在”等值”的例子"><a href="#非唯一索引上存在”等值”的例子" class="headerlink" title="非唯一索引上存在”等值”的例子"></a>非唯一索引上存在”等值”的例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(30,10,30);</span><br></pre></td></tr></table></figure><p><img src="/../images/c1fda36c1502606eb5be3908011ba159.png" alt="img"></p><p>可以看到，虽然有两个c&#x3D;10，但是它们的主键值id是不同的（分别是10和30），因此这两个c&#x3D;10的记录之间，也是有间隙的。</p><p>图中我画出了索引c上的主键id。为了跟间隙锁的开区间形式进行区别，我用(c&#x3D;10,id&#x3D;30)这样的形式，来表示索引上的一行。</p><p>现在，我们来看一下案例六。</p><p>这次我们用delete语句来验证。注意，delete语句加锁的逻辑，其实跟select … for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。</p><p><img src="/../images/b55fb0a1cac3500b60e1cf9779d2da78.png" alt="img"></p><p>这时，session A在遍历的时候，先访问第一个c&#x3D;10的记录。同样地，根据原则1，这里加的是(c&#x3D;5,id&#x3D;5)到(c&#x3D;10,id&#x3D;10)这个next-key lock。</p><p>然后，session A向右查找，直到碰到(c&#x3D;15,id&#x3D;15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c&#x3D;10,id&#x3D;10) 到 (c&#x3D;15,id&#x3D;15)的间隙锁。</p><p>也就是说，这个delete语句在索引c上的加锁范围，就是下图中蓝色区域覆盖的部分。</p><p><img src="/../images/bb0ad92483d71f0dcaeeef278f89cb24.png" alt="img"></p><p>这个蓝色区域左右两边都是虚线，表示开区间，即(c&#x3D;5,id&#x3D;5)和(c&#x3D;15,id&#x3D;15)这两行上都没有锁。</p><h4 id="limit-语句加锁"><a href="#limit-语句加锁" class="headerlink" title="limit 语句加锁"></a>limit 语句加锁</h4><p><img src="/../images/afc3a08ae7a254b3251e41b2a6dae02e.png" alt="img"></p><p>这个例子里，session A的delete语句加了 limit 2。你知道表t里c&#x3D;10的记录其实只有两条，因此加不加limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B的insert语句执行通过了，跟案例六的结果不同。</p><p>这是因为，案例七里的delete语句明确加了limit 2的限制，因此在遍历到(c&#x3D;10, id&#x3D;30)这一行之后，满足条件的语句已经有两条，循环就结束了。</p><p>因此，索引c上的加锁范围就变成了从（c&#x3D;5,id&#x3D;5)到（c&#x3D;10,id&#x3D;30)这个前开后闭区间</p><h4 id="一个死锁的例子"><a href="#一个死锁的例子" class="headerlink" title="一个死锁的例子"></a>一个死锁的例子</h4><p>是按照next-key lock的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock实际上是间隙锁和行锁加起来的结果。</p><p><img src="/../images/7b911a4c995706e8aa2dd96ff0f36506.png" alt="img"></p><ol><li><p>session A 启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10] 和间隙锁(10,15)；</p></li><li><p>session B 的update语句也要在索引c上加next-key lock(5,10] ，进入锁等待；</p></li><li><p>然后session A要再插入(8,8,8)这一行，被session B的间隙锁锁住。由于出现了死锁，InnoDB让session B回滚。</p></li><li><p>其实是这样的，session B的“加next-key lock(5,10] ”操作，实际上分成了两步，先是加(5,10)的间隙锁，加锁成功；然后加c&#x3D;10的行锁，这时候才被锁住的。</p><p>也就是说，我们在分析加锁规则的时候可以用next-key lock来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p><h3 id="MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>MySQL有哪些“饮鸩止渴”提高性能的方法？</h3><h4 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h4><p><strong>第一种方法：先处理掉那些占着连接但是不工作的线程。</strong></p><p>max_connections的计算，不是看谁在running，是只要连着就占用一个计数位置。对于那些不需要保持的连接，我们可以通过kill connection主动踢掉。这个行为跟事先设置wait_timeout的效果是一样的。设置wait_timeout参数表示的是，一个线程空闲wait_timeout这么多秒之后，就会被MySQL直接断开连接。</p><p><strong>第二种方法：减少连接过程的消耗。</strong></p><h4 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h4><ol><li>索引没有设计好；<ol><li>在备库B上执行 set sql_log_bin&#x3D;off，也就是不写binlog，然后执行alter table 语句加上索引；</li><li>执行主备切换；</li><li>这时候主库是B，备库是A。在A上执行 set sql_log_bin&#x3D;off，然后执行alter table 语句加上索引。</li></ol></li><li>SQL语句没写好；</li><li>MySQL选错了索引。<ol><li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把long_query_time设置成0，确保每个语句都会被记录入慢查询日志；</li><li>在测试表里插入模拟线上的数据，做一遍回归测试；</li><li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。（我们在前面文章中已经多次用到过Rows_examined方法了，相信你已经动手尝试过了。如果还有不明白的，欢迎给我留言，我们一起讨论）。</li></ol></li></ol><h4 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h4><ol><li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。</li></ol><h3 id="MySQL是怎么保证数据不丢的？"><a href="#MySQL是怎么保证数据不丢的？" class="headerlink" title="MySQL是怎么保证数据不丢的？"></a>MySQL是怎么保证数据不丢的？</h3><h4 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h4><p>binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。</p><p>系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态如图1所示。</p><p><img src="/../images/9ed86644d5f39efb0efec595abb92e3e.png" alt="img"></p><p>可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。</p><ul><li>图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li><li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</li></ul><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><p>因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。</p><p>但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p></li></ol><h4 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h4><p>redo log buffer里面的内容，是不是每次生成后都要直接持久化到磁盘呢？</p><p>​如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</p><p>另外一个问题是，事务还没提交的时候，redo log buffer中的部分日志有没有可能被持久化到磁盘呢？</p><p>答案是，确实会有。</p><p><img src="/../images/9d057f61d3962407f413deebc80526d4.png" alt="img"></p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢多了。</p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><h2 id="MySQL有哪些“饮鸩止渴”提高性能的方法？-1"><a href="#MySQL有哪些“饮鸩止渴”提高性能的方法？-1" class="headerlink" title="MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><h3 id="短连接风暴-1"><a href="#短连接风暴-1" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>max_connections</p><p><strong>先处理掉那些占着连接但是不工作的线程。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br><span class="line">kill connection + id</span><br></pre></td></tr></table></figure><p><strong>第二种方法：减少连接过程的消耗。</strong></p><h4 id="慢查询性能问题-1"><a href="#慢查询性能问题-1" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h4><ol><li>索引没有设计好；</li><li>SQL语句没写好；</li><li>MySQL选错了索引。</li></ol><h4 id="QPS突增问题-1"><a href="#QPS突增问题-1" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h4><h2 id="MySQL是怎么保证数据不丢的？-1"><a href="#MySQL是怎么保证数据不丢的？-1" class="headerlink" title="MySQL是怎么保证数据不丢的？"></a>MySQL是怎么保证数据不丢的？</h2><h4 id="binlog的写入机制-1"><a href="#binlog的写入机制-1" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h4><p>binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态如图1所示。</p><p><img src="/../images/9ed86644d5f39efb0efec595abb92e3e-8725160.png" alt="img"></p><p>可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。</p><ul><li>图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li><li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</li></ul><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><p>将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p><h4 id="redo-log的写入机制-1"><a href="#redo-log的写入机制-1" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h4><p><img src="/../images/9d057f61d3962407f413deebc80526d4-8725289.png" alt="img"></p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢多了。</p><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><h3 id="MySQL是怎么保证主备一致的？"><a href="#MySQL是怎么保证主备一致的？" class="headerlink" title="MySQL是怎么保证主备一致的？"></a>MySQL是怎么保证主备一致的？</h3><p><img src="/../images/fd75a2b37ae6ca709b7f16fe060c2c10.png" alt="img"></p><p>客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。这样可以保持节点B和A的数据是相同的。</p><p><img src="/../images/a66c154c1bc51e071dd2cc8c1d6ca6a3.png" alt="img"></p><ol><li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li><li>防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；</li><li>可以用readonly状态，来判断节点的角色。</li><li>因为readonly设置对超级(super)权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</li></ol><h2 id="Mysql是如何保证高可用"><a href="#Mysql是如何保证高可用" class="headerlink" title="Mysql是如何保证高可用"></a>Mysql是如何保证高可用</h2><p><img src="/../images/89290bbcf454ff9a3dc5de42a85a69cc.png" alt="img"></p><p>图 1 MySQL主备切换流程–双M结构</p><ol><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li><li>备库B执行完成这个事务，我们把这个时刻记为T3。</li></ol><p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。</p><p>你可以在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p><p>seconds_behind_master的计算方法是这样的：</p><ol><li>每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li><li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master。</li></ol><p>可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。</p><h4 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h4><p><strong>首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</strong></p><p><strong>第二种常见的可能了，即备库的压力大</strong>。一般的想法是，主库既然提供了写能力，那么备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。</p><p>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力</p><ol><li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li></ol><p>其中，一主多从的方式大都会被采用。因为作为数据库系统，还必须保证有定期全量备份的能力。而从库，就很适合用来做备份。</p><p><strong>这就是第三种可能了，即大事务。</strong></p><p>*另一种典型的大事务场景，就是大表DDL。**这个场景，我在前面的文章中介绍过。处理方案就是，计划内的DDL，建议使用gh-ost方案</p><h4 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h4><p>在图1的双M结构下，从状态1到状态2切换的详细过程是这样的：</p><ol><li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li><li>把主库A改成只读状态，即把readonly设置为true；</li><li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li><li>把备库B改成可读写状态，也就是把readonly 设置为false；</li><li>把业务请求切到备库B。</li></ol><p>这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。</p><p><img src="/../images/54f4c7c31e6f0f807c2ab77f78c8844a.png" alt="img"></p><p>图中的SBM，是seconds_behind_master参数的简写。</p><p>这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于readonly状态，也就是说这时系统处于不可写状态，直到步骤5完成后才能恢复。</p><p>在这个不可用状态中，比较耗费时间的是步骤3，可能需要耗费好几秒的时间。这也是为什么需要在步骤1先做判断，确保seconds_behind_master的值足够小。</p><h2 id="备库为什么会延迟好几个小时？"><a href="#备库为什么会延迟好几个小时？" class="headerlink" title="备库为什么会延迟好几个小时？"></a>备库为什么会延迟好几个小时？</h2><p><img src="/../images/1a85a3bac30a32438bfd8862e5a34eef.png" alt="img"></p><p>图1 主备流程图</p><p>我们要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主库，另一箭头代表的是备库上sql_thread执行中转日志（relay log）。如果用箭头的粗细来代表并行度的话，那么真实情况就如图1所示，第一个箭头要明显粗于第二个箭头。</p><p>在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。</p><p>而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。</p><p><img src="/../images/bcf75aa3b0f496699fd7885426bc6245.png" alt="img"></p><p>coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。而work线程的个数，就是由参数slave_parallel_workers决定的。根据我的经验，把这个值设置为8~16之间最好（32核物理机的情况），毕竟备库还有可能要提供读查询，不能把CPU都吃光了。</p><p>你需要先思考一个问题：事务能不能按照轮询的方式分发给各个worker，也就是第一个事务分给worker_1，第二个事务发给worker_2呢？</p><p>其实是不行的。因为，事务被分发给worker以后，不同的worker就独立执行了。但是，由于CPU的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。</p><p>同一个事务的多个更新语句，能不能分给不同的worker来执行呢？</p><p>答案是，也不行。举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。</p><p>coordinator在分发的时候，需要满足以下这两个基本要求：</p><ol><li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</li><li>同一个事务不能被拆开，必须放到同一个worker中。</li></ol><h1 id="MySQL-5-5版本的并行复制策略"><a href="#MySQL-5-5版本的并行复制策略" class="headerlink" title="MySQL 5.5版本的并行复制策略"></a>MySQL 5.5版本的并行复制策略</h1><h3 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。</p><p><img src="/../images/8b6976fedd6e644022d4026581fb8d76.png" alt="img"></p><p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。</p><p>有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。</p><p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。</p><h2 id="主库出问题了，从库怎么办？"><a href="#主库出问题了，从库怎么办？" class="headerlink" title="主库出问题了，从库怎么办？"></a>主库出问题了，从库怎么办？</h2><p><img src="/../images/aadb3b956d1ffc13ac46515a7d619e79.png" alt="img"></p><p>图1 一主多从基本结构</p><p>图中，虚线箭头表示的是主备关系，也就是A和A’互为主备， 从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p><p><img src="/../images/0014f97423bd75235a9187f492fb2453.png" alt="img"></p><p>图2 一主多从基本结构–主备切换</p><p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也要改接到A’。正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
